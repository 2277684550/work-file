素材

​	https://pan.baidu.com/s/1UlO7JAqIHzT2ET_Od_sn0g?from=init#list/path=%2F

​	提取码：h54h 

##  1.0

### 1.1 可视化创建vue项目

![image-20221217110845182](E:\备份\md文件\md图片存放\image-20221217110845182.png)

![image-20221117142915329](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142915329.png)

cmd命令

![image-20221117141141532](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141141532.png)

选择创建目录

![image-20221117141221677](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141221677.png)

![image-20221117141240541](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141240541.png)

创建项目

![image-20221117141430714](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141430714.png)

![image-20221117141507502](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141507502.png)

![image-20221117141559796](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141559796.png)

![image-20221117141747437](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141747437.png)

![image-20221117141854981](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117141854981.png)

### 1.2 安装插件与依赖

创建完毕来到仪表盘

![image-20221117142147931](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142147931.png)

安装element插件

![image-20221117142209233](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142209233.png)

![image-20221117142323971](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142323971.png)

![image-20221117142631546](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142631546.png)

安装依赖（axios库）

![image-20221117142743144](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142743144.png)

![image-20221117142830582](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117142830582.png)

### 1.3 初始化GIT远程仓库

登录码云平台

https://gitee.com/

![image-20221117143805367](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117143805367.png)

生成公钥，具体步骤可以点里面的如何生成公匙

![image-20221117144002245](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117144002245.png)

Git Bash Here命令运行

![image-20221117145804542](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117145804542.png)

`ssh-keygen -t ed25519 -C "注册码云的邮箱地址"`

生成地址

![image-20221117145310372](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117145310372.png)

验证是否添加成功

`ssh -T git@gitee.com`

输入两次，出现Hi，则表示成功

![image-20221117145709035](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117145709035.png)

### 1.4 本地项目托管到GitHub或者码云中 

码云中创建一个仓库

![image-20221117150029945](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117150029945.png)

![image-20221117150236751](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117150236751.png)

![image-20221117150458463](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117150458463.png)

![image-20221117150647487](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117150647487.png)

![image-20221117151336897](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117151336897.png)

![image-20221217111513194](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221217111513194.png)

```
git 仓库托管指令
git init
初始化当前目录为本地仓库
git add .
添加本地代码指令
git status
查看本地代码状态指令
git commit -m
提交代码到云端仓库
git branch
查看当前本地分支
git branch xxx
创建本地xxx分支
git checkout xxx
切换到本地xxx分支
git merge xxx
合并当前本地分支和xxx分支
```

命令依次为

` git status`

` git add .`

` git commit -m "add files"`

`git status`

`git remote add origin https://gitee.com/hua-xia-si/vue_shop.git`

`git push -u origin "master"`

![image-20221117151943520](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117151943520.png)

### 1.5 后台项目的环境安装配置

![image-20221117152531812](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117152531812.png)

从老师那下载的服务器

![image-20221117181648719](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117181648719.png)

也可以用该网址

`https://gitee.com/HUJIAFANGFUJIDDD/vue_api_server`

进行下载

![image-20221117182145971](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182145971.png)

解压后也有mydb.sql



官网下载phpStudy 2016版

![image-20221117181325181](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117181325181.png)

![image-20221117181448843](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117181448843.png)

导入mysql

![image-20221117181514156](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117181514156.png)

![image-20221117182320308](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182320308.png)

验证是否导入成功

![image-20221117182415661](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182415661.png)

里面有mydb文件夹且里面有文件则导入成功

![image-20221117182458861](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182458861.png)

![image-20221117182507264](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182507264.png)

### 1.6 测试后台接口是否正常

管理员命令cd进入服务器文件夹，并npm install 安装

![image-20221117182644631](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182644631.png)

然后数据库连接服务器 node .\app.js，不连接接口无法访问

![image-20221117182747682](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117182747682.png)

然后在apifox里面快捷请求接口，来判断接口是否能使用

![image-20221117183013817](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117183013817.png)

api文档

![image-20221117183036581](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117183036581.png)

![image-20221117183057409](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117183057409.png)

## 2.0

### 2.1 登录与退出![image-20221117193040873](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117193040873.png)

token原理分析![image-20221117193346762](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117193346762.png)

打开项目后首先运行终端

![image-20221117194111424](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117194111424.png)

如果暂存区不干净，便清空暂存区

![image-20221118003233421](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118003233421.png)

可视化vue运行项目

![image-20221117195001586](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117195001586.png)

清空项目无用代码

如App.vue,报错是因为安装了Linter，代码格式要求严格

![image-20221117195307547](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221117195307547.png)

#### 2.1.1登录组件布局

设置一个Login组件，并且在路由里面绑定并重定向

Login.vue

```vue
<template>
    <div class="login_container">
        登录组件
    </div>
</template>
<style scoped lang="less">
// 添加背景样式
.login_container{
        background-color: #2b4b6b;
    }
</style>
```

router/index.js

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

const routes = [
  {
    //路由重定向，当页面处于/时自动跳转到login
    path:'/',
    redirect:'/login'
  },
  {
    path:'/login',
    // 路由懒加载
    component:()=>import('../components/Login.vue')
  }
 
]

const router = new VueRouter({
  routes
})

export default router

```

并在APP.vue里面添加路由占位符

```vue
<template>
  <div id="app">
    <!--路由占位符 -->
    <router-view></router-view>
  </div>
</template>

<style lang="less">

</style>
```

此时页面显示为![image-20221118104525209](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118104525209.png)

没有全屏显示是因为html，body，#app这些标签都没有全屏

​		在assets下面创建一个css文件夹，里面创建一个global的css文件，然后在全局main.js里面引入

![image-20221118104826972](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118104826972.png)

global.css

```css
html,
body,
#app {
    height: 100%;
    margin: 0;
    padding: 0;
}
```

main.js

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import './plugins/element.js'
//引入全局样式
import './assets/css/global.css'

Vue.config.productionTip = false

new Vue({
  router,
  render: h => h(App)
}).$mount('#app')

```

此时背景颜色还是没有铺满，是因为Login.vue没有铺满

在Login.vue的css样式里面添加高度100%。

并且添加一个盒子将其居中

```css
<template>
    <div class="Login_container">
        <!-- 创建一个盒子，将盒子居中 -->
        <div class="login_box"></div>
    </div>
</template>

<script>
export default {

};
</script>

<style scoped lang="less">
    .Login_container{
        background-color: #2b4b6b;
        height: 100%;
    }
    .login_box{
        width: 450px;
        height: 300px;
        background-color: #ffff;
        border-radius: 3px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
    }
</style>

```

效果如下

![image-20221118140446377](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118140446377.png)

#### 2.1.2创建登录图标

```vue
<template>
    <!-- login容器 -->
    <div class="Login_container">
        <!-- 创建一个盒子，将盒子居中 -->
        <div class="login_box">
            <!-- 图标盒子 -->
            <div class="avatar_box">
                <img src="../assets/logo.png">
            </div>
        </div>
    </div>
</template>

<script>
export default {
};
</script>

<style scoped lang="less">
    .Login_container{
        background-color: #2b4b6b;
        height: 100%;
    }
    .login_box{
        width: 450px;
        height: 300px;
        background-color: #ffff;
        border-radius: 3px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
    }
    .avatar_box{
        height: 130px;
        width: 130px;
        border: 1px solid gray;
        border-radius: 50%;
        padding: 10px;//增加内边距，把图片挤进去
        box-shadow: 0 0 10px #ddd;//给边框加阴影，向外扩散10px
        position: absolute;
        left: 50%;
        transform: translate(-50%,-50%);
        background-color: #fff;
        img{
            // 因为图片本身是只有图像颜色画存在，其余地方都是空的,所以可以添加背景色，
            //这样中间留出来一个padding的距离
            width: 100%;
            height: 100%;
            // 图片本身（本身也是一个块元素）也设置成圆形
            border-radius: 50%;
            background-color: #eee;
        }
    }
</style>

```

#### 2.1.3创建登录框

1. 打开element官网

![image-20221118183904492](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118183904492.png)

删除掉多余的部分，最中如下

```vue
 <!-- 登录表单区域 -->
      <el-form ref="form"  label-width="80px">
        <el-form-item label="活动名称">
          <el-input ></el-input>
        </el-form-item>
      </el-form>
```

保存刷新后浏览器会报错

![image-20221118184052890](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118184052890.png)

是因为安装element组件时是按需安装，所以得需要在plugins/element.js中把需要用到的组件引入一下

plugins/element.js

```JS
import Vue from 'vue'
import { Button } from 'element-ui'
import { From } from 'element-ui'
import { FromItem } from 'element-ui'
import { Input } from 'element-ui'

Vue.use(Button)
Vue.use(From)
Vue.use(FromItem)
Vue.use(Input)

```

此时如果还报错

![image-20221118184336723](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118184336723.png)

可能是vue-router版本太高，重新安装一下低版本

`npm i vue-router@3.2.0`

多复制两个el-form

button按钮在官网找

![image-20221118192924272](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118192924272.png)

复制过来改个名字就行

登录框前面的图标也在官网找

![image-20221118193208183](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118193208183.png)

然后找到自己想要的图标，替换就行了

![image-20221118193324673](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221118193324673.png)

如果不想用官网的图标，可以引入阿里巴巴矢量图标库里面的图标，具体教程见此视频

https://www.bilibili.com/video/BV1E7411c7M8/?p=17&spm_id_from=pageDriver&vd_source=91ddac9bea3a3a81e5d8b9217a0225dc

最后结果如下

```vue
 <!-- 登录表单区域 -->
      <el-form ref="form" class="login_form">
        <!-- 用户名 -->
        <el-form-item>
          <el-input  prefix-icon="el-icon-s-custom" ></el-input>
        </el-form-item>
        <!-- 密码 -->
        <el-form-item>
          <el-input  prefix-icon="el-icon-lock" ></el-input>
        </el-form-item>
        <!-- 按钮 -->
        <el-form-item class="btns">
          <el-button type="primary">登录</el-button>
          <el-button type="info">重置</el-button>
        </el-form-item>
      </el-form>
```

样式部分

```css
.login_form{
  width: 80%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%,-20%);
}
.btns{
  display: flex;
  justify-content: center;
}
```

#### 2.1.4表单绑定数据

```vue
<!-- 登录表单区域 -->
      <!--绑定data数据，并且用rules绑定验证表单验证,用ref来上传表单信息-->
      <el-form
        ref="loginFromRef"
        class="login_form"
        :model="loginForm"
        :rules="loginFormRules"
      >
        <!-- 用户名 -->
        <el-form-item prop="username">
          <!--prop为要拿下面的input里的数据与loginFormRules属性相验证 -->
          <el-input prefix-icon="el-icon-s-custom" v-model="loginForm.username">
          </el-input>
        </el-form-item>
        <!-- 密码 -->
        <el-form-item prop="password">
          <!-- show-password为element自带的密码框属性,点击显示密码,再点隐藏 -->
          <el-input
            prefix-icon="el-icon-lock"
            v-model="loginForm.password"
            show-password
          >
          </el-input>
        </el-form-item>
        <!-- 按钮 -->
        <el-form-item class="btns">
          <el-button type="primary" @click="login()">登录</el-button>
          <el-button type="info" @click="resetLoginForm()">重置</el-button>
        </el-form-item>
      </el-form>
```

```js
 data() {
    return {
      loginForm: {
        username: "admin", //双向绑定,验证是否成功
        password: "123456",
      },
      // 表单验证规则
      loginFormRules: {
        // 验证用户名是否合法
        username: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入用户名", trigger: "blur" },
          // min为最小长度，max为最大长度
          {
            min: 3,
            max: 10,
            message: "长度在 3 到 10 个字符",
            trigger: "blur",
          },
        ],
        // 验证密码是否合法
        password: [
          { required: true, message: "请输入密码", trigger: "blur" },
          {
            min: 6,
            max: 15,
            message: "长度在 6 到 15 个字符",
            trigger: "blur",
          },
        ],
      },
    };
  },
```

#### 2.1.5 表单发起请求

首先打开phpstudy的mysql服务

![image-20221120090001169](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120090001169.png)

然后再管理员命令行进入服务器文件夹所在的目录

![image-20221120090056257](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120090056257.png)

然后再输入 node .\app.js 启动服务器

页面如下则启动成功

![image-20221120090143263](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120090143263.png)

该命令行不能关闭，关闭服务器便关了，就不能获取接口数据了

首先需要在main.js里面引入axios

```js
//配置axios
import axios from 'axios'
// 配置请求的根路径，接口
axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'
// 将axios引入全局组件，这样每一个vue组件都可通过this来访问http服务，从而发起axios请求
Vue.prototype.$http = axios
```

因为里面需要用到新的element组件，所以需要在element.js里面引入需要用到的组件

![image-20221119202935174](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119202935174.png)![image-20221119203001455](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119203001455.png)

button按钮绑定事件

![image-20221119202441079](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119202441079.png)

​											这是表单双向绑定的数据，在发起请求时需要携带的参数

![image-20221119202424340](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119202424340.png)

```js
login() {
      // this.$refs.loginFromRef为表单的引用对象,validate是对表单的预校验，里面会接收一个回调函数，
      // 返回一个boolean值，来返回表单的验证结果
      this.$refs.loginFromRef.validate((valid) => {
        // 如果valid为false，就取反，return，什么也不操作
        if (!valid) return;
        // this.$http为main.js里面挂载的根api地址，这样后面直接写需要访问的具体接口就行了，比较方便
        // 请求方式为post，里面有两个参数，第一个为请求地址，由于已经挂载了根地址，此时直接写具体接口就行了
        // 第二个参数为要访问的数据，原本需要用{数据1，数据2}来访问，但是this.loginForm里面已经写了双向绑定的input数据
        // 便可以直接写上，then是一个回调函数，接收返回值。返回值里面有一个data对象，里面才是我们需要的数据，
        this.$http.post("login", this.loginForm).then((res) => {
          console.log(res.data);
          // data里面有一个meta，我们请求的数据都在里面，里面有一个status属性，如果不为200则返回失败
          if (res.data.meta.status !== 200) {
            // 这是element自带的函数，用来弹出错误框，必须在element.js里面引入才能使用，不然报错
            this.$message.error('登录失败')//error为框类型，是一个错误框
            
          } else(  //反之则成功
            this.$message({
              message: "登陆成功",
              type: "success",//成功框
              duration:1000//持续时间
            })
          )
        });
      });
    },
```

#### 2.1.6 请求成功后保存token

创建一个home页面，并且引入路由

然后在上面的login事件里，else登录成功里面写入以下代码

```js
else(  //反之则成功
            this.$message({
              message: "登陆成功",
              type: "success",//成功框
              duration:1000//持续时间
            }),
            //  1.将登录成功之后的token，保存到客户端的 session Storage 中
            //     1.1 项目中除了登录之外的其他API接口，必须在登录之后才能访问
            //     1.2 token 只应在当前网站打开期间生效，所以将token 保存在 sessionStorage 中   
            window.sessionStorage.setItem('token',res.data.data.token),
            console.log(res.data),
            // 2.通过编程式导航跳转到后台主页，路由地址时 /home
            this.$router.push('/home')
          )
```

#### 2.1.7 路由守卫跳转login

router/index.js

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

const router = new VueRouter({
  routes : [
    { path: '/', redirect: '/login' },
    { path: '/login', component: () => import('../components/Login.vue') },
    { path: '/home', component: () => import('../views/Home.vue') }
  ]
})

//路由守卫
router.beforeEach((to,from,next) => {
  // to 将要访问的路径
  // from 代表从哪个路径跳转而来
  // next 是一个函数 表示放行
  //     next() 放行 next('/login') 强制跳转
  if(to.path === '/login') return next();//if所执行的代码如果只有一行，便可以不用写{}
  // 如果没有retuen出去，说明访问的是其他页面，这时候便需要判断是否有本地是否有token，
  // 获取token
  const tokenStr = window.sessionStorage.getItem('token')
  // 有token说明已经登录过了，可以访问，如果没有token则说明没有登录，便强制跳转登录页,if(!不存在的值){执行}
  if(!tokenStr) return next('/login')
  // 如果上面两个都没有return，便直接放行
  next()
  
}) 
//暴露路由
export default router

```

#### 2.1.8 退出登录

基于token的当时实现退出比较简单，只需要销毁本地的token 即可，后续的请求就不会携带token ，必须重新登录生成一个新的token值之后才能访问

Home.vue

```vue
<template>
    <div>
        我是主页
        <el-button type="info" @click="logout">退出</el-button>
    </div>
</template>

<script>
export default {
    methods: {
        logout(){
            // 清空token
            window.sessionStorage.clear(),
            // 跳转登录页
            this.$router.push('/login')
        }
    },
};
</script>

```

#### 2.1.9 提交代码到码云

项目目录下运行终端

输入以下命令

![image-20221119223303914](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119223303914.png)

推送代码到暂存区 `git add .`

![image-20221119223411440](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119223411440.png)

再次查看推送状况 变绿说明提交成功![image-20221119223518539](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119223518539.png)

推送到本地仓库 `git commit –m”次推送的名称”`   推送到的是login分支上

![image-20221119223740237](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119223740237.png)

合并分支（要合并与被合并）必须得处在要合并的分支上，切换分支，并把被合并的login分支合并到master主分支上，

![image-20221119223952392](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119223952392.png)

推送本地仓库到远程码云

首先在码云中找到仓库地址

![image-20221119224341456](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119224341456.png)

首次推送码云需要终端输入`git remote add origin 仓库地址`

![image-20221119224443367](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119224443367.png)

然后推送 `git push -u origin master` 发现报错

![image-20221119224628227](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119224628227.png)

接着输入 `git push -u origin master -f`  

![image-20221119224736924](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119224736924.png)

然后再次推送 `git push -u origin master` 便可成功

![image-20221119224758549](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119224758549.png)

然后还可以推送login分支到码云中

![image-20221119230641687](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221119230641687.png)

### 2.2 主页面布局

#### 2.2.1 框架布局

element官网

![image-20221120004936159](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120004936159.png)

因为想要的是第四个布局，找到对应的第四个代码

![image-20221120005018841](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005018841.png)

复制到Home.vue里面

但是此时会不起效果，是因为没有在element.js里面引用组件

![image-20221120005224873](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005224873.png)

引入之后发现高度没有满，那是因为最外层的el-container没有占满整个屏幕，给它绑定一个类名

![image-20221120005340667](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005340667.png)

![image-20221120005349896](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005349896.png)

然后给其他的组件都添加一个类名，名字都以组件名为准，然后都添加背景样式

![image-20221120005601041](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005601041.png)

![image-20221120005640765](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005640765.png)

#### 2.2.2 header布局

创建一个div，把图片和title放在一起，把退出登录按钮同级，然后在el-header的样式里面display：flex

![image-20221120005806477](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120005806477.png)

```less
.el-header{
    background-color: #363D40;
    display: flex;
    justify-content: space-between;
    padding-left: 0;
    align-items: center;
    div{
        height: 100%;
        display: flex;
        align-items: center;
        color: #fff;
        img{
        height: 80%;
        margin-right: 15px;
    }
    }
    
}
```

最终效果如下

![image-20221120010600176](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120010600176.png)

#### 2.2.3 侧边栏布局

element官网

![image-20221120010401919](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120010401919.png)

![image-20221120010650740](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120010650740.png)

复制之后，现在element.js里面引入这些组件，不然不生效

![image-20221120010831178](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120010831178.png)

因为有三四级导航，我们只需要二级导航，所以把多余的删掉

```vue
    <!-- 侧边栏 -->
      <el-aside width="200px" class="el-aside">
        <!-- 导航栏 -->
        <el-menu
      default-active="2"
      class="el-menu-vertical-demo"
      @open="handleOpen"
      @close="handleClose"
      background-color="#313743"
      text-color="#fff"
      active-text-color="#ffd04b">
      <!-- 一级菜单 -->
      <el-submenu index="1">
        <!-- 一级菜单的模板区 -->
        <template slot="title">
            <!-- 图标 -->
          <i class="el-icon-location"></i>
          <!-- 文本 -->
          <span>导航一</span>
        </template>
        <!-- 二级菜单 -->
        <el-menu-item>
          <!-- 把一级导航栏的图标复制一份到二级里面 -->
            <i class="el-icon-location"></i>
            <span>二级菜单</span>
        </el-menu-item>
      </el-submenu>
    </el-menu>
      </el-aside>
```

#### 2.2.4 接口获取左侧菜单数据

首先在main.js里面加入axios请求拦截

```js
axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'
// axios请求拦截
// 为保证其他的页面在每次请求时都确保是登录状态，便需要拦截器在请求之前加入token令牌，来让
// 后台知道此时已经登录
//request为请求，use为回调函数
axios.interceptors.request.use(config => {
  // 为请求头对象，添加 Token 验证的 Authorization 字段
  config.headers.Authorization = window.sessionStorage.getItem('token')
  //必须得return，不然请求就卡在这里了，因为请求发不出去了
  return config
})
```

然后在Home.vue里面创造一个生命周期函数，在页面启动时便要获取接口数据来加载页面

```js
export default {
  data(){
    return {
      // 左侧菜单数据
      menuList:''
    }
  },
  created(){
    //打开页面时就调用到全部菜单的内容
    this.getMenuList()
  },
  methods: {
    logout() {
      // 清空token
      window.sessionStorage.clear(),
        // 跳转登录页
        this.$router.push("/login");
    },
     // 获取所有菜单
    // await 关键字 只能放在 async 函数内部， await关键字的作用就是获取Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值
    // 如果await 后面并不是一个Promise的返回值，则会按照同步程序返回值处理,为undefined
    async getMenuList(){
      // const {数据中的一个对象 ：重新命名}
      const {data: res} = await this.$http.get('menus')
      // 如果不为200 则请求失败，弹出失败框
        if(res.meta.status !== 200) return this.$message.error(res.meta.msg);
        // 反之则把数据赋给本地
        this.menuList = res.data
    }
  },
};
```

在Home.vue的ui页面循环遍历菜单

因为有二级菜单，所以需要双循环

```vue
 <el-menu
      default-active="2"
      background-color="#313743"
      text-color="#fff"
      active-text-color="#ffd04b">
      <!-- 一级菜单 -->
      <!-- 循环遍历一级菜单，并且需要绑定一个唯一key值，因为数据里面有唯一id，所以直接引用数据里面的就行了
      因为每一个一级菜单也都有一个唯一的index，这样选中下拉时，不会影响其他的一级菜单，
      于是动态绑定:index等于数据里面id，但是此时页面会报错，是因为:index只接受字符串，而数据里面的id是数值
      所以加上以一个空字符串，强制转换类型 -->
      <el-submenu :index="item.id + ''" v-for="item in menuList" :key="item.id">
        <!-- 一级菜单的模板区 -->
        <template slot="title">
            <!-- 图标 -->
          <i class="el-icon-location"></i>
          <!-- 文本 -->
          <span>{{item.authName}}</span>
        </template>
        <!-- 二级菜单 -->
        <!-- 二级循环和一级循环一个道理，只不过需要把数据换成一级菜单里面二级菜单数据，也就是item.children -->
        <el-menu-item :index="subItem.id + ''" v-for="subItem in item.children" :key="subItem.id">
            <i class="el-icon-location"></i>
            <span>{{subItem.authName}}</span>
        </el-menu-item>
      </el-submenu>
    </el-menu>
```

效果如下

![image-20221120102731530](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120102731530.png)

此时一级菜单和二级菜单的图标都一样，我们需要修改一下

二级菜单统一用固定的图标，直接在二级菜单写死

![image-20221120102848033](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120102848033.png)

一级菜单的图标都不同，这里在data里面添加一个数组，里面放入需要的图标

```js
  iconObj:[
        'el-icon-s-check',
        'el-icon-mobile',
        'el-icon-shopping-bag-1',
        'el-icon-tickets',
        'el-icon-data-line'
      ]
```

然后在一级菜单的for循环里面添加一个index，有几个一级菜单，index的数组便从0递增多少，然后根据index的值来动态绑定数组里面的icon图标值

![image-20221120103114985](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120103114985.png)

效果如下

![image-20221120103317476](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120103317476.png)

但是此时可以同时打开多个一级菜单，这样不方便，我们要打开一个一级菜单时，其他的菜单折叠

此时element里面的菜单属性提供了方法，

![image-20221120103517723](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120103517723.png)

![image-20221120103738926](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120103738926.png)

现在还有一个问题，就是导航栏右侧没有对齐，选中的部分会超出区域

![image-20221120104004201](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120104004201.png)

这是因为导航栏有一个边框，我们把边框去掉就行了

![image-20221120104310089](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120104310089.png)

![image-20221120104345043](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120104345043.png)

此时便正常了

![image-20221120104405940](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120104405940.png)

#### 2.2.5 折叠侧边栏

首先在侧边栏里面加入一个可以点击的盒子，绑定事件和样式

![image-20221120115025053](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120115025053.png)

![image-20221120121927543](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120121927543.png)

data属性值

![image-20221120122135083](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120122135083.png)

点击事件

![image-20221120122118939](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120122118939.png)

点击按钮样式

![image-20221120122305800](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120122305800.png)

也可以在侧边的的样式里面自定义给切换过渡

![image-20221120122408028](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120122408028.png)

折叠时宽度为64px

![image-20221120122034873](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120122034873.png)

#### 2.2.6 二级菜单路由跳转

首先给Home.vue组件重定向，就是当登录成功跳转/home时，让它显示一个欢迎界面，这需要先写一个weclome组件

weclome.vue

![image-20221120124828988](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120124828988.png)

然后在路由里面重定向，因为是在home组件里面，所以应该是home路由的子路由

![image-20221120125108094](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125108094.png)

然后在Home.vue的main主题里面添加路由占位符便可以显示了，如果不需要添加路由跳转按钮，便不需要路由入口

![image-20221120125211736](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125211736.png)

然后给每个二级菜单添加路由链接

element官网自带属性，默认时false

![image-20221120125345105](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125345105.png)

![image-20221120125536725](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125536725.png)

因为跳转时会以index作为path的路径名称，我们之前的index是为![image-20221120125916744](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125916744.png),但是id不具有识别度，

![image-20221120125856257](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125856257.png)

发现数据里面的二级菜单还有一个path属性，这个里面的值具有识别度，我们把它作为路由的path跳转名称

![image-20221120130229996](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120130229996.png)

把二级菜单里面的：index更改成![image-20221120125952856](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120125952856.png)

现在访问的便是path的地址了![image-20221120130035802](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120130035802.png)

#### 2.2.7 二级菜单选中常亮

此时选中是亮的，

![image-20221120201834605](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120201834605.png)

但是路由跳转再返回后，就不亮了，也不展开二级菜单了，我们需要把它设置成常亮

![image-20221120201955584](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120201955584.png)

element自带属性

![image-20221120202111564](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120202111564.png)

1.这个属性需要传进去的值就是子导航的index值（也就是其路由值），达到点击路由就可以引起高亮。

​	因为这个属性是在侧边栏上面才能生效，所以先动态绑定一个空值

![image-20221120202605539](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120202605539.png)

![image-20221120202756335](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120202756335.png)

2.然后在每个二级菜单上面都绑定一个事件，点击事件，传入该二级菜单的路由名称

![image-20221120202714313](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120202714313.png)

3.每点击一次事件，便将所点击的二级菜单路由的path值传到本地，并取名为activePath

![image-20221120220845758](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120220845758.png)

4.在页面每一次重新加载时，用钩子函数获取本地的activePath值，然后赋给组件的数据，：default-active获取到本地的组件数据

便可以让那个二级菜单常亮了，必须得获取，不获取，页面返回上一步时便不会常亮

![image-20221120203800397](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120203800397.png)

### 2.3 用户列表布局

#### 2.3.1 用户列表ui结构

Users.vue

官网获取代码

![image-20221120235504509](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120235504509.png)

把多余的部分删掉

```vue
  <!-- 面包屑导航区域 -->
    <el-breadcrumb>
        <!-- 当点击首页时，路由跳转到首页 -->
      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>用户管理</el-breadcrumb-item>
      <el-breadcrumb-item>用户列表</el-breadcrumb-item>
    </el-breadcrumb>
```

element.js引入组件

![image-20221120235649847](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120235649847.png)

![image-20221120235700020](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120235700020.png)

官网获取代码

删的只剩外面的一个card就行了，用来当背景板

![image-20221120235814116](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221120235814116.png)

只要一行两列，要一个row包裹两个col就行了一个col包裹一个搜索框，另一个包裹按钮

![image-20221121000320255](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221121000320255.png)

获取搜索框，删除下拉表单和按钮，按钮自定义一个放在col里面

![image-20221121000132937](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221121000132937.png)

element.js引入组件

![image-20221121001924456](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221121001924456.png)![image-20221121001939621](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221121001939621.png)

删掉多余的部分，代码如下

```vue
 <!-- 卡片视图区 -->
    <el-card>
      <!-- 搜索与与添加区域 -->
      <el-row :gutter="20">  <!-- :gutter设置的是列与列之间的距离 -->
         <!-- 第一列是input搜索框 -->
        <el-col :span="8">  <!-- 一行被分成24块 ，第一列占8块 -->
          <el-input placeholder="请输入内容">
            <el-button slot="append" icon="el-icon-search"></el-button>
          </el-input>
        </el-col>
         <!-- 第二列是一个button按钮 -->
        <el-col :span="4">  <!-- 第二列占4块 -->
            <el-button type="primary">添加用户</el-button>  <!-- primary是element的蓝色确定按钮样式 -->
        </el-col>
      </el-row>
    </el-card>
```

在再global.css里面全局定义样式，之所以全局设置是因为其他的组件也需要用到element的卡片，所以直接全局，不用重复写了

这里的类名直接就是element的标签名，这是因为element的标签本身就是一个类名，所以可以直接复制标签再在前面加一个点，便可以定义标签了

```css
.el-breadcrumb{
    font-size: 15px;
    margin-bottom: 15px;
}
.el-card{
    box-shadow: 0 1px 1px rgba(0,0, 0, 0.15) !important;
}
```

#### 2.3.2 获取用户列表数据并渲染 

打开我们的api文档

![image-20221121003158456](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221121003158456.png)

Users.vue

```js
 data() {
    return {
      // 获取用户列表的参数对象
      queryInfo: {
        query: "", //查询参数
        pagenum: 1, //当前页码
        pagesize: 2, //每页显示条数
      },
      //创建两个属性用来接收响应的数据
      //如果接收的是一个对象，那么必须是一个数组形式，而不是''
      userlist:[],
      total:0
    };
  },
  created() {
    // 2.创建页面时触发事件
    this.getUserList();
  },
  methods: {
    // 1.先定义一个事件
    // 异步函数
    async getUserList() {
      const { data: res } = await this.$http.get("users", { //await可以获取promise对象
        params: this.queryInfo,  //携带的参数是一个对象，get请求适用params指定对象
      });
      //如果返回失败则弹出报错框
      if(res !== 200) return this.$message.error('数据获取失败');
      //将接收的数据传到组件内部
      this.userlist = res.data.users;
      this.total = res.data.total;
      console.log(res);
    },
  },
```

返回的数据

![image-20221121003504989](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221121003504989.png)

渲染数据

element官网

![image-20221122101259011](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122101259011.png)

![image-20221122101542984](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122101542984.png)

![image-20221122101728264](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122101728264.png)

删改代码如下,代码放到卡片标签el-card里面，记得在element.js里面引入组件，

```vue
 <!-- 用户列表区 -->
      <el-table :data=" userlist" border stripe>
        <!-- 在最前面加一个索引列，label是列名，prop是上面userlist里面的数据 -->
        <el-table-column  label="#" type="index" ></el-table-column>
        <el-table-column  label="姓名" prop="username"></el-table-column>
        <el-table-column  label="邮箱" prop="email"></el-table-column>
        <el-table-column  label="电话" prop="mobile"></el-table-column>
        <el-table-column  label="角色" prop="role_name"></el-table-column>
        <el-table-column  label="状态" prop="mg_state"></el-table-column>
        <el-table-column  label="操作"></el-table-column>
      </el-table>
```

效果如下

![image-20221122101933523](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122101933523.png)

动态的更改表格状态

​	为什么要使用作用域插槽

​	  1.不能够直接el-switch,v-model绑定prop的mg_state，只有prop才能获取到mg_state的数据

​      但是v-model是双向绑定，获取不到数据，会报错，所以需要插槽作用域获取子组件的所有数据

​     2.因为一个table表格便是一个组件，若把table表格作为父组件，其他组件接收父组件数据就得需要插槽

​      而插槽是父传子，需要一个一个的传，比较麻烦，如果用子传父，便可以用作用域插槽，

​      直接让父组件获取子组件的所有数据，所以应把表格组件作为一个子组件

​      3.在状态栏里面创建一个父组件，便可以用slot-scope = "scope"获取子组件的所有数据 :data=" userlist，

​      scope是获取到表格的所有数据，scope.row便是获取表格的每一行数据 scope.column是获取每一列

```vue
<el-table-column  label="状态" prop="mg_state">
          <!-- 
						1.不能够直接el-switch,v-model绑定prop的mg_state，只有prop才能获取到mg_state的数据
            但是v-model是双向绑定，获取不到数据，会报错，所以需要插槽作用域获取子组件的所有数据
            2.因为一个table表格便是一个组件，若把table表格作为父组件，其他组件接收父组件数据就得需要插槽
            而插槽是父传子，需要一个一个的传，比较麻烦，如果用子传父，便可以用作用域插槽，
            直接让父组件获取子组件的所有数据，所有应把表格组件作为一个子组件
            3.在状态栏里面创建一个父组件，便可以用slot-scope = "scope"获取子组件的所有数据 :data=" userlist，
            scope是获取到表格的所有数据，scope.row便是获取表格的每一行数据 scope.column是获取每一列-->
          <template slot-scope = "scope">
            {{scope.row}}
            <el-switch v-model="scope.row.mg_state"></el-switch>
          </template>
        </el-table-column>
```

![image-20221122105800342](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122105800342.png)

最后把这个删除就行了

![image-20221122105819621](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122105819621.png)

并且因为作用域了插槽，就会把上面的prop的数据覆盖掉，prop就没有用了，便可以删掉

![image-20221122111815514](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122111815514.png)

#### 2.3.3 分页器

element官网

![image-20221122170918403](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122170918403.png)

![image-20221122170942998](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122170942998.png)

然后element.js里面注册组件

```vue
<!--放在表格下面-->
</el-table>
      <!-- 分页区 -->
      <!-- @size-change 只要切换下拉框，便触发
           @current-change 页码值只要切换，就立刻触发 
          :current-page 当前显示的是第几页
          :page-sizes 下拉框的选项
          :page-size 当前情况下每页显示多少条数据
          layout 页面需要展示那些组件 total：显示共多少条 sizes：在页面上显示下拉菜单 
          :total 总共有多少条数据
          -->
      <el-pagination 
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange" 
        :current-page="queryInfo.pagenum"
        :page-sizes="[1, 2, 5, 10]"
        :page-size="queryInfo.pagesize"
        layout="total, sizes, prev, pager, next, jumper"
        :total="total"
      >
      </el-pagination>
    </el-card>
<!--放在卡片里面-->
```

​	里面的参数怎么更改呢，首先咱们发起请求时

![image-20221122172640181](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122172640181.png)

![image-20221122173446854](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122173446854.png)

我们第一次发起请求时，携带的参数为显示第一页，每一页显示两条数据，然后服务器便会响应，返回数据

![image-20221122174020718](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122174020718.png)

总共有四条数据，又因为我们让每页显示两条数据，所有便会分成两页，每页两天数据

但是这样便是静态的了，为了能够动态更改这些数据，我们先给下拉框绑定事件

![image-20221122180209672](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180209672.png)

![image-20221122174931085](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122174931085.png)

此时便可以动态更改每一页显示多少条数据了，

![image-20221122175104531](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122175104531.png)

![image-20221122175140705](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122175140705.png)

但是此时的页码值却不能跳转，也得给页码值绑定事件

![image-20221122175328310](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122175328310.png)

道理与下拉框事件绑定一样，也是事件接收当前选中的页码值，然后赋给请求参数里面，然后再次发起后台请求，返回响应参数，再让![image-20221122180356242](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180356242.png)实时渲染返回的参数数据

![image-20221122180244415](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180244415.png)

因为之前便在响应参数里面返回了一个total值![image-20221122180635468](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180635468.png)也就是数据总量，

![image-20221122180817771](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180817771.png)

我们在本地接收这个数据![image-20221122180724194](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180724194.png)

然后分页器动态显示总共有多少天数据

![image-20221122180909939](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180909939.png)

此时完成效果

![image-20221122180950439](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122180950439.png)

#### 2.3.4 实时更改数据库用户状态

因为更改状态后，刷新，switch按钮还是原本的状态，因为按钮只在前端生效，前端更改状态后，并没有更改后端数据，所有需要更改数据库用户状态

首先先给switch按钮绑定一个事件，即switch按钮自带的事件

![image-20221122214119323](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122214119323.png)

事件里面传入每一行的数据

![image-20221122214138827](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122214138827.png)

查看api文档，如果更改用户状态，

put请求是专门的修改后台数据请求

![image-20221122214433406](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122214433406.png)

因为put请求必须携带参数，而且需要携带的参数![image-20221122225640487](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122225640487.png)这里面都有

![image-20221122225749161](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221122225749161.png)

#### 2.3.5 实现搜索功能

因为api文档里面请求用户数据列表里面携带了查询参数

![image-20221124025209220](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124025209220.png)

![image-20221124025332542](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124025332542.png)

![image-20221124025249784](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124025249784.png)

那么我们只需要获取搜索框的数据给query，然后button按钮绑定请求事件，把查询参数给后台，然后返回查询的结果就行了

首先让搜索框按钮与queryInfo的query数据双向绑定，这样能够获取输入框的值，然后绑定请求事件

![image-20221124025659445](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124025659445.png)

由于我们点击搜索框搜索后，想要有一个清空框来清空内容，便需要element库的属性

![image-20221124025906058](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124025906058.png)

只写一个属性，不赋值，则默认为true

但是此时只能清空内容，而不能够让搜索后的内容重新返回没有搜索值的样子，此时需要再给input绑定一个事件，让内容清空后，会再次发起后台请求，请求查询参数为空的数据，而element库提供了属性![image-20221124030302423](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124030302423.png)

![image-20221124030154545](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124030154545.png)

此时便完成了搜索效果

#### 2.3.6 添加用户表单

1.先给添加按钮绑定一个对话框，点击按钮时弹出对话框

element库

![image-20221124120901667](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124120901667.png)

把这段代码放在buttion按钮下面，并且在element.js里面引入组件 ，slot = “fotter” 为按钮显示在右下角

![image-20221124121610339](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124121610339.png)

此时点击button按钮，弹出对话框，点击取消、确定和页面的其他地方都会隐藏对话框

2.我们在对话框里面添加一个表单，在里面添加用户信息

```vue
 <!-- 给添加用户按钮绑定对话框 -->
        <el-dialog title="添加用户" :visible.sync="AddUserVisible">
          <!-- :model 与data数据双向绑定 :rules 绑定表单验证规则 
            ref 向后台上传信息 label-width 表单的宽度 -->
          <el-form
            :model="AddUserForm"
            :rules="AddUserFormRules"
            ref="AddUserFormRef"
            label-width="70px"
          >
          <!-- 用户名框 -->
          <!-- prop为要拿下面的input里的数据与AddUserFormRules属性相验证 -->
            <el-form-item label="用户名" prop="username">
              <!-- 与本地data数据双向绑定 -->
              <el-input v-model="AddUserForm.username"></el-input>
            </el-form-item>
            <!-- 密码框 -->
            <el-form-item label="密码" prop="password">
              <el-input
                v-model="AddUserForm.password"
                type="password"
                show-password
              ></el-input>
            </el-form-item>
            <!-- 邮箱框 -->
            <el-form-item label="邮箱" prop="email">
              <el-input v-model="AddUserForm.email"></el-input>
            </el-form-item>
            <!-- 手机号框 -->
            <el-form-item label="手机" prop="mobile">
              <el-input v-model="AddUserForm.mobile"></el-input>
            </el-form-item>
          </el-form>
          <!-- button按钮 -->
           <!-- slot = “fotter” 为按钮显示在右下角 -->
          <div slot="footer" >
            <el-button @click="AddUserVisible = false">取 消</el-button>
            <el-button type="password" @click="AddUserVisible = false"
              >确 定</el-button
            >
          </div>
        </el-dialog>
```

data数据

```js
 // 对话框隐显
      AddUserVisible: false,
      // 双向绑定添加用户表单
      AddUserForm: {
        username: "adimin1", //双向绑定,验证是否成功
        password: "123456",
        email: "1111",
        mobile: "11111111111",
      },
      // 添加用户表单验证规则
      AddUserFormRules: {
        // 用户名验证规则
        username: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入用户名", trigger: "blur" },
          // min为最小长度，max为最大长度
          {
            min: 3,
            max: 10,
            message: "长度在 3 到 10 个字符",
            trigger: "blur",
          },
        ],
        // 密码验证规则
        password: [
          { required: true, message: "请输入密码", trigger: "blur" },
          {
            min: 6,
            max: 15,
            message: "长度在 6 到 15 个字符",
            trigger: "blur",
          },
        ],
          // 邮箱验证规则
        email: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入邮箱", trigger: "blur" },
          // min为最小长度，max为最大长度
          {
            min: 3,
            max: 10,
            message: "长度在 3 到 10 个字符",
            trigger: "blur",
          },
        ],
          // 手机号验证规则
        mobile: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入手机号", trigger: "blur" },
          // min为最小长度，max为最大长度
          {
            min: 11,
            max: 11,
            message: "请输入11号码",
            trigger: "blur",
          },
        ],
      },
```

效果如下

![image-20221124122853974](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124122853974.png)

3.此时虽然已经完成了表单效果，但是邮箱的验证规则并不符合规范，所以我们需要自定义验证规则

首先需要在data里面定义两个变量

```js
data() {
    // 验证邮箱的规则
    // value为要校验的值 ,cb为回调函数,直接调用cb说明校验通过 ,
    // 如果调用cb的时候提供了一个Error对象,说明校验失败
    var checkEmail = (rule,value,cb) => {
      // 验证邮箱的正则表达式
      const regEmail = /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/
      // 如果校验通过,则返回成功
      if(regEmail.test(value)){
        return cb()
      }
      // 校验失败,返回一个失败的对象
      cb(new Error('请输入合法的邮箱'))
    }
    // 验证手机号的规则
    var checkMobile = (rule,value,cb) => {
      // 验证手机号的正则表达式
      const regMobile = /^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]{8}$/
      if(regMobile.test(value)){
        return cb()
      }
      cb(new Error('请输入合法的手机号'))
    }
    return {
      // 获取用户列表的参数对象
    		其他内容已折叠
        // 邮箱验证规则
        email: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入邮箱", trigger: "blur" },
          // 通过 validator 指定具体的校验规则 通过 trigger 来指定校验时机
          {
            validator:checkEmail,
            trigger: "blur",
          },
        ],
        // 手机号验证规则
        mobile: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入手机号", trigger: "blur" },
          {
            validator:checkMobile,
            trigger: "blur",
          },
        ],
      },
    };
  },
```

#### 2.3.7 重置表单

![image-20221124165340879](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124165340879.png)

**重置**

当表单关闭时，触发关闭函数close，

```vue
<!-- 给添加用户按钮绑定对话框 -->
        <el-dialog title="添加用户" :visible.sync="AddUserVisible" @close="UserDialogClosed">
```

事件

```js
// 监听添加用户对话框的关闭事件
    UserDialogClosed(){
      // this指向Login组件，获取其数据，$refs是组件里面的一个对象，AddUserFormRef是上面表单上传的表单信息
      // resetFields()是element自带的函数，对整个表单进行重置，将所有字段值重置为初始值并移除校验结果
      this.$refs.AddUserFormRef.resetFields()
    },
```

#### 2.3.8 后台添加新用户

**首先是一个预校验**

点击确定按钮时，触发

![image-20221124165311634](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124165311634.png

![image-20221124165255552](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221124165255552.png)

```js
 // 点击按钮,添加新用户
    AddUser(){
      // this.$refs.AddUserFormRef为表单的引用对象,validate是对表单的预校验，里面会接收一个回调函数，
      // 返回一个boolean值，来返回表单的验证结果
      this.$refs.AddUserFormRef.validate(valid => {
        if(!valid) return
        //可以发起添加用户的网络请求
      })
    }
```

然后朝回调函数里面添加网络请求

```js
 // 点击按钮,添加新用户
    AddUser(){
      // this.$refs.AddUserFormRef为表单的引用对象,validate是对表单的预校验，里面会接收一个回调函数，
      // 返回一个boolean值，来返回表单的验证结果
      this.$refs.AddUserFormRef.validate(async valid => {
        if(!valid) return
        //可以发起添加用户的网络请求
       const {data:res} = await this.$http.post('users',this.AddUserForm);
       if(res.meta.status != 201){
        this.$message.error('添加用户失败')
       }
       this.$message.success('添加用户成功')
      //  隐藏添加用户对话框
       this.AddUserVisible = false;
      //  因为添加后需要显示新增,就得刷新页面,重新请求后台数据渲染
      this.getUserList
      })
    }
```

#### 2.3.9 编辑用户并提交

1.给编辑按钮绑定事件，点击显示对话框，并且在对话框里面添加表单

![image-20221125004204093](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004204093.png)

```vue
 <!-- 操作列 -->
        <el-table-column label="操作" width="180px">
          <template slot-scope="scope">
            <!-- 修改按钮 -->
						<!-- 使用tooltip提示框，会导致下面的button的点击事件失效，必须用span把button按钮和对话框包裹起来，点击事件才能生效
								但是用span包裹之后，原本的样式会失效，所以在需要在三个button按钮外面用一个盒子包裹起来，然后用弹性盒子布局
								这里没有写全代码，最下面应该还有剩下的两个按钮-->
            <div class="operate">
              <el-tooltip
                class="item"
                effect="dark"
                content="修改"
                placement="top"
                :enterable="false"
              >
                <span>
                  <el-button
                    @click="showEditDialog(scope.row.id)"
                    type="primary"
                    icon="el-icon-edit"
                    size="mini"
                  ></el-button>
                  <!-- 给编辑绑定对话框 -->
                  <!-- 给添加用户按钮绑定对话框 -->
                  <el-dialog
                    title="修改用户"
                    :visible.sync="editDiaVisible"
                    @close="editDialogClosed()"
                  >
                    <!-- :model 与data数据双向绑定 :rules 绑定表单验证规则 
            ref 向后台上传信息 label-width 表单的宽度 -->
                    <el-form
                      :model="editForm"
                      :rules="editFormRules"
                      ref="editFormRef"
                      label-width="70px"
                    >
                      <!-- 用户名框 -->
                      <!-- prop为要拿下面的input里的数据与AddUserFormRules属性相验证 -->
                      <el-form-item label="用户名">
                        <!-- 与本地data数据双向绑定 -->
                        <el-input
                          v-model="editForm.username"
                          disabled
                        ></el-input>
                      </el-form-item>
                      <!-- 邮箱框 -->
                      <el-form-item label="邮箱" prop="email">
                        <el-input v-model="editForm.email"></el-input>
                      </el-form-item>
                      <!-- 手机号框 -->
                      <el-form-item label="手机" prop="mobile">
                        <el-input v-model="editForm.mobile"></el-input>
                      </el-form-item>
                    </el-form>
                    <!-- button按钮 -->
                    <div slot="footer">
                      <el-button @click="editDiaVisible = false"
                        >取 消</el-button
                      >
                      <el-button
                        type="primary"
                        @click="editUserInfo(scope.row.id)"
                        >确 定</el-button
                      >
                    </div>
                  </el-dialog>
                </span>
              </el-tooltip>
```

大部分操作都与添加用户表单差不多

2.通过后台查询id，获取当前编辑行的数据，然后同步到编辑用户里面

![image-20221125004233719](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004233719.png)

api文档

![image-20221125004601308](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004601308.png)

即给修改按钮绑定一个事件，点击按钮，获取后台数据，因为请求数据里面需要用户id，所以用scope获取子组件（显示表单）的所有数据。

scope.row.id为点击编辑按钮那一行的用户id

![image-20221125004441102](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004441102.png)



data数据

![image-20221125004821704](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004821704.png)

点击事件

![image-20221125004517993](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004517993.png)

获取本地的editForm数据，并绑定form表单，达到点击哪个编辑按钮，便从后台获取那一行的数据，然后在编辑表单里面显示

![image-20221125004724202](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125004724202.png)

3.给表单绑定验证规则

![image-20221125005610435](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125005610435.png)

data数据

```js
 editFormRules: {
        // 邮箱验证规则
        email: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入邮箱", trigger: "blur" },
          // 通过 validator 指定具体的校验规则 通过 trigger 来指定校验时机
          {
            validator: checkEmail,
            trigger: "blur",
          },
        ],
        // 手机号验证规则
        mobile: [
          //required为必填项，message为验证错误时触发的提示，trigger为触发条件，这里为失去焦点触发
          { required: true, message: "请输入手机号", trigger: "blur" },
          // min为最小长度，max为最大长度
          {
            validator: checkMobile,
            trigger: "blur",
          },
        ],
      },
```

4.重置表单

给对话框绑定事件，即对话框自带的关闭触发的函数



![image-20221125005731065](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125005731065.png)

```js
 // 监听修改对话框的关闭事件
    editDialogClosed() {
      // 清空表单（这里是只清空修改内容，但是原本获取到的数据还在）
      this.$refs.editFormRef.resetFields();
      // 点击取消隐藏对话框
      this.editDiaVisible = false;
    },
```

5.修改后台的数据

api文档

![image-20221125010125923](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125010125923.png)

给确定按钮绑定事件，点击确定，修改数据，这里也要传参用户id，因为网络请求需要用户id

![image-20221125010049682](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125010049682.png)

```js
// 编辑内容提交后台
    editUserInfo(id) {
      // 表单预验证
      this.$refs.editFormRef.validate(async (valid) => {
        // 网络请求,更改数据
        const { data: res } = await this.$http.put(`users/${id}`, {
          // 需要携带参数,邮箱和手机号
          email: this.editForm.email,
          mobile: this.editForm.mobile,
        });
        if(res.meta.status !== 200)return this.$message.error('获取用户信息失败')
        // 如果修改成功,关闭对话框
        this.editDiaVisible = false
        // 刷新页面
        this.getUserList()
        // 弹出成功提示框
        this.$message.success('更新用户信息成功')
      });
    },
```

#### 2.3.10 删除用户

![image-20221125112223571](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125112223571.png)

首先给删除按钮绑定一个点击事件，因为需要删除按钮所在行的数据，所有需要传入该行的id

![image-20221125111218821](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125111218821.png)

element.js

​	该组件不是引入使用，而是引入之后挂载到全局

![image-20221125112310583](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125112310583.png)

![image-20221125112340491](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125112340491.png)

点击事件

```js
// 删除提示框事件
    async  removeUserById(id){
      // 第一个参数为要显示的内容，第二个参数为title标题
      const {data:res} = await this.$confirm('此操作将永久删除该用户, 是否继续?', '提示', {
          // 确定按钮
          confirmButtonText: '确定',
          // 取消按钮
          cancelButtonText: '取消',
          // 前面的图标类型
          type: 'warning'
        })
        console.log(res);
    }
```

此时点成功 控制台返回![image-20221125112528476](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125112528476.png)

但是此时点击取消会报错

![image-20221125111331739](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125111331739.png)

这是因为点取消会触发$confirm里面的一个错误，需要在$confirm捕获这个错误，用catch

![image-20221125112156469](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125112156469.png)

此时再点取消

 控制台输出的便是![image-20221125112453712](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125112453712.png)

于是我们便可以根据这两个返回值来判断用户是否删除用户，如果为cancel则取消删除，弹出取消删除提示信息，如果为confirm

则是确认删除，那么就需要删除后台的数据并刷新页面

取消删除

​	![image-20221125113136884](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125113136884.png)

确认删除

​	![image-20221125125420697](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125125420697.png)



#### 2.3.11 分配用户

![image-20221201230622365](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201230622365.png)

可视区域

```vue
<el-button
type="warning"
icon="el-icon-setting"
size="mini"
@click="setRole(scope.row)"
></el-button>
<el-dialog
title="提示"
:visible.sync="setRoleDialogVisible"
width="30%"
@close="setRoleDialogClosed"
>
<div>
<p>当前的用户：{{ userInfo.username }}</p>
<p>当前的角色：{{ userInfo.role_name }}</p>
<p>
分配新角色：
<!-- v-model绑定的值为选中的值，用来携带在请求参数里面请求数据 -->
<el-select v-model="selectedRoleId" placeholder="请选择">
<!-- 循环渲染角色 -->
<el-option
v-for="item in roleList"
:key="item.id"
:label="item.roleName"
:value="item.id"
>
</el-option>
</el-select>
</p>
</div>
<span slot="footer">
<!-- 点击隐藏对话框 -->
<el-button @click="setRoleDialogVisible = false"
>取 消</el-button
>
<el-button
type="primary"
@click="saveRoleInfo"
>确 定</el-button
>
</span>
</el-dialog>
```

data

```js
// 控制分配角色对话框的显示与隐藏
setRoleDialogVisible:false,
// 需要被分配角色的用户信息
userInfo:'',
// 所有角色的数据列表
roleList:'',
// 已选择的角色id值
selectedRoleId:''
```

api文档

![image-20221201230646036](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201230646036.png)

行为区域

```js
 // 展示分配角色对话框
    setRole(userInfo){
      // 将每一行的值赋给本地数据
      this.userInfo = userInfo
      // 在展示对话框之前，获取所有角色的列表
      this.$global.request(this,'roles','get','',200,'获取角色列表失败')
      .then(val => {
        // 获取角色列表里的角色数据赋给本地
        this.roleList = val
      })
      // 显示对话框
      this.setRoleDialogVisible = true 
    },
    // 点击分配角色确定按钮事件
    saveRoleInfo(){
      // 如果什么都没有选择，便点击确定，则弹出提示框
      if(!this.selectedRoleId){
        return this.$message.error('请选择要分配的角色！')
      }
      // 更改后台数据
      this.$global.request(this,'users/'+this.userInfo.id+'/role','put',{rid:this.selectedRoleId},200,'更新角色失败')
      .then(val => {
        // 刷新页面
        this.getUserList(),
        // 关闭对话框
        this.setRoleDialogVisible = false
      })
    },
    // 监听分配角色对话框的关闭事件
    setRoleDialogClosed(){
      // 让选择的内容为空，方便用户重新选择
      this.selectedRoleId = '',
      // 令展示数据为空，方便重新选择
      this.userInfo = ''
    }
```



#### 2.3.12 提交用户列表功能到码云



![image-20221125130724603](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125130724603.png)

第一次推送分支到远程仓库需要加 -u  `git push -u origin user`

![image-20221125131733135](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125131733135.png)

![image-20221125131837866](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125131837866.png)

![image-20221125131855957](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125131855957.png)推送成功

### 2.4 权限管理布局

#### 2.4.1 创建分支

![image-20221125132425683](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125132425683.png)

#### 2.4.2 创建权限组件并路由

![image-20221125133431822](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125133431822.png)

在index.js里面添加子路由，因为是要该组件在Home.vue里面显示的，所有路由也必须写成Home.vue的子路由，不然就不是在组件内部显示，而是在一个新页面显示了

![image-20221125133617488](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125133617488.png)

#### 2.4.3 渲染权限列表页面

![image-20221125143321775](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125143321775.png)

1.添加面包屑导航和卡片

​	面包屑之前做的user页面有，直接复制过来就行

```vue
<template>
<!-- 必须把所有的组件内容用一个标签包裹起来，不然报错，这里div不能删除 -->
    <div>
     <!-- 面包屑导航区域 -->
     <el-breadcrumb>
      <!-- 当点击首页时，路由跳转到首页 -->
      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>权限管理</el-breadcrumb-item>
      <el-breadcrumb-item>权限列表</el-breadcrumb-item>
    </el-breadcrumb>
    <el-card>
             <!-- 表格区 -->
    </el-card>
</div>
</template>
```

2.

api文档

![image-20221125143207564](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125143207564.png)

卡片里面添加表格

行为区域

```js
data() {
        return {
            // 接收后台数据
            rightsList:[]
        };
    },
    // 页面初始化触发
    created(){
        // 网络请求后台数据
        this.getRightsList()
    },
    methods: {
        async getRightsList(){
            const {data:res} = await this.$http.get('rights/list')
            if(res.meta.status !== 200) return this.$message.error('请求数据失败')
            // 将后台数据赋给data数据
            this.rightsList = res.data
        }
    },
```

可视区域

```vue
<el-card>
        <!-- :data获取数据，border给表格加边框线，stripe加斑马纹 -->
        <el-table :data="rightsList" border stripe>
            <!-- 索引列 -->
            <el-table-column label="#" type="index"></el-table-column>
            <!-- 名称列 ，prop为要渲染的数据 -->
            <el-table-column label="权限名称" prop="authName" ></el-table-column>
            <!-- 路径列 -->
            <el-table-column label="路径" prop="path" ></el-table-column>
            <!-- 等级列 -->
            <el-table-column label="权限等级">
                <!-- 因为等级都是0，1，2不够明显，为了能够可视化等级，我们需要创建父组件的插槽作用域获取子组件数据
                为什么一定要用父组件插槽作用域，因为只有prop能够直接获取到level的值，其他的属性都获取不到
                即便rightsList.level也获取不到，所以若想其他的属性可以用level的值，就必须得用父组件的作用域插槽
                获取整个子组件的数据，便可以获取到level的值了 -->
                <template slot-scope="scope">
                    <!-- 用v-if来控制三个不同样式的标签，这里必须给值加上单引号，因为level是字符串 -->
                    <el-tag v-if="scope.row.level === '0'">一级权限</el-tag>
                    <el-tag v-else-if="scope.row.level === '1'" type="success">二级权限</el-tag>
                    <el-tag v-else type="warning">三级权限</el-tag>
                </template>
            </el-table-column>
        </el-table>
    </el-card>
```

#### 2.4.4 权限管理业务分析

![image-20221125143959449](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125143959449.png)

#### 2.4.5 创建角色列表组件并路由

![image-20221125151448097](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125151448097.png)

路由

​		因为是要在Home.vue组件里面显示，所有也必须写成Home.vue组件的子路由，不然就重新打开页面显示组件了

![image-20221125151514233](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125151514233.png)

#### 2.4.6 渲染角色列表页面

1.创建面包屑导航，直接复制其他组件的代码

```vue
<template>
  <div>
    <!-- 面包屑导航区域 -->
    <el-breadcrumb>
      <!-- 当点击首页时，路由跳转到首页 -->
      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>权限管理</el-breadcrumb-item>
      <el-breadcrumb-item>角色列表</el-breadcrumb-item>
    </el-breadcrumb>
    <el-card>
        <!-- 添加角色按钮区域 -->
            <el-row>
                <el-col>
                    <el-button type="primary">添加角色</el-button>
                </el-col>
            </el-row>
        <!-- 角色列表区域 -->
    </el-card>
  </div>
</template>
```

2.

api文档

![image-20221125151938159](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221125151938159.png)

行为区域

​	页面初始化获取后台数据

```js
data() {
    return {
        // 接收后台数据
        rolesList:[]
    };
  },
  created(){
    // 页面初始化时便调用事件，获取后台数据
    this.getRolesList()
  },
  methods: {
    // 获取所有角色的列表
    async getRolesList(){
        const {data:res} = await this.$http.get('roles')
        if(res.meta.status !== 200) return this.$message.error('获取用户列表失败')
        // 将数据赋给data数据
        this.rolesList = res.data
    }
  },
```

创建表格

```vue

   <el-card>
        <!-- 添加角色按钮区域 -->
            <el-row>
                <el-col>
                    <el-button type="primary">添加角色</el-button>
                </el-col>
            </el-row>
        <!-- 角色列表区域 -->
        <el-table :data="rolesList" border  stripe >
            <!-- 展开列 -->
            <el-table-column type="expand"></el-table-column>
            <!-- 索引列 -->
            <el-table-column type="index" label="#"></el-table-column>
            <!-- 角色名称列 -->
            <el-table-column label="角色名称" prop="roleName"></el-table-column>
            <!-- 角色描述列 -->
            <el-table-column label="角色描述" prop="roleName"></el-table-column>
            <!-- 操作列  需要操作的，都要用父组件作用域获取表格数据 -->
            <el-table-column label="操作" width="300px">
                <template slot-scope="scope">
                    <!-- 添加三个按钮，根据type规定不同的按钮样式来显示自己想要的颜色，并设置图标，和按钮大小 -->
                    <el-button type="primary" icon="el-icon-edit" size="mini">编辑</el-button>
                    <el-button type="danger" icon="el-icon-delete" size="mini">删除</el-button>
                    <el-button type="warning" icon="el-icon-setting" size="mini">分配权限</el-button>
                </template>
            </el-table-column>
        </el-table>
    </el-card>

```

#### 2.4.7 添加树状图

点击折叠按钮展开树状图

![image-20221130182233875](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221130182233875.png)

```vue
 <!-- 展开列 -->
        <el-table-column type="expand">
          <!-- 获取该行的信息 -->
          <template slot-scope="scope">
            <!-- 每一行有24格 -->
            <!-- class动态绑定.给每一个一级权限添加下边框,如果是第一个一级权限,那么给他添加上边框 -->
            <el-row
              v-for="(item1, i1) in scope.row.children"
              :key="item1.id"
              :class="['bdbottom', i1 === 0 ? ['bdtop'] : '']"
            >
              <!-- 渲染一级权限,占5格 -->
              <el-col :span="5">
                <!-- 标签包裹内容 -->
                <el-tag
                  closable
                  @close="removeRightById(scope.row, item1.id)"
                  >{{ item1.authName }}</el-tag
                >
                <!-- 添加一个图标 -->
                <i class="el-icon-caret-right"></i>
              </el-col>
              <!-- 渲染二.三级权限 ,占19格-->
              <el-col :span="19">
                <!-- 然后在占了19格的列里面再创建一个row,重复一级权限的操作 -->
                <!-- class动态绑定,给每一个二级权限添加上边框,如果是第一个二级权限标签,那么就不加上边框 -->
                <el-row
                  v-for="(item2, i2) in item1.children"
                  :key="item2.id"
                  :class="[i2 === 0 ? '' : ['bdtop']]"
                >
                  <!-- 二级权限占6格 -->
                  <el-col :span="6">
                    <el-tag
                      type="success"
                      closable
                      @close="removeRightById(scope.row, item2.id)"
                    >
                      {{ item2.authName }}
                    </el-tag>
                    <i class="el-icon-caret-right"></i>
                  </el-col>
                  <!-- 三级权限占18格 -->
                  <el-col :span="18">
                    <!-- closable为是否显示删除按钮，@close为点击删除按钮后执行的事件 -->
                    <el-tag
                      v-for="item3 in item2.children"
                      :key="item3.id"
                      type="warning"
                      closable
                      @close="removeRightById(scope.row, item3.id)"
                    >
                      {{ item3.authName }}
                    </el-tag>
                  </el-col>
                </el-row>
              </el-col>
            </el-row>
          </template>
        </el-table-column>
```

封装好的删除事件

global.js

```js
// 删除事件
  // 参数为('请求地址','每一行的id','删除提示框的文本内容')
async function deleteData(url,id,hintText) {
  const confirmResult = await MessageBox.confirm(
    hintText,
    "提示",
    {
      // 确定按钮
      confirmButtonText: "确定",
      // 取消按钮
      cancelButtonText: "取消",
      // 前面的图标类型
      type: "warning",
    }
  ).catch((err) => err);//箭头函数需要{}并且里面要return
                        // 但是只要一行代码，就可以省略{}和return
                        // 默认返回写的那一行代码
  // 如果用户确认删除，则返回值为字符串 confirm
  // 如果用户取消了删除，则返回值为字符串 cancel
  // 如果取消了删除，弹出消息框
  console.log(that);
  if(confirmResult == 'cancel') return Message.info('已取消了删除')
  //如果确定了删除，进行网络请求
  const {data:res} = await axios({
    method:'delete',
    url:`${url}/${id}`
  })
  // 删除失败弹框
  if(res.meta.status !== 200)return Message.error('删除失败')
  // 删除成功弹框
  Message.success('删除成功')
  // 返回成功删除之后的数据
  return res.data
}
```

调用全局事件

```js
// 根据id删除对应的权限
    removeRightById(role, rightId) {
      this.$global.deleteData(
        "roles",
        role.id + "/rights/" + rightId,
        "此操作将永久删除用户权限,是否继续?",
        'request'
      ).then(val =>{ //回调函数接收删除事件返回的数据
        // 让表单的children也就是树状图的数据等于删除后返回的数据
        // 这样就可以不用全局刷新数据，而是局部刷新数据
        role.children = val
      });
```



#### 2.4.8 递归函数

一个函数在它的函数体内调用它自身称为[递归调用](https://so.csdn.net/so/search?q=递归调用&spm=1001.2101.3001.7020)，这种函数称为递归函数。**执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。**

**. 递归的进入**

1. 求 `5!`，即调用 `factorial(5)`。当进入 `factorial()` 函数体后，由于形参 `n` 的值为 5，不等于 0 或 1，所以执行`factorial(n-1) * n`，也即执行`factorial(4) * 5`。为了求得这个表达式的结果，必须先调用 `factorial(4)`，并暂停其他操作。换句话说，在得到 `factorial(4)`的结果之前，不能进行其他操作。这就是第一次递归。
2. 调用 `factorial(4)` 时，实参为 4，形参 n 也为 4，不等于 0 或 1，会继续执行`factorial(n-1) * n`，也即执行`factorial(3) * 4`。为了求得这个表达式的结果，又必须先调用`factorial(3)`。这就是第二次递归。
3. 以此类推，进行四次递归调用后，实参的值为 1，会调用 `factorial(1)`。此时能够直接得到常量 1 的值，并把结果 return，就不需要再次调用 `factorial()` 函数了，递归就结束了。
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/5b34c7b32d1c45709a4e9cc482666705.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54us5Zyo6buR5aScX1_nnIvmuZbpnaI=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

**递归的退出**

递归进入到最内层的时候，递归就结束了，就开始逐层退出了，也就是 逐层执行 `return` 语句。

1. n 的值为 1 时达到最内层，此时 return 出去的结果为 1，也即 `factorial(1)` 的调用结果为 1。
2. 有了 `factorial(1)` 的结果，就可以返回上一层计算`factorial(1) * 2`的值了。此时得到的值为 2，return 出去的结果也为 2，也即 `factorial(2)`的调用结果为 2。
3. 以此类推，当得到 `factorial(4)` 的调用结果后，就可以返回最顶层。经计算，`factorial(4)`的结果为 24，那么表达式`factorial(4) * 5`的结果为 120，此时 return 得到的结果也为 120，也即 `factorial(5)` 的调用结果为 120，这样就得到了`5!`的值。
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/cb648b4af76244ab96087a76b29f7f9a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54us5Zyo6buR5aScX1_nnIvmuZbpnaI=,size_20,color_FFFFFF,t_70,g_se,x_16)

------

**递归的条件**

每一个递归函数都**应该只进行有限次的递归调用，否则它就会进入死循环**，永远都不能退出了，还会导致**栈溢出**。

要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题：

- **存在结束条件**：当符合结束条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束了。
- **存在递推关系**：每次递归调用之后越来越接近结束条件。对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n 的值逐渐减小，越来越趋近于 1 或 0。2.4.9 8 树形列表

#### 2.4.9 树状列表

可视区域

```vue
 <el-button
                type="warning"
                icon="el-icon-setting"
                size="mini"
                @click="showSetRightDialog(scope.row)"
                >分配权限</el-button
              >
              <!-- 分配权限对话框 -->
              <el-dialog
                title="分配权限对话框"
                :visible.sync="SetRightDialogVisible"
                width="50%"
                @close="setRightsDialogClosed"
              >
              <!-- 树形控件 -->
                <!-- 树形控件请求的数据必须是树形结构
                :props="treeProps" 所绑定的数据，里面需要两个属性，需要显示的内容label和分支children
                show-checkbox 是否显示复选框
                node-key="id" 每个点都用id来绑定唯z一值
                default-expand-all 展开树形图
                :default-checked-keys="defKeys" 勾选默认选中选项,用id来标识 
                ref 上传表单信息到本地-->
              <el-tree 
              :data="rightsList" 
              :props="treeProps"
               show-checkbox
               node-key="id"
               default-expand-all
               :default-checked-keys="defKeys"
               ref="treeRef"
               ></el-tree>
                <span slot="footer">
                  <el-button @click="SetRightDialogVisible = false">取 消</el-button>
                  <!-- 点击确定，请求后台数据 -->
                  <el-button type="primary" @click="allotRights()"
                    >确 定</el-button
                  >
                </span>
              </el-dialog>
```

data

```js
 // 分配权限对话框开关
      SetRightDialogVisible: false,
      // 权限列表数据
      rightsList:[],
      // 树形控件的属性绑定对象
      treeProps:{
        // 要显示的内容
        label:'authName',
        // 子节点
        children:'children'
      },
      // 默认选中的节点id属性
      defKeys:[],
      // 当前即将分配角色id
      roleId:''
```

数据请求

![image-20221201203407070](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201203407070.png)

行为区域

```js
// 展示分配权限的对话框
    showSetRightDialog(role) {
      //获取所有权限的数据
        //tree 为数据以树形方式返回
      this.$global.request(
        this,
        "rights/tree",
        "get",
        "",
        200,
        "获取权限数据失败"
      ).then(val =>{
        this.rightsList = val
      });

      // 递归获取三级节点的id，赋给本地，这里必须是赋值，不然不起作用，
      this.roleId = role.id
      // 调用递归函数，传入最外面的节点，和defkeys数组里的id
      this.getLeafKeys(role,this.defKeys)
      // 点击显示对话框
      this.SetRightDialogVisible = true;
    },
    // 通过递归的形式获取角色下所有三级权限的id，并保存到 defkeys 中
    getLeafKeys(node,arr){
      // 如果当前node节点不包含 children 属性，则是三级节点
      if(!node.children){
        把所有的三级节点id都加入到arr中
        return arr.push(node.id)
      }
      // 循环node里面的所有数组，每循环一项，拿到一个子节点item，
      // 再根据item，再次调用递归函数，然后把当前的item当作一个字节的再传进去
      // 递归结束之后，就把所有的三级节点都保存到arr数组里面
      node.children.forEach(item => 
      // 把返回的子节点作为参数传入递归函数，并再次执行
      //一直递归到node下面没有 children
      this.getLeafKeys(item,arr))
    },

    // 监听分配权限对话框的关闭事件
    setRightsDialogClosed(){
      // 关闭对话框便清空数组，防止数组里面的id累积，造成显示混论
      this.defKeys = []
    },

    // 点击为角色分配权限
    allotRights(){
      const keys = [
        // ...为展开数据，这里为展开所有选中节点的id，最后面的是tree控件自带的方法
        ...this.$refs.treeRef.getCheckedKeys(),
               //展开所有半选中节点的id，最后面的是tree控件自带的方法
        ...this.$refs.treeRef.getHalfCheckedKeys(),
      ]
      
      // 把数组里的所有id合并成字符串，因为请求时需要把所有的id以字符串的方式传入后台
      const idStr = keys.join(',')

      // 更改后台数据
      this.$global.request(this,'roles/'+this.roleId +'/rights','post',{rids:idStr},200,'分配权限失败')
      .then(val =>{
        // 更改之后刷新页面
        this.getRolesList();
      })
      //关闭对话框
      this.SetRightDialogVisible = false
    }
```

#### 2.4.10 提交代码

![image-20221201231614266](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201231614266.png)	

![image-20221201231649934](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201231649934.png)

![image-20221201231710072](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201231710072.png)

![image-20221201231725396](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201231725396.png)

### 2.5 分类参数

#### 2.5.1 创建分支

![image-20221201233314006](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201233314006.png)

![image-20221201233330788](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221201233330788.png)

 

#### 2.5.2 表格组件

项目内部输入 npm ui

进入vue可视化操作页面 安装依赖

![image-20221202154403524](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221202154403524.png)

安装完毕之后，有两种引入方式

```
import Vue from 'vue'
import ZkTable from 'vue-table-with-tree-grid'

Vue.use(ZkTable)
```

Or

```
import Vue from 'vue'
import ZkTable from 'vue-table-with-tree-grid'

Vue.component(ZkTable.name, ZkTable)
```

我们选择第二种方式，组件方式引入

main.js

```js
  // 注册表格插件，用组件的方式
Vue.component('TreeTable',()=>import('vue-table-with-tree-grid'))
```



获取后台数据存放本地

data

```js
//商品分类数据
cateList:[],
  // 总页数
  total : 0,
    columns:[
      // 有几个对象，便有几个列
      {   
        // 列名称
        label:'分类名称',
        //列数据，字符串形式
        prop:'cat_name'
      },
      {
        label:'是否有效',
        // 表示当前列定义为模板列
        type:'template',
        // 表示当前这一列使用模板名称
        //也就是定义具名插槽的名字
        template:'isok'
      },
      {
        label:'排序',
        // 表示当前列定义为模板列
        type:'template',
        // 表示当前这一列使用模板名称
        template:'order'
      },
      {
          label: "操作",
          // 表示当前列定义为模板列
          type: "template",
          // 表示当前这一列使用模板名称
          //也就是定义具名插槽的名字
          template: "opt",
        },
    ]
```

api

![image-20221202162539115](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221202162539115.png)

行为区域

```js
created(){
        this.getCateList()
    },
    methods: {
        getCateList(){
            this.$global.request(this,'categories','get',{type:3,pagenum:1,pagesize:5},200,'请求失败')
            .then(val => {
                this.cateList = val
                this.total = val.total
            })
        }
    }
```



可视区域

```vue
<!-- 使用表格组件 -->
<!-- :data 绑定本地数据
:columns 每一列需要显示的内容，用数组形式，里面放入对象，来展示
:selection-type 去掉复选框
show-index 显示索引列
index-text = '#' 索引列的名称
border 显示边框线
:show-row-hover="false" 取消鼠标悬停高亮 -->
<TreeTable 
           :data="cateList"
           :columns = "columns"
           :selection-type = 'false'
           show-index
           index-text = '#'
           border
           :show-row-hover="false"
           >
  <!-- '是否有效'具名插槽 -->
  <template slot="isok" slot-scope="scope">
<!-- 用scope.row.cat_deleted的值来判断显示哪个图标 -->
<i class="el-icon-success" v-if="scope.row.cat_deleted === false"
   style="color:lightgreen"
   ></i>
<i class="el-icon-error" v-else
   style="color:lightgreen"
   ></i>
  </template>
  <!-- '排序'具名插槽 -->
  <template slot="order" slot-scope="scope">
<!-- 用scope.row.cat_level的值来判断显示哪个标签 -->
<el-tag size="mini" v-if="scope.row.cat_level === 0 ">一级</el-tag>
<el-tag size="mini" v-else-if="scope.row.cat_level === 1 " type="success">二级</el-tag>
<el-tag size="mini" v-else type="warning">三级</el-tag>
  </template>
  <!-- '操作'具名插槽 -->
        <template slot="opt" slot-scope="scope">
          <el-button type="primary" icon="el-icon-edit" size="mini"
            >编辑</el-button
          >
          <el-button type="danger" icon="el-icon-delete" size="mini"
            >删除</el-button
          >
        </template>
</TreeTable>
```

接下来的内容由于接口失效，不再赘述

####  2.5.3 上传分支

![image-20221203001729926](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221203001729926.png)

![image-20221203001806293](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221203001806293.png)

![image-20221203001828701](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221203001828701.png)

![image-20221203001835075](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221203001835075.png)

#### 2.5.4 基本布局

![image-20221208120559098](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208120559098.png)

#### 2.5.5 头部警告框

```vue
 <!-- 面包屑导航组件 -->
    <breadcrumb :title="breadcrumb_title">
      <!-- 头部的警告区域 -->
        <!-- closable	是否可关闭  选择false-->
      <el-alert
        title="注意：值允许为第三级分类设置相关参数"
        type="warning"
        :closable="false"
        show-icon
      >
      </el-alert>
		</breadcrumb>  
```

#### 2.5.6 级联选择框

可视区域

```vue

      <!-- 选择商品分类区域 -->
      <el-row>
        <el-col>
          <span>选择商品分类：</span>
          <!-- 选择商品分类的级联选择框 -->
            <!-- v-model 为最终选中的分类的id值
                option 为后台获取到的数据
                props 为级联选中框需要的配置选项
                @change 为每一次选择框发生变化，便触发 -->
          <el-cascader
            v-model="selectedCateKeys"
            :options="cateList"
            :props="cateProps"
            @change="handleChange"
          ></el-cascader>
        </el-col>
      </el-row>
```

行为区域

 data

```js
//   商品分类列表
      cateList: [],
      //   级联选择框的配置对象
      cateProps: {
        value: "cat_id",
        label: "cat_name",
        children: "children",
        expandTrigger: "hover",
      },
      //   级联最后选中的数据传递的数组
      selectedCateKeys: [],
```

methods

```js
   handleChange() {
     //此处调用该函数，只是使用其上半段证明选中的是否为三级分类，只是为了方便，把两端代码写在一起了
      this.getParamsDate();
    },
    // 获取参数中中的列表数据
    async getParamsDate() {
      //证明选中的不是三级分类
      if (this.selectedCateKeys.length !== 3) {
        this.selectedCateKeys = [];
        return;
      }
      //证明选中的是三级分类
      //根据所选分类的id，和当前所处的面板，获取对应的参数
      const { data: res } = await this.$http.get(
        `categories/${this.cateId}/attributes`,
        {
          params: { sel: this.activeName },
        }
      );
      if (res.meta.status !== 200){
        return this.$message.error("获取参数列表失败");
      }
      if (this.activeName === "many") {
        this.manyTableData = res.data;
      } else {
        this.onlyTableData = res.data;
      }
    },
```

#### 2.5.7 tabs 页签

可视区域

```vue
 <!-- tabs页签区域 -->
      <el-tabs v-model="activeName" @tab-click="handleClick">
        <!-- 添加动态参数面板 -->
        <el-tab-pane label="动态参数" name="many">
            <!-- :disabled 动态的根据级联选择款是否选中来控制button按钮是否可点击 -->
            <!-- 添加参数点击事件，点中时显示增加表单，并为表单组件传入其需要的数据 -->
          <el-button size="mini" type="primary" :disabled="isBtnDisabled"
            @click="btnAddForm" 
            >添加参数</el-button
          >

          <!-- 动态参数表格 -->
            <!-- :data的数据是getParamsDate函数根据activeName的值的不同
                请求后台返回的数据 activeName的值默认为many，而activeName的值
                是根据tabs的页签绑定的v-model来决定的 -->
          <el-table :data="manyTableData" border stripe>
            <el-table-column type="expand"></el-table-column>
            <!-- 索引列 -->
            <el-table-column type="index" label="#"></el-table-column>
            <el-table-column
              label="参数名称"
              prop="attr_name"
            ></el-table-column>
            <el-table-column label="操作">
                <template slot-scope="scope">
                <el-button size="mini" type="primary" icon="el-icon-edit"
                @click="btnCompileForm(scope.row)"     
                >编辑</el-button
                >
                <el-button size="mini" type="danger" icon="el-icon-delete"
                @click="btnRemoveParams(scope.row)"
                  >删除</el-button
                >
              </template>
            </el-table-column>
          </el-table>
        </el-tab-pane>
        <!-- 添加静态属性面板 -->
        <el-tab-pane label="静态属性" name="only">
          <el-button size="mini" type="primary" :disabled="isBtnDisabled"
            @click="btnAddForm"
            >添加属性</el-button
          >

          <!-- 静态参数表格 -->
          <el-table :data="onlyTableData" border stripe>
            <el-table-column type="expand"></el-table-column>
            <!-- 索引列 -->
            <el-table-column type="index" label="#"></el-table-column>
            <el-table-column
              label="属性名称"
              prop="attr_name"
            ></el-table-column>
            <el-table-column label="操作">
              <template slot-scope="scope">
								 <!-- 绑定编辑事件-->
                <el-button size="mini" type="primary" icon="el-icon-edit"
                @click="btnCompileForm(scope.row)"  
                >编辑</el-button
                >
								 <!-- 绑定删除事件-->
                <el-button size="mini" type="danger" icon="el-icon-delete"
                @click="btnRemoveParams(scope.row)"
                >删除</el-button
                >
              </template>
            </el-table-column>
          </el-table>
        </el-tab-pane>
      </el-tabs>
 <!-- 添加参数的对话框 -->
   <addForm :data="FormData" :getList="getParamsDate"></addForm>
   <!-- 编辑参数对话框 -->
   <addForm :data="compile_FormData" :getList="getParamsDate"></addForm>
```

行为区域

​	data

```js
//   被激活的页签名称
      activeName: "many",
      //   动态参数数据
      manyTableData: [],
      //   静态属性数据
      onlyTableData: [],
      //   添加表单组件数据
        FormData: {
        // 表单标题
            title: '',
            // 对话框是否显示
            AddVisible: false,
            // 添加input框的属性
            AddInput: [
                {
                // input框的名字
                label:"",
                // 验证规则
                prop: "username",
                // 双向绑定的数据
                model: "", 
                }
            ],
            // 后台请求参数
            FormRequest: {
                // 请求路径
                url: '',
                // 请求方法
                way: "post",
                // 请求参数
                parameter: {},
                // 成功返回参数
                status: 201,
                // 请求失败返回内容
                error: "添加参数失败",
                // 请求成功返回内容
                success: "添加参数成功",
                // 请求数据事件，完成请求后刷新页面
                //传进来的是一个事件
                
            },
            getList: {
                    type: Function, 
                    default: () => {
                        return Function;
                    },
                },
        },
      //   编辑表单组件数据
      compile_FormData: {
        // 表单标题
            title: '',
            // 对话框是否显示
            AddVisible: false,
            // 添加input框的属性
            AddInput: [
                {
                // input框的名字
                label:"",
                // 验证规则
                prop: "username",
                // 双向绑定的数据
                model: "", 
                }
            ],
            // 后台请求参数
            FormRequest: {
                // 请求路径
                url: '',
                // 请求方法
                way: "put",
                // 请求参数
                parameter: {},
                // 成功返回参数
                status: 200,
                // 请求失败返回内容
                error: "修改参数失败",
                // 请求成功返回内容
                success: "修改参数成功",
                // 请求数据事件，完成请求后刷新页面
                //传进来的是一个事件
                
            },
            getList: {
                    type: Function, 
                    default: () => {
                        return Function;
                    },
                },
      },
    //   添加参数的表单数据对象
      addForm:{
        atter_name:''
      }

```

computed

```js
// 如果按钮需要被禁用，则返回true 否则返回false
    isBtnDisabled() {
      // 如果选择列表，则数组不为空，返回false，即不执行disabled，可以选中
      if (this.selectedCateKeys.length !== 0) {
        return false;
      }
      // 数组为空，则disabled为true，不可选中button按钮
      return true;
    },
    //当前选中的三级分类id
    cateId() {
      // 如果选中了三级分类，那么就返回三级分类的二级分类id
      if (this.selectedCateKeys.length === 3) {
        return this.selectedCateKeys[2];
      }
      return null;
    },
```

methods

```js
// tab 页签点击事件的处理函数
    handleClick() {
      this.getParamsDate();
    },
// 编辑按钮显示表单
    btnCompileForm(row){
        this.compile_FormData.AddVisible = true
        // 动态的传递compile_FormData所需要的数据
        if(this.activeName === 'many'){
            this.compile_FormData.title = '编辑动态参数'
            this.compile_FormData.AddInput[0].label = '动态参数'
        }else{
            this.compile_FormData.title = '编辑静态属性'
            this.compile_FormData.AddInput[0].label = '静态属性'
        }
        // 传url
        this.compile_FormData.FormRequest.url=`categories/${this.cateId}/attributes/${row.attr_id}`
        // 传model
        this.compile_FormData.AddInput[0].model = row.attr_name
        // 传请求参数
        this.compile_FormData.FormRequest.parameter = {
         attr_name : this.compile_FormData.AddInput[0].model,   
         attr_sel : row.attr_sel
        }
    },
    // 根据id删除对应的参数项
    btnRemoveParams(row){
        // 必须得用回调函数执行页面刷新事件，不然会有异步延迟
       this.$global.deleteData(`categories/${this.cateId}/attributes/${row.attr_id}`,'','是否删除').then(res =>{
        this.getParamsDate()
       })
       
    }      
```

#### 2.5.8 展开折叠列

![image-20221208145937253](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208145937253.png)

可视区域

​	以下是动态参数折叠列i的展开内容

​	静态属性的展开内容与其一致，只需要把该可视区域的代码复制一份到静态属性的折叠列下面即可

```vue
 //折叠列
 <el-table-column type="expand">
              <!-- 折叠列的展开内容 -->    
              <template slot-scope="scope">
                <!-- 循环渲染tag标签 -->
                <!-- closable为添加删除按钮
                    @close 为点击删除按钮执行的事件
                        handleClose里面要传入每个tag的index值，才能确定是要删除哪一个 -->
                <el-tag
                  v-for="(item, index) in scope.row.attr_vals"
                  :key="index"
                  closable
                  @close="handleClose(index,scope.row)"
                >
                  {{ item }}
                </el-tag>
                <!-- 输入文本框 -->
                   <!-- v-if 动态判断是显示文本框还是显示添加按钮
                        v-model 双向绑定row表格里面的数据，该数据不是原有的
                            而是为了让每一行的数据互相不侵扰，所以给每一行都
                            添加一个 scope.row.inputVisible 与 scope.row.inputValue
                            这样就不会混乱
                        ref 提交表格数据到本地
                        @keyup.enter.native 点击确定键 触发事件
                        @blur 失去焦点 触发事件 -->
                <el-input
                  class="input-new-tag"
                  v-if="scope.row.inputVisible"
                  v-model="scope.row.inputValue"
                  ref="saveTagInput"
                  size="small"
                  @keyup.enter.native="handleInputConfirm(scope.row)"
                  @blur="handleInputConfirm(scope.row)"
                >
                </el-input>
                <!-- 添加按钮 -->
                  <!-- v-else 如果input框为false 则显示button按钮 -->
                <el-button 
                  v-else
                  class="button-new-tag"
                  size="small"
                  @click="showInput(scope.row)"
                  >+ New Tag</el-button
                >
              </template>
</el-table-column>              
```

行为区域

```js
 //将对 attr_vals 的操作 保存到数据库
    saveAttrVals(row){
            // 发起网络请求
        this.$global.request(
        `categories/${this.cateId}/attributes/${row.attr_id}`,
        'put',
        {
        attr_name : row.attr_name,
        attr_sel : row.attr_sel,
        attr_vals :row.attr_vals.join(',')
        },
        200,
        '添加失败')
    },

    // 文本框失去焦点或者按下了Enter键都会触发
    handleInputConfirm(row){
      //如果去除空格后内容为空，则说明验证失败，关闭输入框并不进行数据请求
        if(row.inputValue.trim().length ===0){
            row.inputValue = ''
            row.inputVisible = false
            return
        }
        // 如果没有return 则证明输入的内容需要后续的处理
        row.attr_vals.push(row.inputValue.trim())
        row.inputValue = ''
        row.inputVisible = false

        // 发起网络请求，把添加过的数据传入后台
        this.saveAttrVals(row)

    },
    
    // 点击按钮，改变文本输入框
    showInput(row){
        row.inputVisible = true
        // 让文本框自动获得焦点
        // $nextTick方法的作用，就是当页面上元素
        // 被重新渲染之后，才会指定回调函数中的代码
        // 因为上面的布尔值重置为true后，页面上的元素还没有被重新渲染
        // 此时页面上显示的还是button按钮，并不是文本输入框，这时候我们需要等一个时机
        // $nextTick被调用就说明页面上的元素被渲染了，
        // 此时在调用函数就没问题了，不然获取不到inout元素
        // 会报错
        this.$nextTick(_ => {
          this.$refs.saveTagInput.$refs.input.focus();
        });
    },
    //删除对应的参数可选项
    handleClose(index,row){
        row.attr_vals.splice(index,1)

        // 发起网络请求，把修改过的数据传入后台
        this.saveAttrVals(row)
    }
  },
```

css

```less
<style scoped lang="less">
.el-alert {
  margin-bottom: 15px;
}
.el-tag {
  margin-left: 10px;
}
.input-new-tag{
    width: 140px;
    margin-left: 10px;
}
.button-new-tag{
    margin-left: 10px;
}
</style>
```

#### 2.5.9 提交分类参数到码云

![image-20221208153929441](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208153929441.png)![image-20221208154155883](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208154155883.png)

![image-20221208154425594](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208154425594.png)

![image-20221208154447802](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208154447802.png)

### 2.6 商品列表

#### 2.6.1 基本布局

![image-20221208195400901](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208195400901.png)

可视区域

```vue
<!-- 面包屑导航组件 -->
    <breadcrumb :title="title">
    <!-- 搜索框与添加按钮 -->
      <!-- :gutter设置的是列与列之间的距离 -->
      <el-row :gutter="20">
        <el-col :span="8">
          <el-input placeholder="请输入内容">
            <!-- slot="append" 为将button按钮放在input框后面  -->
            <el-button slot="append" icon="el-icon-search"></el-button>
          </el-input>
        </el-col>
        <el-col :span="4">
            <el-button
            type="primary"
            >
            添加商品
            </el-button>
        </el-col>
      </el-row>
    </breadcrumb>
```

api文档

![image-20221208211612049](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208211612049.png)

行为区域

```js
data() {
    return {
    //   面包屑导航组件数据
      title: {
        one: "商品管理",
        two: "商品列表",
      },
    //   查询参数对象
    queryInfo:{
        query:'',
        pagenum:1,
        pagesize:10
    },
    //商品列表
    goodsList:[],
    // 总数据条数
    total:0
    };
  },
  created() {
    //该组件初始化时便获取后台数据
    // 根据分页获取对应的商品列表
    this.getGoodsList()
  },
  methods: {
    // 请求该页面的后台数据
    async getGoodsList(){
        // 这里使用this.$global.request方法调用携带请求参数的请求会失败，
        // 所以不再调用全局函数
        const {data:res} = await this.$http.get('goods',{
            params:this.queryInfo
        })
        if(res.meta.status !==200){
            return this.$message.error('获取商品列表失败')
        }
        // 赋值给本地数据
        this.goodsList = res.data.goods
        // 将后台总数据条数赋给本地
        this.total = res.data.total
    }
  },
```

#### 2.6.2 表格



![image-20221208211435226](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208211435226.png)

可视区域

```vue
 <!-- table表格区域   -->
    <el-table :data="goodsList" border  stripe >
        <!-- 索引列 -->
        <el-table-column type="index"></el-table-column>
        <el-table-column label="商品名称" prop="goods_name"></el-table-column>
        <el-table-column label="商品价格(元)" prop="goods_price" width="95px"></el-table-column>
        <el-table-column label="商品重量" prop="goods_weight" width="70px"></el-table-column>
        <el-table-column label="创建时间" prop="add_time" width="140px">
            <!-- 用过滤器格式化时间 -->
                <!-- 需要传入每一行的add_time,需要用到插槽作用域 -->
            <template slot-scope="scope">
                {{scope.row.add_time | dateFormat}}
            </template>
        </el-table-column>
        <!-- 操作列 -->
        <el-table-column label="操作" width="130px">
            <template slot-scope="scope">
                <!-- 编辑按钮 -->
                <el-button type="primary" icon="el-icon-edit" size="mini"></el-button>
                <!-- 删除按钮 -->
                <el-button type="danger" icon="el-icon-delete" size="mini"></el-button>
            </template>
        </el-table-column>
    </el-table>
```

在main.js里面创建全局的时间过滤器

```js
Vue.filter('dateFormat',function(originVal){
  const dt = new Date(originVal)
    const y = dt.getFullYear()
    // 因为getMonth()是以0开始的，所以加上1，才是真正的月份，加上'',将其转为字符串
    // padStart()接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串
    const m = (dt.getMonth() + 1 + '').padStart(2,'0')
    const d = (dt.getDate() + '').padStart(2,'0')

    const hh = (dt.getHours() + '').padStart(2,'0')
    const mm = (dt.getMinutes() + '').padStart(2,'0')
    const ss = (dt.getSeconds() + '').padStart(2,'0')

    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`
})
```

#### 2.6.3 分页器

![image-20221208213301018](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208213301018.png)

可视区域

```vue
 <!-- 分页区 -->
    <!-- @size-change pageSize 改变时会触发
        @current-change currentPage 改变时会触发
        :current-page 当前位于第几页
        :page-sizes 每页可以显示多少条数据
        :page-size 当前每页要显示多少天数据
        layout="total, sizes, prev, pager, next, jumper" 组件布局
        :total 总共有多少条数据
        background 添加背景颜色 -->
    <el-pagination
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="queryInfo.pagenum"
      :page-sizes="[5, 10, 15, 20]"
      :page-size="queryInfo.pagesize"
      layout="total, sizes, prev, pager, next, jumper"
      :total="total"
      background 
      >
    </el-pagination>
```

行为区域

```js
 // 点击每页要显示多少条数据时,该函数会把那个值当作参数传入
    handleSizeChange(newSize){
        // 让this.queryInfo.pagesize 的值等于选择的要显示多少条数据的值
        this.queryInfo.pagesize = newSize
        // 刷新页面
        this.getGoodsList()
    },
    // 道理同上
    handleCurrentChange(newSize){
        this.queryInfo.pagenum = newSize
        this.getGoodsList()
    }
```

#### 2.6.4 搜索功能

![image-20221208215126711](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221208215126711.png)

```vue
<el-col :span="8">
  <!-- 与queryInfo的query双向绑定,这样每次发起请求都会把input里面的内容
        当作查询参数请求后台,然后每一次改变输入框内容都会触发请求函数,并刷新页面 
        clearable 为添加删除按钮
        suffix-icon 在input框后面添加一个按钮-->
  <el-input placeholder="请输入内容" 
            v-model="queryInfo.query"
            @input="getGoodsList"
            clearable 
            suffix-icon="el-icon-search"
            >
  </el-input>
</el-col>
```

#### 2.6.5 删除功能

可视区域

```vue
 <el-table-column label="操作" width="130px">
            <template slot-scope="scope">
                <!-- 编辑按钮 -->
                <el-button type="primary" icon="el-icon-edit" size="mini"></el-button>
                <!-- 删除按钮 -->
                <el-button 
                type="danger"
                 icon="el-icon-delete" 
                 size="mini"
                 @click="removeById(scope.row.goods_id)"
                 ></el-button>
            </template>
        </el-table-column>
```

行为区域

```js
// 删除事件
    removeById(id){
        this.$global.deleteData(`goods/${id}`,'此操作将永久删除该商品,是否继续?')
        .then(res => {
            this.getGoodsList()
        })
    },
```

#### 2.6.6 添加商品

##### 2.6.6.1 商品列表页面添加路由跳转

​	可视区域

```vue
<el-col :span="4">
            <el-button
            type="primary"
            @click="goAddpage"
            >
            添加商品
            </el-button>
        </el-col>
```

行为区域

```js
// 添加商品事件
    goAddpage(){
        this.$router.push('/home/goods/add')
    }
```

##### 2.6.6.2 注册组件

​		创建组件

![image-20221209002828823](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209002828823.png)

​	router/index.js

![image-20221209002918364](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209002918364.png)

##### 2.6.6.3 头部提示栏

![image-20221209003251870](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209003251870.png)



Add.vue

```vue
<template>
    <!-- 面包屑导航组件 -->
  <breadcrumb :title="title">
    <!-- 消息提示框 -->
    <el-alert
      title="添加商品信息"
      type="info"
      center
      :closable="false"
      show-icon
    >
    </el-alert>
  </breadcrumb>
</template>
```

data

```js
 // 面包屑导航组件数据
      title: {
        one: "商品管理",
        two: "添加商品",
      },
```

##### 2.6.6.4 进度条

![image-20221209003537290](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209003537290.png)

```vue
<!-- 步骤条区 -->
<!-- (activeIndex - 0)将其字符串强制转为数值 -->
    <el-steps :space="200" :active="(activeIndex - 0)" finish-status="success" align-center>
      <el-step title="基本信息"></el-step>
      <el-step title="商品参数"></el-step>
      <el-step title="商品属性"></el-step>
      <el-step title="商品图片"></el-step>
      <el-step title="商品内容"></el-step>
      <el-step title="完成"></el-step>
    </el-steps>

```

data

```js
// 步骤条所处索引  
    // 因为要与tabs 双向绑定,tabs传递字符串到activeIndex
      activeIndex:'0',
```

##### 2.6.6.5 tabs 页签

![image-20221209103719422](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209103719422.png)

可视区域

```vue
 <!-- tabs 栏区 -->
    <!-- 因为最终是把这下面五块数据都提交,所以需要用form表单包裹起来,方便提交
        这里需要把el-form标签放在el-tabs外面,因为el-tab-pane必须作为el-tabs的
        子节点才能生效,如果把el-form标签放在el-tabs里面,那么el-tab-pane就不再是
        el-tabs的子节点了,便会失效
				:tab-position 为tabs 页签居左显示-->
    <el-form :model="addForm" :rules="addFormRules" ref="addFormRef" label-position="top">
        <el-tabs 
        :tab-position="'left'" 
        v-model="activeIndex"
        >
        <el-tab-pane label="基本信息" name="0">基本信息</el-tab-pane>
        <el-tab-pane label="商品参数" name="1">商品参数</el-tab-pane>
        <el-tab-pane label="商品属性" name="2">商品属性</el-tab-pane>
        <el-tab-pane label="商品图片" name="3">商品图片</el-tab-pane>
        <el-tab-pane label="商品内容" name="4">商品内容</el-tab-pane>
        </el-tabs>
    </el-form>
```

这里因为el-tabs的v-model 值是下面的el-tab-pane 的name属性传递进来的，点击哪一个el-tab-pane，那个el-tab-pane便会把它的name值传递给因为el-tabs的v-model ，又因为el-tabs的v-model双向绑定了activeIndex，而activeIndex又与上面的el-steps的:active双向绑定了，activeIndex的值是多少，el-steps便会跳转到哪一个el-step，此时便完成了el-steps与el-tabs的同步操作，但是因为el-tab-pane的name是字符串，最终activeIndex接收到的值也是字符串，而el-steps的:active所需要的值是数值，所以:active接收时需要把activeIndex - 0  强制转换成数值

##### 2.6.6.6基本信息

![image-20221209123038310](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209123038310.png)

可视区域

```vue
			<el-tab-pane label="基本信息" name="0">
          <el-form-item label="商品名称" prop="goods_name">
            <el-input v-model="addForm.goods_name"></el-input>
          </el-form-item>
          <el-form-item label="商品价格" prop="goods_price">
            <el-input v-model="addForm.goods_price" type="number"></el-input>
          </el-form-item>
          <el-form-item label="商品重量" prop="goods_weight">
            <el-input v-model="addForm.goods_weight" type="number"></el-input>
          </el-form-item>
          <el-form-item label="商品数量" prop="goods_number">
            <el-input v-model="addForm.goods_number" type="number"></el-input>
          </el-form-item>
          <el-form-item label="商品分类" prop="goods_cat">
            <!-- 级联选择器 -->
            <!-- v-model绑定的属性名与prop要一致
                options 获取商品列表数据
                props 级联选择器的配置
                change 级联选择框变化触发函数 -->
            <el-cascader
              v-model="addForm.goods_cat"
              :options="cateList"
              :props="cateProps"
              @change="handleChange"
            ></el-cascader>
          </el-form-item>
        </el-tab-pane>
```

行为区域

data

```js
//添加商品的表单对象
      addForm: {
        goods_name: "",
        goods_price: 0,
        goods_weight: 0,
        goods_number: 0,
        // 商品所属的分类列表
        goods_cat:[]
      },
    //   验证规则
      addFormRules: {
        goods_name: [
          { required: true, message: "请输入商品名称", trigger: "blur" },
          {
            min: 2,
            message: "长度最少为两个字符",
            trigger: "blur",
          },
        ],
        goods_price: [
          { required: true, message: "请输入商品价格", trigger: "blur" },
        ],
        goods_weight: [
          { required: true, message: "请输入商品重量", trigger: "blur" },
        ],
        goods_number: [
          { required: true, message: "请输入商品数量", trigger: "blur" },
        ],
        goods_cat:[
        { required: true, message: "请选择商品分类", trigger: "change" },
        ]
      },
      // 商品分类列表
      cateList: [],
      //级联选择器的配置项
      cateProps:{
        // 要显示什么内容
        label:'cat_name',
        // 绑定的值
        value:'cat_id',
        // 子分支
        children:'children',
        // 悬停显示
        expandTrigger: 'hover'
      }
    };
```

methods

```js
created() {
    this.getAddList();
  },
  methods: {
    // 请求后台获取商品列表数据
    getAddList() {
      this.$global
        .request("categories", "get", "", 200, "获取商品数据分类失败")
        .then((res) => {
          this.cateList = res.data;
        });
      console.log(this.cateList);
    },
    //级联选择器选项中变化,会触发这个函数
    handleChange(){
        // 如果没有选中最后一级,便不可选中
        if(this.addForm.goods_cat.length !==3){
            this.addForm.goods_cat = []
        }
    },
    // activeName为即将进入的标签页名字
    // oldActiveName为即将离开的标签页
    beforeTabLeave(activeName,oldActiveName){
        // 如果处在name为0的那页标签页,并且this.addForm.goods_name(商品名称)的长度不符合规范
        // 或者this.addForm.goods_cat(商品分类)未选择,那么弹出错误框,并且返回false 禁止跳转
        if(oldActiveName === '0' 
            && this.addForm.goods_cat.length !== 3
            || this.addForm.goods_name.split('').length < 2){
                this.$message.error('内容不符合规范或未选择,请重新输入') 
                return false
            }
         }
  },
```

##### 2.6.6.7 商品参数(动态参数)

![image-20221209142918221](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209142918221.png)

可视区域

```vue
			<el-tab-pane label="商品参数" name="1">
          <!-- 循环渲染manyTableDate里面的数据-->
          <el-form-item
            :label="item.attr_name"
            v-for="(item, index) in manyTableDate"
            :key="index"
          >
            <!-- 复选框组 -->
            <el-checkbox-group v-model="item.attr_vals">
                <!-- 复选框循环manyTableDate里面的attr_vals数据 -->
              <el-checkbox 
               :label="item1"
               v-for="(item1,index2) in item.attr_vals"
               :key="index2"
               border
               ></el-checkbox>
            </el-checkbox-group>
          </el-form-item>
        </el-tab-pane>
```

行为区域

data

```js
  //   动态参数列表数据
      manyTableDate: [],
```

methods

```js
    // 这里是商品参数页面函数
    // tabs 页签内部跳转时触发该函数
    tabClicked() {
      // 证明访问的是动态参数的访问面板
      if (this.activeIndex === "1") {
        this.$global
          .request(
            `categories/${this.cateId}/attributes`,
            "get",
            { sel: "many" },
            200,
            "请求参数列表失败"
          )
          .then((res) => {
            // 循环data里面的attr_vals,因为它是字符串,这里直接判断字符串的长度,每个字符占1
            // 如果为空,则长度为0,那就返回一个空数组,最后渲染出来什么也不显示
            // 如果不为空,那就分割字符串成数组,最后渲染数组
            res.data.forEach((item) => {
              item.attr_vals =
                item.attr_vals.length === 0 ? [] : item.attr_vals.split(",");
            });
            this.manyTableDate = res.data;
          });
      }
    },
```

##### 2.6.6.8 商品属性(静态属性)

![image-20221209173455107](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209173455107.png)

可视区域

```vue
		<el-tab-pane label="商品属性" name="2">
          <el-form-item
            v-for="item in onlyTableDate"
            :key="item.attr_id"
            :label="item.attr_name"
          >
            <el-input v-model="item.attr_vals"></el-input>
          </el-form-item>
        </el-tab-pane>
```

行为区域

data

```js
//   静态属性列表数据
      onlyTableDate: [],
```

methods

```js
// tabs 页签内部跳转时触发该函数
    tabClicked() {
      // 这里是商品参数页面函数
      // 证明访问的是动态参数的访问面板
      if (this.activeIndex === "1") {
        this.$global
          .request(
            `categories/${this.cateId}/attributes`,
            "get",
            { sel: "many" },
            200,
            "请求动态参数失败"
          )
          .then((res) => {
            // 循环data里面的attr_vals,因为它是字符串,这里直接判断字符串的长度,每个字符占1
            // 如果为空,则长度为0,那就返回一个空数组,最后渲染出来什么也不显示
            // 如果不为空,那就分割字符串成数组,最后渲染数组
            res.data.forEach((item) => {
              item.attr_vals =
                item.attr_vals.length === 0 ? [] : item.attr_vals.split(",");
            });
            this.manyTableDate = res.data;
          });
      }
      // 这里是商品属性页面函数
      // 证明访问的是静态属性的访问面板
      else if (this.activeIndex === "2") {
        this.$global
          .request(
            `categories/${this.cateId}/attributes`,
            "get",
            { sel: "only" },
            200,
            "获取静态属性失败"
          )
          .then((res) => {
            this.onlyTableDate = res.data;
          });
      }
    },
```

##### 2.6.6.9 商品图片(图片上传)

![image-20221209223645438](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209223645438.png)

可视区域

```vue
       <el-tab-pane label="商品图片" name="3">
          <!-- 上传页面 -->
          <!-- action 表示图片要上传的后台API地址
                on-preview 点击图片预览触发的事件
                on-remove 点击删除图标触发的事件
                list-type 是上传组件的展示样式
                headers upload组件值封装了axios请求,但是没有请求头,
                        必须设置请求头,里面传入token
                        不然上传会失败 
                on-success 图片上传成功触发的事件    -->
          <el-upload
            class="upload-demo"
            :action="uploadURL"
            :on-preview="handlePreview"
            :on-remove="handleRemove"
            list-type="picture"
            :headers="headerObj"
            :on-success="handleSuccess"
          >
            <el-button size="small" type="primary">点击上传</el-button>
          </el-upload>
        </el-tab-pane>
```

行为区域

data

```js
//添加商品的表单对象
        // 里面的数据都是根据添加商品里面的api而定
      addForm: {
        goods_name: "",
        goods_price: 0,
        goods_weight: 0,
        goods_number: 0,
        // 商品所属的分类列表
        goods_cat: [],
        // 图片的数组
        pics: [],
      },
         //   上传图片的url地址
      uploadURL: "http://127.0.0.1:8888/api/private/v1/upload",
      // 图片上传组件的headers请求头对象
      headerObj: {
        // 用 Authorization 来接收本地的 token
        Authorization: window.sessionStorage.getItem("token"),
      },
      //   接收想要在对话框中显示的图片的真实地址
      previewPath: "",
      //   控制对话了的隐现
      previewVisible:false
```

methods

```js
 // 处理图片预览效果
        // file为on-preview 自带的默认参数,指向图片上传成功后
        // 服务器返回的数据
    handlePreview(file) {
        // 点击显示对话框
      this.previewVisible = true
        //将点击的图片真实地址传递给this.previewPath,然后让img的src指向this.previewPath,
        //便可以在对话框里面显示点击的图片
      this.previewPath = file.response.data.url;
    },
    //处理移除图片的操作
        // file为on-remove 自带的默认参数,指向图片上传成功后
        // 服务器返回的数据
    handleRemove(file) {
      // 1.获取将要删除的图片的临时路径
      const filePath = file.response.data.tem_path;
      // 2.从 pics 数组中,找到这个图片对应的索引值
            // findIndex的第一个参数是数组里面的每一个值,它有一个箭头函数,
            // 函数里面让每个索引值的pic的值与filePath 对比,
            // 如果相等,就返回那个相等的索引值
      const i = this.addForm.pics.findIndex((x) => x.pic === filePath);
      // 3.调用数组的 splice 方法,把图片信息对接,从 pics 数组中移除
            // splice第一个参数为数组的索引值,第二个为要删除几个
      this.addForm.pics.splice(i, 1);
    },
    // 监听图片上传成功的事件
         // response为on-success 自带的默认参数,指向图片上传成功后
        // 服务器返回的数据
    handleSuccess(response) {
      // 1.拼接得到一个图片信息对象
      const picInfo = { pic: response.data.tmp_path };
      // 2.将图片信息对象,push 到pics数组中
      this.addForm.pics.push(picInfo);
    },
```

##### 2.6.6.10 商品内容(富文本)

![image-20221209224009347](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209224009347.png)

需要在vue 可视化面板中安装依赖

![image-20221209224235583](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209224235583.png)

然后在mian.js里面挂载到全局组件里面

```js
// 导入富文本编辑器
import VueQuillEditor from 'vue-quill-editor'
// 导入富文本的样式
import 'quill/dist/quill.core.css' // import styles
import 'quill/dist/quill.snow.css' // for snow theme
import 'quill/dist/quill.bubble.css' // for bubble theme
// 将富文本挂载成全局可用的组件
Vue.use(VueQuillEditor, /* { default global options } */)
```

可视区域

```js
		<el-tab-pane label="商品内容" name="4">
            <!-- 富文本编辑器 -->
            <quill-editor v-model="addForm.goods_introduce"></quill-editor>
            <!-- 添加商品的按钮 -->
            <el-button type="primary" class="btnAdd" @click="add">添加商品</el-button>
        </el-tab-pane>
        
        <el-dialog
        title="图片预览"
        :visible.sync="previewVisible"
        width="50%"
    >
        <img :src="previewPath" alt="" class="previewImg">
    </el-dialog>
```

行为区域

data

```js
 //添加商品的表单对象
        // 里面的数据都是根据添加商品里面的api而定
      addForm: {
        goods_name: "",
        goods_price: 0,
        goods_weight: 0,
        goods_number: 0,
        // 商品所属的分类列表
        goods_cat: [],
        // 图片的数组
        pics: [],
        // 商品的详情描述
        goods_introduce:'',
      },
```

methods

```js
//添加商品
    add(){
        // 表单预验证
        this.$refs.addFormRef.validate( valid => {
            if(!valid){
                return this.$message.error('请填写必要的表单项')
            }
            
        })
    }
```

##### 2.6.6.11 深拷贝

vue可视化面板安装依赖

![image-20221209224717013](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209224717013.png)

在Add.vue中引入

![image-20221209224802259](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209224802259.png)

methods

```js
//添加商品
    add(){
        // 表单预验证
        this.$refs.addFormRef.validate( valid => {
            if(!valid){
                return this.$message.error('请填写必要的表单项')
            }
            // 执行添加的业务逻辑
            // lodash.cloneDeep(obj)
            // 这里的lodash被我们定义成了 _ ,所以是 _.cloneDeep()
            // 深拷贝给form,原本的this.addForm留给级联选择框使用
            const form = _.cloneDeep(this.addForm)
            // 把form里面的goods_cat数组 改成由,连接的字符串
            form.goods_cat = form.goods_cat.join(',') 
        })
    }
```

##### 2.6.6.12 提交

![image-20221209233510395](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221209233510395.png)

行为区域

```js
  //添加商品
     add(){
        // 表单预验证
        this.$refs.addFormRef.validate(async valid => {
            if(!valid){
                return this.$message.error('请填写必要的表单项')
            }
            // 执行添加的业务逻辑
            // lodash.cloneDeep(obj)
            // 这里的lodash被我们定义成了 _ ,所以是 _.cloneDeep()
            // 深拷贝给form,原本的this.addForm留给级联选择框使用
            const form = _.cloneDeep(this.addForm)
            // 把form里面的goods_cat数组 改成由,连接的字符串
            form.goods_cat = form.goods_cat.join(',') 
            
            // 因为提交时attrs里面要有动态参数和静态属性的attr_id与attr_value值
            // 这里循环动态参数和静态属性的数据，获取他们的attr_id与attr_vals，赋给newInfo
            // 然后再将newInfo添加到attrs数组中
            // 处理动态参数,
            this.manyTableDate.forEach(item => {
                const newInfo = {
                    attr_id:item.attr_id,
                    // 因为attr_vals现在是数组，而提交时需要字符串形式，转换一下
                    attr_value:item.attr_vals.join('')
                }
                this.addForm.attrs.push(newInfo)
            })
            // 处理静态属性 
            this.onlyTableDate.forEach(item => {
                const newInfo = {
                    attr_id:item.attr_id,
                    // 因为attr_vals现在是数组，而提交时需要字符串形式，转换一下
                    attr_value:item.attr_vals
                   }
                this.addForm.attrs.push(newInfo)
            })
            // 将获取好的attrs的值给深拷贝一份
            form.attrs = this.addForm.attrs

            // 发起请求添加商品
            // 商品的名称必须是唯一的
            this.$global.request1('goods','post',form,201,'添加失败')
            .then( res => {
              // 添加成功后跳转路由到商品列表页面
              this.$router.push('/home/goods')
            })
        })
    }
```

#### 2.6.7 编辑功能

新创建一个组件，组件的内容赋值Add.vue（添加商品页面）的一份

注册组件

![image-20221211170113227](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211170113227.png)

route/index.js

![image-20221211170137477](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211170137477.png)



goods.vue

```vue
 <!-- 删除按钮 -->
                <el-button 
                type="danger"
                 icon="el-icon-delete" 
                 size="mini"
                 @click="removeById(scope.row.goods_id)"
                 ></el-button>
```

行为区域

```js
// 编辑商品事件
    goCompilePage(row){
      // 将这行的数据转为字符串
      row = JSON.stringify(row)
      // 将字符串存入本地
      sessionStorage.setItem('compile',row)
      // 跳转路由
      this.$router.push('/home/goods/compile')
    }
```

compile.vue

由于内容基本上都和Add.vue里面的内容相似，只稍作更改便可

可视区域

![image-20221211170725087](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211170725087.png)

![image-20221211170653513](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211170653513.png)

行为区域

data

![image-20221211170619898](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211170619898.png)

created

```js
 created() {
        // 将本地的字符串传为对象并赋值
        var row = JSON.parse(sessionStorage.getItem('compile'))
        // 将addForm里面的值也就是页面input框绑定的model值改成从本地获取到的值
        this.addForm.goods_id = row.goods_id
        this.addForm.goods_name = row.goods_name
        this.addForm.goods_number = row.goods_number
        this.addForm.goods_price = row.goods_price
        this.addForm.goods_weight = row.goods_weight
      this.getAddList();
    },
```

methods

```js
//修改商品
       compile(){
          // 表单预验证
          this.$refs.addFormRef.validate(valid => {
              if(!valid){
                  return this.$message.error('请填写必要的表单项')
              }
              // 执行添加的业务逻辑
              // lodash.cloneDeep(obj)
              // 这里的lodash被我们定义成了 _ ,所以是 _.cloneDeep()
              // 深拷贝给form,原本的this.addForm留给级联选择框使用
              const form = _.cloneDeep(this.addForm)
              // 把form里面的goods_cat数组 改成由,连接的字符串
              form.goods_cat = form.goods_cat.join(',') 
              
              // 因为提交时attrs里面要有动态参数和静态属性的attr_id与attr_value值
              // 这里循环动态参数和静态属性的数据，获取他们的attr_id与attr_vals，赋给newInfo
              // 然后再将newInfo添加到attrs数组中
              // 处理动态参数,
              this.manyTableDate.forEach(item => {
                  const newInfo = {
                      attr_id:item.attr_id,
                      // 因为attr_vals现在是数组，而提交时需要字符串形式，转换一下
                      attr_value:item.attr_vals.join('')
                  }
                  this.addForm.attrs.push(newInfo)
              })
              // 处理静态属性 
              this.onlyTableDate.forEach(item => {
                  const newInfo = {
                      attr_id:item.attr_id,
                      // 因为attr_vals现在是数组，而提交时需要字符串形式，转换一下
                      attr_value:item.attr_vals
                     }
                  this.addForm.attrs.push(newInfo)
              })
              // 将获取好的attrs的值给深拷贝一份
              form.attrs = this.addForm.attrs
              // 发起请求添加商品
              // 商品的名称必须是唯一的

              this.$global.request(`goods/${form.goods_id}`,'put',form,200,'修改失败')
              .then( res =>{
                this.$router.push('/home/goods')

              })
          })
      }
```

#### 2.6.8 提交

![image-20221211171955391](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211171955391.png)![image-20221211172007167](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211172007167.png)![image-20221211172028035](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211172028035.png)![image-20221211172037683](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211172037683.png)

![image-20221211172105757](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221211172105757.png)

### 2.7 订单提交

1.引入面包屑导航组件，传入数据

2.请求页面数据

3.用表格渲染内容

4.分页器更改显示

5.添加编辑功能

​		需要引入中国省市区数据

​			https://github.com/iceyangcc/provinces-china

6.添加查看时间线功能

​		由于引入的element-ui版本不是最新，不支持时间线组件，所以需要自己手动引入

​		https://pan.baidu.com/s/1UlO7JAqIHzT2ET_Od_sn0g#list/path=%2F%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F8.vue-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98day6%2F%E7%B4%A0%E6%9D%90

 下载这两个文件



![image-20221212153842748](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212153842748.png)

把这两文件放到elememt.js的同级目录下![image-20221212154019081](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212154019081.png)

然后在element.js里面引入

```js
import Timeline from './timeline/index'
import TimelineItem from './timeline-item/index'

Vue.use(Timeline)
Vue.use(TimelineItem)
```



可视区域

```vue
<template>
  <breadcrumb :title="title">
    <el-row>
      <el-col :span="8">
        <el-input
          placeholder="请输入内容"
          clearable
          suffix-icon="el-icon-search"
        >
        </el-input>
      </el-col>
    </el-row>
    <!-- 订单列表数据 -->
    <el-table :data="orderList" border stripe>
      <el-table-column type="index"></el-table-column>
      <el-table-column label="订单编号" prop="order_number"></el-table-column>
      <el-table-column label="订单价格" prop="order_price"></el-table-column>
      <el-table-column label="是否付款" prop="pay_status">
        <template slot-scope="scope">
          <el-tag v-if="scope.pay_status === '1'" type="success">已付款</el-tag>
          <el-tag v-else type="danger">未付款</el-tag>
        </template>
      </el-table-column>
      <el-table-column label="是否发货" prop="is_send"></el-table-column>
      <el-table-column label="下单时间" prop="create_time" width="140px">
        <template slot-scope="scope">
          {{ scope.row.create_time | dateFormat }}
        </template>
      </el-table-column>
      <el-table-column label="操作">
        <template slot-scope="scope">
          <!-- 编辑按钮 -->
          <el-button
            type="primary"
            icon="el-icon-edit"
            size="mini"
            @click="compileForm.AddVisible = true"
          ></el-button>
          <!-- 显示物流信息按钮 -->
          <el-button
            type="success"
            icon="el-icon-location"
            size="mini"
            @click="showProgressBox"
          ></el-button>
        </template>
      </el-table-column>
    </el-table>
    <!-- 分页区 -->
    <el-pagination
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="queryInfo.pagenum"
      :page-sizes="[5, 10, 15, 20]"
      :page-size="queryInfo.pagesize"
      layout="total, sizes, prev, pager, next, jumper"
      :total="total"
    >
    </el-pagination>

    <!-- 修改地址对话框 -->
      <!-- 由于没有接口，这里编辑功能的提交无效 -->
    <addForm :data="compileForm" :getList="getOrderList()"></addForm>

    <!-- 物流进度对话框 -->
    <el-dialog
      title="物流信息"
      :visible.sync="progressVisible"
      width="50%"
    >
      <!-- 时间线 -->
      <el-timeline>
        <el-timeline-item v-for="(activity,index) in progressInfo" :key="index" :timestamp="activity.time">
          <el-card>
            {{activity.context}}}
          </el-card>
        </el-timeline-item>
      </el-timeline>
     
    </el-dialog>
  </breadcrumb>
</template>
```

行为区域

```js
<script>
// 由于接口失效，把接口响应的内容复制到单独的js里面，然后这里接收js里面的数据
import logistics from './logisticsData'
export default {
  props: {},
  data() {
    return {
      // 面包屑组件数据
      title: {
        one: "订单管理",
        two: "订单列表",
      },
      //   查询对象
      queryInfo: {
        query: "",
        pagenum: 1,
        pagesize: 10,
      },
      // 总数据条数
      total: 0,
      // 接收数据
      orderList: [],
      compileForm: {
        // 表单标题
        title: "修改地址",
        // 对话框是否显示
        AddVisible: false,
        // 添加省区县级联选择框
        cascaderInput: true,
        // 添加input框的属性
        AddInput: [
          {
            // input框的名字
            label: "详细地址",
            // prop可以选择的验证规则
            // username；password；email；mobile；     ''；1；2；3
            // 前四个有验证规则                        后四个无验证规则
            //因为每个input的prop都具有唯一性，必须再以上8个值选择一个传入
            prop: "",
            // 双向绑定的数据
            model: "",
            // 类型
            type: "",
            // 如果为密码框是否添加显示按钮
            show_password: "",
          },
        ],
        // 后台请求参数
        FormRequest: {
          // 请求路径
          url: "",
          // 请求方法
          way: "",
          // 请求参数
          //再点击显示对话框事件里面为请求参数对象赋值
          parameter: {},
          // 成功返回参数
          status: "",
          // 请求失败返回内容
          error: "",
          // 请求成功返回内容
          success: "",
        },
      },
    //   物流对话框显示
    progressVisible:false,
    //物流对话框数据
    progressInfo : []
    };
  },
  created() {
    // 请求页面数据
    this.getOrderList();
  },
  methods: {
    // 请求页面数据函数
    getOrderList() {
      this.$global
        .request(
          "orders",
          "get",
          { params: this.queryInfo },
          200,
          "获取订单列表失败"
        )
        .then((res) => {
          this.total = res.data.total;
          this.orderList = res.data.goods;
        });
    },
    // 获取选中的每页显示多少条数据
    handleSizeChange(e) {
      this.queryInfo.pagesize = e;
      this.getOrderList();
    },
    // 获取当前选中了第几页
    handleCurrentChange(e) {
      this.queryInfo.pagenum = e;
      this.getOrderList();
    },

    async showProgressBox() {
        this.progressInfo = logistics.data
        this.progressVisible = true
    },
  },
  components: {},
};
</script>

<style scoped lang="less">
// 必须引入时间线组件的样式才能生效
@import '../../plugins/timeline/timeline.css';
@import '../../plugins/timeline-item/timeline-item.css';
</style>

```

7.提交

![image-20221212155319512](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212155319512.png)

![image-20221212155336533](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212155336533.png)

![image-20221212155357635](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212155357635.png)![image-20221212155417821](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212155417821.png)

![image-20221212155454687](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212155454687.png)

![image-20221212155508040](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212155508040.png)

### 2.8 数据统计

1.创建页面

```vue
<template>
    <breadcrumb :title="title">
         <!-- 2.为 ECharts 准备一个定义了宽高的 DOM -->
        <div id="main" style="width: 750px;height:400px;"></div>
    </breadcrumb>
</template>
```

2.vue 可视化页面下载依赖

![image-20221212174931484](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212174931484.png)

3.

Report.vue

```js
<script>
// 1. 导入echarts
import  * as echarts from 'echarts'
import _ from 'lodash'
export default {
    props: {

    },
    data() {
        return {
            // 面包屑导航组件数据
            title:{
                one:'数据统计',
                two:'数据报表'
            },
            // 需要合并的数据
            options: {
                title: {
                text: '用户来源'
                },
                tooltip: {
                trigger: 'axis',
                axisPointer: {
                    type: 'cross',
                    label: {
                    backgroundColor: '#E9EEF3'
                    }
                }
                },
                grid: {
                left: '3%',
                right: '4%',
                bottom: '3%',
                containLabel: true
                },
                xAxis: [
                {
                    boundaryGap: false
                }
                ],
                yAxis: [
                {
                    type: 'value'
                }
                ]
            }
        };
    },
    // 此时页面上的元素已经渲染完毕了
    mounted(){
    // 3.基于准备好的dom，初始化echarts实例
    var myChart = echarts.init(document.getElementById('main'));
    
    // 4. 准备数据和配置项
     // 指定图表的配置项和数据
      
    this.$global.request('reports/type/1','get','',200,'获取折线图数据失败')
        .then(res => {
            const result = _.merge(res.data,this.options)
            result && myChart.setOption(result,true)
        })
    },
    methods: {

    },
    components: {

    },
};
</script>

<style scoped lang="less">

</style>

```

提交

![image-20221212175700452](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212175700452.png)

![image-20221212175715194](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212175715194.png)

### 2.9 项目优化

#### 2.9.1.增加进度条

给每个页面加载时，增加一个进度条

下载依赖

​	![image-20221212183636321](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212183636321.png)

然后在main.js里面的axios请求拦截器里面放入进度条

​	请求之前的拦截里面让进度条开始

​	请求之后的拦截里面让进度条结束

```js
// 引入进度条组件
import Nprogress from 'nprogress'
// 引入进度条样式
import 'nprogress/nprogress.css'
//配置axios
import axios from 'axios'
// 配置请求的根路径，接口
axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'
// axios请求拦截
// 为保证其他的页面在每次请求时都确保是登录状态，便需要拦截器在请求之前加入token令牌，来让
// 后台知道此时已经登录
//request为请求，use为回调函数
  // 在 request 中，展示进度条 Nprogress.start()
axios.interceptors.request.use(config => {
  Nprogress.start()
  // 为请求头对象，添加 Token 验证的 Authorization 字段
  config.headers.Authorization = window.sessionStorage.getItem('token')
  return config
})

  // 在 response 拦截器中，隐藏进度条 Nprogress.done()
  axios.interceptors.response.use( config => {
    Nprogress.done()
    return config
  })
```

#### 2.9.2 清空项目里面的所有conlole.log

 下载开发依赖

![image-20221212184026504](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212184026504.png)

在babel.config.js里面配置

```js
module.exports = {
  "presets": [
    "@vue/cli-plugin-babel/preset"
  ],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ],
    // ...是展开符，就是把数组展开了，放到另一个数组中
    // 发布产品时的插件数组
    'transform-remove-console'
  ]
}
```

又因为babel.config.js是全局的事件，测试阶段还是需要console.log，这个时候还不能把log全部清除，只能在发布阶段才能清除

这时候我们发现测试阶段

![image-20221212184435131](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212184435131.png)

发布阶段

![image-20221212184459325](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212184459325.png)

他们的model值不一样，所有只需要获取model值就可以知道现在处在什么阶段，然后判断是否要执行清除console.log了

```js
//这是项目发布阶段需要用到的 babel 插件
const prodplugins = []
// process.env.NODE_ENV 获取处在什么阶段的model值
if(process.env.NODE_ENV === 'prodution'){
  prodplugins.push('transform-remove-console')
}
module.exports = {
  "presets": [
    "@vue/cli-plugin-babel/preset"
  ],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ],
    // ...是展开符，就是把数组展开了，放到另一个数组中
    // 发布产品时的插件数组
    ...prodplugins
  ]
}
```

2.9.3 生成打包报告

![image-20221212211331855](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212211331855.png)

![image-20221212211355157](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212211355157.png)

![image-20221212211957227](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212211957227.png)



#### 2.9.4 通过vue.config.js 修改 webpack 的默认工具

![image-20221212212109361](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212212109361.png)

![image-20221212212123813](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212212123813.png)

​												https://cli.vuejs.org/zh/config/#vue-config-js



#### 2.9.5 为开发模式与发布模式指定不同的打包入口

![image-20221212212353998](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212212353998.png)

![image-20221212212421649](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212212421649.png)

#### 2.9.6 通过 chainWebpack 自定义打包入口

先把main.js改成![image-20221212212604841](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212212604841.png) 

然后再把main-dev里面内容复制一份，再新建一个文件名字为![image-20221212212717488](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212212717488.png)

然后把复制到内容复制到它里面即可

这时候页面可能会报错，这是因为入口名称改了，得重启一下项目

接下来在项目目录下创建一个vue.config.js

```js
module.exports = ({
  transpileDependencies: true,
  chainWebpack:config =>{
    // 当模式处于发布阶段
    config.when(process.env.NODE_ENV === 'production' , config => {
      // 获取默认入口，清空，然后增加新的入口
      config.entry('app').clear().add('./src/main-prod.js')
    })
    // 当模式处于开发阶段
    config.when(process.env.NODE_ENV === 'development' , config => {
      // 获取默认入口，清空，然后增加新的入口
      config.entry('app').clear().add('./src/main-dev.js')
    })
  }
})

```

然后再次运行，没有错误的话便把打包入口更改了

#### 2.9.7 第三方库启用CDN

1.

![image-20221212214550552](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212214550552.png)

在vue.config.js里面创建一个 externals节点，把包都放在里面，这样打包时，检测到节点里面有包，便不会再去打包这些包了，而是直接区全局挂载的里面去找这些包

```js
module.exports = ({
  transpileDependencies: true,
  chainWebpack:config =>{
    // 当模式处于发布阶段
    config.when(process.env.NODE_ENV === 'production' , config => {
      // 获取默认入口，清空，然后增加新的入口
      config.entry('app').clear().add('./src/main-prod.js')

      // 因为是发布阶段才需要打包，所有写在发布阶段了里面
      config.set('externals',{
        vue:'Vue',
        'vue-router':'VueRouter',
        axios:'axios',
        lodash:'_',
        echarts:'echarts',
        'vue-quill-editor':'VueQuillEditor'
      })
    })
    // 当模式处于开发阶段
    config.when(process.env.NODE_ENV === 'development' , config => {
      // 获取默认入口，清空，然后增加新的入口
      config.entry('app').clear().add('./src/main-dev.js')
    })
  }
})

```

2.之所以要在这里面引入，是因为原本main.js里面有很多的引入的样式表，这些也会打包进去，会占用很大的空间，所以把原本的这些引入的样式都删掉，然后再public/index.html里面用link引入，这样打包时，便不会去打包这些包，而是根据externals节点里面的包名，去全局里面寻找包，所以要把css与js文件都引入到全局，这样就可以找到了

![image-20221212215707747](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212215707747.png)



![image-20221212215944574](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212215944574.png)

public/index.html

```html
<!-- nprogress 的样式表文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />
    <!-- 富文本编辑器 的样式表文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css" />
    <link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css" />
    <!-- element-ui 的样式表文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css" />
```

3.

![image-20221212220607642](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212220607642.png)

```html
		<script src="https://cdn.staticfile.org/vue/2.5.22/vue.min.js"></script>
    <script src="https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js"></script>
    <script src="https://cdn.staticfile.org/axios/0.18.0/axios.min.js"></script>
    <script src="https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js"></script>
    <script src="https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js"></script>
    <script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script>
    <!-- 富文本编辑器的 js 文件 -->
    <script src="https://cdn.staticfile.org/quill/1.3.4/quill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js"></script>

    <!-- element-ui 的 js 文件 -->
    <script src="https://cdn.staticfile.org/element-ui/2.8.2/index.js"></script>
```

效果如下

更改前

![image-20221212221956657](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212221956657.png)

更改后

![image-20221212222024689](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212222024689.png)

#### 2.9. 8 通过CDN 优化 Element-ui 的打包

![image-20221212222124041](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212222124041.png)

此时element-ui的包还是很大，所有还得进行更改

![image-20221212222214950](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212222214950.png)

public/index.html  

​	引入element-ui的cdn

```js
<!-- element-ui 的样式表文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css" />
        <!-- element-ui 的 js 文件 -->
    <script src="https://cdn.staticfile.org/element-ui/2.8.2/index.js"></script>
```

![image-20221212222432916](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212222432916.png)

更改前

![image-20221212222830772](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212222830772.png)

更改后

![image-20221212222902117](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212222902117.png)

#### 2.9.9 首页内容定制

![image-20221212224947427](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212224947427.png)

开发环境的首页和发布环境的首页展示内容的形式有所不同
如开发环境中使用的是import加载第三方包，而发布环境则是使用CDN，那么首页也需根据环境不同来进行不同的实现
我们可以通过插件的方式来定制首页内容，打开vue.config.js，编写代码如下：

```
module.exports = {
    chainWebpack:config=>{
        config.when(process.env.NODE_ENV === 'production',config=>{
            ......
            
            //使用插件
            config.plugin('html').tap(args=>{
                //添加参数isProd
                args[0].isProd = true
                return args
            })
        })

        config.when(process.env.NODE_ENV === 'development',config=>{
            config.entry('app').clear().add('./src/main-dev.js')

            //使用插件
            config.plugin('html').tap(args=>{
                //添加参数isProd
                args[0].isProd = false
                return args
            })
        })
    }
}
```

然后在public/index.html中使用插件判断是否为发布环境并定制首页内容

public/index.html  该文件里面不能写注释

   <%= %> 是输出的意思  htmlWebpackPlugin是插件的具体名称  options是一些参数项

​        具体的参数就是我们在vue.config.js里面挂载的自定义属性

​		然后用<% if(htmlWebpackPlugin.options.isProd){ %>

​						csn

​		 <% } %>

​		的形式来判断什么时候该打包这些

```html
 <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %>电商后台管理系统</title>

    <% if(htmlWebpackPlugin.options.isProd){ %>
     <!-- nprogress 的样式表文件 -->
 <link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />
 <!-- 富文本编辑器 的样式表文件 -->
 <link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css" />
 <link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css" />
 <link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css" />
 <!-- element-ui 的样式表文件 -->
 <link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.8.2/theme-chalk/index.css" />


 <script src="https://cdn.staticfile.org/vue/2.5.22/vue.min.js"></script>
 <script src="https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js"></script>
 <script src="https://cdn.staticfile.org/axios/0.18.0/axios.min.js"></script>
 <script src="https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js"></script>
 <script src="https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js"></script>
 <script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script>
 <!-- 富文本编辑器的 js 文件 -->
 <script src="https://cdn.staticfile.org/quill/1.3.4/quill.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js"></script>

 <!-- element-ui 的 js 文件 -->
 <script src="https://cdn.staticfile.org/element-ui/2.8.2/index.js"></script>
    <% } %>
  </head>
```

2.9.10 路由懒加载

​	不确定是否有效，需安装插件

​	视频地址 https://www.bilibili.com/video/BV1E7411c7M8/?p=204&spm_id_from=pageDriver&vd_source=91ddac9bea3a3a81e5d8b9217a0225dc

### 2.10 项目上线

#### 2.10.1 通过 node 创建 web配置

![image-20221212231940449](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212231940449.png)

1.在项目同级目录下创建一个新的文件夹  vue_shop_server

![image-20221212232837843](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212232837843.png)

然后打开终端

![image-20221212233008017](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212233008017.png)

然后打开vue_shop 文件夹，把里面的dist文件复制一份到vue_shop_server中

![image-20221212233138128](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212233138128.png)

然后再在目录下创建一个app.js文件

![image-20221212233214227](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212233214227.png)

app.js

```js
// 导入exprss第三方库
const express = require('express')
// 调用express
const app = express()

// 使用app.use注册一个中间键，要把哪个目录托管成静态资源，就写哪个目录
app.use(express.static('./dist'))

// app.listen启动服务器，设置端口为80，如果成功输出一段话
app.listen(80,()=>{
    console.log('server running at http://127.0.0.1');
})
```

终端运行

![image-20221212233453437](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212233453437.png)

服务器启动成功

 此时复制 http://127.0.0.1 到网页

![image-20221212233552859](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212233552859.png)

访问成功

#### 2.10.2 开启 gzip 配置

![image-20221212235702483](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221212235702483.png)

![image-20221213000445502](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213000445502.png)

vue.config.js

```js
// 导入exprss第三方库
const express = require('express')
const compression = require('compression')
// 调用express
const app = express()

// 一定要把这一行代码写在静态资源托管之前，不然不生效
app.use(compression())
// 使用app.use注册一个中间件，要把哪个目录托管成静态资源，就写哪个目录
app.use(express.static('./dist'))

// app.listen启动服务器，设置端口为80，如果成功输出一段话
app.listen(80,()=>{
    console.log('server running at http://127.0.0.1');
})
```

#### 2.10.2 配置 HTTPS 配置

​	通常都是由后端 Jave 或者 php 来完成

步骤

​				https://freessl.cn/

![image-20221213000651249](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213000651249.png)

cert为公钥

key为私钥

都是字符串



把钥匙信息作为第一个参数，服务器传进来作为第二个参数，然后.lesten函数监听并启动https服务器，

默认情况下 http  运行在 80 端口   

​					https 运行在 443 端口

![image-20221213000846593](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213000846593.png)

#### 2.10.3 pm2 管理应用

因为关闭终端服务器后，浏览器会无法访问，为了关服务器后仍可以访问页面，便需要用到pm2

![image-20221213001311239](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213001311239.png)

1.

![image-20221213001525072](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213001525072.png)

2.

![image-20221213001850617](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213001850617.png)

![image-20221213001909531](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213001909531.png)

此时关闭除了（vue_api_server的服务器）以外的终端依然可以访问页面

要想也关闭 vue_api_server的服务器，也可以访问页面，也需要用pm2 管理vue_api_server服务器

![image-20221213002417868](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221213002417868.png)

其他功能自己尝试  其他功能的自定义名称可以改成id值，依然可以访问
