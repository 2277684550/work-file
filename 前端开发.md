# Js基础

### 1.String对象方法

| 方法                 | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| charAt(a)            | 返回在指定位置的字符（注：字符串中第一个字符的下标是0,a代表下标） |
| concat(b)            | 连接字符串,b为被合并对象名,和+的作用一样，不修改字符串       |
| replace(/a/,'b')     | 用于在字符串中用一些字符替换另一些字符，把a字符替换为b字符；/a/表示只替换匹配到的第一个a，/a/g，表示替换全部的a |
| split('')            | 把对象根据引号内的规则分割成字符串数组                       |
| indexOf(‘字符’)      | 根据字符找到所在的下标位置（只返回第一个下标）；如果找不到，返回-1； |
| lastIndexOf('字符‘)  | 返回一个指定的字符串值最后出现的下标位置                     |
| reverse()            | 颠倒数组顺序                                                 |
| join()               | 将数组合成字符串                                             |
| toLowerCase()        | 将所有字符变小写                                             |
| toUpperCase()        | 将所有字符变大写                                             |
| slice(start,end)     | 提取字符串的某个部分，并以新的字符串返回被提取的部分。<br/>start为要抽取的片断的起始下标，如果是负数，则从后超前取，-2为倒数第二个字符,<br/>end为抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。 |
| subString(start,end) | 与slice效果相同                                              |
| trim()               | 移除字符串两侧的空白字符或其他预定义字符                     |
| find()               | 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 [undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)[ ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) |
| findIndex()          | 方法返回数组中满足提供的测试函数的第一个元素的**索引**。否则返回-1。 |
| includes()           | 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 |
| indexOf()            |                                                              |
| pop()                | 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 |
| push()               | 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 |
| shift()              | 方法从数组中删除**第一个**元素，并返回该元素的值。此方法更改数组的长度。 |
| unshift()            | 方法将一个或多个元素添加到数组的**开头**，并返回该数组的**新长度****(****该**方法修改原有数组**)**。 |
| reverse()            | 方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。 |
| sort()               | 方法用[原地算法](https://en.wikipedia.org/wiki/In-place_algorithm)对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 |

1.  提取首字母转换为大写并与其余的字母拼接起来(3种方法)

                                   var name = name.charAt(0).toUpperCase() + name.slice(1); 
                                   var name = name.slice(0,1).toUpperCase() + name.slice(1);
                                   var name = name.subString(0,1).toUpperCase() + name.subString(1);

### 2.Math对象

| 方法            | 作用                    | 说明                                                  |
| --------------- | ----------------------- | ----------------------------------------------------- |
| Math.ceil(num)  | 向上取整                | Math.ceil(25.5);返回26<br/>Math.ceil(-25.5);返回-25   |
| Math.floor(num) | 向下取整                | Math.floor(25.5);返回25<br/>Math.floor(-25.5);返回-26 |
| Math.round(num) | 四舍五入                | Math.round(25.5);返回26<br/>Math.round(-25.5);返回-26 |
| Math.abs(num)   | 求绝对值                |                                                       |
| Math.random()   | 返回0.0~1.0之间的随机数 |                                                       |

### 3.系统函数

| 方法                 | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| parseInt ("字符串")  | 将字符串转换为整型数字 ，省略小数点以后的内容<br/> 如: parseInt ("86")将字符串“86“转换为整型值86 |
| parseFloat("字符串") | 将字符串转换为浮点型数字 ，如果有小数，不省略小数点以后的内容<br/> 如: parseFloat("34.45")将字符串“34.45“转换为浮点值34.45 |
| isNaN()              | 用于检查其参数是否是非数字                                   |

### 4.js执行流程

​		1、代码的检查装载阶段（预编译阶段）

​				    此阶段进行变量和函数的声明，但是不对变量进行赋值，变量的默认值为undefined

​					就是讲所有的声明（此时可理解为变量声明），都提升到最当前作用域最上面的位置，有变量名，但是没有值，就叫只声明不赋值，所以默认值是					undefined。

​		 2、代码的执行阶段

​					此阶段对变量进行赋值和函数的声明。

​					搞完步骤1以后，会对变量进行赋值。并从上向下执行。

 		3、函数的提升

​						表达式函数会先把变量提升，

​						声明函数，会把整个的函数提升到当前作用域的最上面

### 5.作用域链

​		一般情况下，变量取值是到创建这个变量的函数的作用域中取值

​		但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域

​		这样一个查找过程形成的链条就叫做作用域链

### 6.闭包

​		闭包就是能够读取其他函数内部变量的函数。

​		在本质上， 闭包就是将函数内部和函数外部连接起来的一座桥梁。

```js
function fn() {
                      var a = 100;
                     function son() {
                      //    console.log(a);
                             return a;
                     }
                return son();
 
         }
        var z=fn();
```

- 闭包的优点

  - 保护变量不被污染

- 闭包的缺点

  - 滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量，

    因为垃圾回收机制，只会回收变量。清空没用被调用函数的作用域

  			只要形成闭包，作用域就不能被销毁，因为闭包存在的意义，就是保护闭包内的变量不被外部影响

​			  如果将函数内部的变量return出来，只是return出来这一个值

  			而闭包，return的是，整个闭包函数的作用域，提供给外部使用，依旧保持函数内部结构

- 闭包形成条件
  - 函数嵌套函数，内部函数使用外部函数的变量，此时就形成了闭包，内部的函数就是闭包，闭包内的变量和参数都不会被回收

​				可以理解为：父亲养了个儿子，儿子来使用父亲的财产，此时就形成了闭包，儿子使用的这个财产，不会被收回，因为儿子一直在占用着这个财产。财产      				被销毁的条件，父亲没有用了，但是，儿子一直要用父亲的财产，就导致，父亲一直有用

​				因为闭包永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数 

​				想要释放的时候，给该闭包函数，赋一个null值

```js
		var z=fn();
		z = ''
```



# JS高级

### 1.BOM常用属性&方法

- ##### windows： 窗口对象, 可以用来控制当前窗口, 或打开新的窗口

  - window.open('http://www.baidu.com','_blank');//新窗口打开
  - window.open('http://www.baidu.com','_self');//当前窗口打开
  - window.close()//关闭窗口

- ##### screen:屏幕对象, 获取屏幕相关信息 

- ##### navigator:浏览器对象, 通过这个对象可以判定用户所使用的浏览器

  ```html
  <script type="text/javascript">
  			function go(){
  				window.open('http://www.baidu.com')//打开新窗口
  			}
  			function guanbi(){
  				window.close();  //关闭窗口
  			}
  			console.log(window.screen)//输出屏幕信息
  			var z=window.navigator.userAgent;
  			if(z.indexOf('Chrome')!=-1){
  				alert('当前浏览器为谷歌')
  			}else{
  				alert('其他浏览器')
  			} 
  			document.write(window.navigator.userAgent)//输出浏览器名称
  			
  		</script>
  	</head>
  	<body>
  		<button type="button" onclick="go()">打开新窗口</button>
  		<button type="button" onclick="guanbi()">关闭该窗口</button>
  		<button type="button" onclick="forward()_">前进</button>
  		<button type="button" onclick="back()_">后退</button>
  	</body>
  ```

- ##### history对象：历史对象, 可以用来前进或后退一个页面

  - history.forward(); //前进
  - history.back(); //后退

- ##### location对象：地址对象, 可以用来获取当前URL的信息  

  - window.location.href ； //不赋值，获取地址
  - window.location.href =‘’地址‘’； //重定向到该地址
  - window.location.reload();   //刷新页面

- ##### JavaScript 计时事件 :在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行

  - setInterval("调用的函数",间隔的毫秒数) :间隔指定的毫秒数不停地执行指定的代码  

    - 计时器狂点的时候，速度会发生变化，计时器的执行是可以累加的

       解决办法，在计时器上面添加清除计时器

  - clearInterval()：用于停止 setInterval() 方法执行的函数代码 

    ```js
      clearInterval(setInterval()返回的ID值)；
                       如：var timer=setlnterval（function（）{
                                                                执行函数
                                                                  },1000）;
                              clearInterval(timer)；//停止计时
    ```

  - setTimeout()  :指定的毫秒数后执行指定的代码
  - clearTimeout() :用于停止执行setTimeout()方法的函数代码

- JavaScript 弹窗：

  | 弹窗   | 语法             | 说明                               |
  | ------ | ---------------- | ---------------------------------- |
  | 警告框 | window.alert()   | 用于确保用户可以得到某些信息       |
  | 确认框 | window.confirm() | 用于验证是否接受用户操作           |
  | 提示框 | indow.prompt()   | 用于提示用户在进入页面前输入某个值 |



### 2.DOM节点

- 节点属性

  ```html
  <p class="lucy">Hello，World</p>
  <p></p> //就是元素节点
  Hello，World //就是文本节点
  class="lucy" //就是属性节点
  ```

  | 属性名称         | 描述                                                       |
  | ---------------- | ---------------------------------------------------------- |
  | parentNode       | 返回节点的父节点                                           |
  | childNodes       | 返回所有节点，包含元素节点和文本节点，换行等               |
  | children         | 返回子节点集合，只返回元素节点【标签】                     |
  | firstChild       | 返回节点的第一个子节点，最普遍的用法是访问该元素的文本节点 |
  | lastChild        | 返回节点的最后一个子节点                                   |
  | nextSibling      | 下一个节点                                                 |
  | previousSibling  | 上一个节点                                                 |
  | getAttributeNode | 获取属性节点                                               |

- Element属性

  加了element的属性，只返回元素节点，不再包含文本换行等文本节点（常用）

  | 属性名称               | 描述                           |
  | ---------------------- | ------------------------------ |
  | firstElementChild      | 返回节点的第一个子节点【元素】 |
  | lastElementChild       | 返回节点的最后一个子节点       |
  | nextElementSibling     | 下一个节点                     |
  | previousElementSibling | 上一个节点                     |

- 获取节点信息

  | 节点信息  | 解释                                     |
  | --------- | ---------------------------------------- |
  | nodeName  | 获取节点的名称，比如获取节点是什么标签   |
  | nodeValue | 节点值，比如 获取p标签包裹的内容         |
  | nodeType  | 节点类型，有不同的数值对应不同的节点类型 |

- 创建&插入&删除&替换节点

  | 方法名称                               | 作用                                                         |
  | -------------------------------------- | ------------------------------------------------------------ |
  | document.createElement(“元素名”)       | 创建元素节点                                                 |
  | document.createTextNode(“文本”)        | 创建文本节点                                                 |
  | A.appendChild( B)                      | 把B节点追加至A节点的末尾，A节点就是父节点                    |
  | parent.insertBefore( A,B )             | 把A节点插入到B节点之前。parent插入元素的父元素               |
  | a.cloneNode(deep)                      | 复制某个指定的节点a；a表示 被复制的节点<br>deep: 默认false浅复制: 只复制当前节点对象本身<br>eep: true深复制: 复制当前节点及所有子节点对象 |
  | 父节点.removeChild( 子节点)            | 删除指定的节点                                               |
  | 父节点.replaceChild( newNode, oldNode) | 用其他的节点替换指定的节点                                   |

- 操控节点属性

  | 方法              | 作用     | 示例                                                         |
  | ----------------- | -------- | ------------------------------------------------------------ |
  | setAttribute()    | 添加属性 | document.getElementById("changePic").setAttribute("src","image/change.jpg"); |
  | getAttribute()    | 获取属性 | alert(document.getElementById('changePic').getAttribute('src')); |
  | removeAttribute() | 删除属性 | document.getElementById("changePic").removeAttribute("src","image/change.jpg"); |

- 获取样式属性

  HTML元素.style.样式属性;      只能获取到内部样式的属性 拿不到内联样式的属性

  document.defaultView.getComputedStyle(元素,null).属性;     可以拿到一切样式 

  window.getComputedStyle(元素，null).属性;       可以拿到一切样式

  ```js
  var zz=document.getElementsByTagName('p')[0];
  		//改变样式
  		// zz.style.color='pink';
  		//获取样式,只能获取标签内的属性值，不能获取内联式的属性值
  		document.write(zz.style.color);
  		document.write('<br>');
  		document.write(window.getComputedStyle(zz).fontSize)//可以获取内外链
  		document.write(window.getComputedStyle(zz).color)//获取到的值都为rgb
  ```

### 3.鼠标事件

| 名称                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| onclick                        | 当用户单击某个对象时调用事件                                 |
| ondbclick                      | 双击鼠标左键时发生，如果右键也按下则不会发生                 |
| onmouseover  /   onmouseout    | 鼠标移到某元素之上    /   鼠标从某元素移开 ;移动到其子元素身上也会触发事件  （不冒泡） |
| onmouseenter  /   onmouseleave | 鼠标移到某元素之上    /   鼠标从某元素移开 ;移动到其子元素身上不会触发事件 （冒泡） |
| onmousedown                    | 鼠标按钮被按下                                               |
| onmouseup                      | 某个鼠标按键被松开                                           |
| onmousemove                    | 鼠标在某个元素上时持续发生                                   |

### 4.添加class与id

```js
document.getElementById("cart").className="cartOver";
document.getElementById("cartList").className="cartListOver";//设置class名
document.querySelector('div').id= 'aa';//设置id名，querySelector为第一个元素
```

### 5.获取元素位置与宽高

| 属性         | 说明                                                   |
| ------------ | ------------------------------------------------------ |
| offsetLeft   | 返回当前元素左边界到它上级元素的左边界的距离，只读属性 |
| offsetTop    | 返回当前元素上边界到它上级元素的上边界的距离，只读属性 |
| offsetHeight | 返回元素的高度,包含边框                                |
| offsetWidth  | 返回元素的宽度，包含边框                               |
| offsetParent | 返回元素的偏移容器，即当前容器偏移对应的父容器         |
| scrollTop    | 返回匹配元素的滚动条的垂直位置                         |
| scrollLeft   | 返回匹配元素的滚动条的水平位置                         |
| clientWidth  | 返回元素的可见宽度 不包含边框                          |
| clientHeight | 返回元素的可见高度 不包含边框                          |

### 6.监听事件

​	给dom元素添加监听事件：el_obj.addEventListener('click',fn(){},ture);

​	1: 要监听的事件名（不加on）

​	2: 事件的处理函数，即时间要执行的函数

​	3： boolean:true false(默认)

​		--false：事件冒泡  默认

​		-- true: 事件捕获

```js
 var div1=document.getElementById('div1'); 
                    div1.addEventListener('click',function(){
 	            		 alert('爷爷出手了')
                                },true); //ture为捕获型事件流(由外至内触发事件)，false为冒泡型(由内至外触发事件)，什么都不填默认为冒泡

```

​	  4.dom元素删除事件监听： el_obj.removerEventListener(1,2);

​		  Ⅰ.要删除的事件名

​	 	 Ⅱ.相关的事件处理函数（注意：该函数需要时一个外部处理函数）

```js
btn_2.removeEventListener('click', fn);
```

示例：

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			div{
				padding: 50px;
				border: red 2px solid;
			}
		</style>
	</head>
	<body>
		<div id="div1">
			爷爷
			<div id="div2">
				爸爸
				<div id="div3">
					儿子
				</div>
			</div>
		</div>
	</body>
	<script type="text/javascript">
		 var div1=document.getElementById('div1');
		 var div2=document.getElementById('div2');
		 var div3=document.getElementById('div3');
		 //捕获型事件流，由外至内触发，冒泡型事件流，由内至外
		 div1.addEventListener('click',function(){
			 alert('爷爷出手了')
		 },true);//ture为捕获型事件流，false为冒泡型，什么都不填默认为冒泡
		 div2.addEventListener('click',function(){
			 alert('爸爸出手了')
		 },true);
		 div3.addEventListener('click',function(){
			 alert('儿子出手了')
		 },true);
	</script>
</html>

```



### 7.表单事件

| 事件名   | 作用                           |
| -------- | ------------------------------ |
| onfocus  | 元素获得焦点                   |
| onblur   | 元素失去焦点                   |
| onchange | 用户改变域的内容               |
| onreset  | 表单重置时触发【绑定在form上】 |
| onsubmit | 表单提交时触发【绑定在form上】 |
| oninpu   | 用户输入时                     |

表单重置

​	在form上进行onreset，而不是在form里面的某个元素

```js
 var form_=document.getElementsByTagName('form')[0];
		var name_=document.getElementById('usename');
		form_.onreset=function(){
			name_.value='';
			alert('重置了')
		}
```

### 8.键盘事件

| 事件名     | 作用                                              |
| ---------- | ------------------------------------------------- |
| onkeydown  | 某个键盘的键被按下                                |
| onkeypress | 某个键盘的键被按下并释放一个键时发生              |
| onkeyup    | 某个键盘的键被松开                                |
| key        | 键盘按下的键  类似于输入的值。如按下0 ，显示key:0 |
| keycode    | 按键对应的Unicode编码                             |

说明：

​	绑定keydown事件，然后通过event取值

```js
var text=document.getElementsByTagName('textarea')[0];
		text.onkeydown=function(e){//键盘按下触发事件
			e=e||window.event;
			console.log(e.key);
			console.log(e.keyCode);
			if(e.key==' '){
				alert('已提交')
			}
       //组合键盘，同时按下ctrl + c 才执行
			if(e.ctrlKey&&e.key=="c"){//直接用ctrlKey取ctrl的值，不用再==了
				alert('已复制')
			}
		}
```

### 9.UI事件(移动端设置大小)

​	 UI（User Interface，用户界面）事件

​	指的是那些不一定与用户操作有关的事件

	//里面传入参数时,用来判断移动端的桌面大小来设置字体大小
		window.onresize=function(){
			console.log("页面重置大小")
		}

| 事件名   | 作用                     |
| -------- | ------------------------ |
| onload   | 某个页面或图像被完成加载 |
| onresize | 窗口或框架被调整尺寸     |
| onscroll | 当文档被滚动时发生的事件 |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>利用 onresize 事件，实现页面大小随浏览器窗口变化</title>
</head>
<!-- onresize 事件当浏览器被重置大小时执行 -->
<body onresize="resize()" style="margin: 0px; padding: 0px; overflow: hidden; background: #000">
    <!-- 容器 -->
    <div id="box"></div>
</body>
</html>
<Script>
    function resize() {
        var box = document.getElementById("box");
        box.style.width = document.documentElement.clientWidth + 'px';
        box.style.height = document.documentElement.clientHeight + 'px';
    }
</Script>

```

### 10.event对象（获取事件信息）

​	用来兼容各种浏览器，获取事件的详细信息：鼠标位置、键盘按键

​	就是一个js对象，里面包含了事件的详细具体信息

| 属性     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| altKey   | 返回当事件被触发时，"ALT”是否被按下。                        |
| ctrlKey  | 返回当事件被触发时，"CTRL”键是否被按下。                     |
| shiftKey | 返回当事件被触发时，"SHIFT”键是否被按下。                    |
| metakey  | 返回当事件被触发时，"meta”键是否被按下。window键             |
| button   | 返回当事件被触发时，哪个鼠标按钮被点击。                     |
| target   | 返回与事件的目标节点相关的节点。                             |
| clientX  | 返回当事件被触发时鼠标指针向对于浏览器页面(或客户区〉的水平坐标客户区指的览器的有效区域 |
| clientY  | 返回当事件被触发时鼠标指针向对于浏览器页面(或客户区）的垂直坐标客户区指的览器的有效区域 |
| screenX  | 返回当某个事件被触发时，鼠标指针的水平坐标。鼠标相对于显示器屏幕x轴的位置 |
| screenY  | 返回当某个事件被触发时，鼠标指针的垂直坐标。鼠标相对于显示器屏幕Y轴的位置 |

```js
 //获取event对象（兼容性写法）
           document.onclick=function(e){
	                      	  e = e|| window.event;//兼容浏览器
                                                console.log('距离屏幕上方'+e.screenX);
                                            }
```

- 拖拽元素

  ```js
  var div_=document.getElementsByTagName('div')[0];
  	div_.onmousedown=function(e){
  		e=e||window.event;
  		var x=e.offsetX;
  		var y=e.offsetY;
  		console.log(x,y);
  		document.onmousemove=function(e){
  			div_.style.left=(e.clientX-x)+'px';
  			div_.style.top=(e.clientY-y)+'px';
  			div_.style.backgroundColor='#006400';
  			
  		}
  		
  	}
  	div_.onmouseup=function(){
  		//当鼠标松开时，什么函数也不执行
  		document.onmousemove=''
  	}
  ```

### 11.阻止事件冒泡

​		window.event?window.event.cancelBubble=true :event.stopPropagation();

```html
 <body>
		<div onclick="fn('爷爷')">
			爷爷
			<div onclick="fn('爸爸')">
				爸爸
				<div onclick="fn('儿子')">
					儿子
				</div>
			</div>
		</div>
	</body>
	<script type="text/javascript">
		function fn(e){
			alert(e+'出手了');
			//判断是否为IE？为IE，阻止冒泡 ： 不是IE，阻止蔓延
			window.event?window.event.cancelBubble=true :event.stopPropagation();
		}
	</script>
```

### 12.阻止默认行为

​		window.event? e.returnValue = false :e.preventDefault();

```js
//oncontextmenu 鼠标右键
document.oncontextmenu = function (e) {
                                        e = e || window.event;
                                        //三目运算符，使其兼容ie与其他浏览器
                                        window.event? e.returnValue = false :e.preventDefault();
                                        alert('阻止默认事件成功');
                                   }  
```

### 13.储存数据到本地

 **cookie的特点和作用**

1. cookie存储数据在客户端浏览器。

    数据存储在服务器端，安全等级高。数据cookie存储在浏览器端，安全等级低，容易被篡改，但是访问速度快

2. 浏览器对于单个cookie的大小有限制(4kb)同一个域名下的总cooki e数量也有限制(20个)

    

**作用:**

1. cookie- 般用于存出少量的不太敏感的数据
2. 在不登录的情况下，服务器对客户端的身份识别

比如：设置搜索提示框



**Cookie特性**

1. 同一个网站中所有页面共享一套Cookie,cookie是按照域名进行存储的
2. 数量、大小有限 4-10k

<img src="E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322145516382.png" alt="image-20210322145516382" style="zoom:67%;" />

   3.过期时间，因为存储的空间太小了，所以到期就把数据给清理掉了

   4.每次会随着HTTP请求发送给服务器

​      每次请求都要携带的信息（最典型的就是身份认证信息）就特别适合放在cookie中，其他类型的数据就不适合了。

#### 1、创建Cookie

语法：

```javascript
document.cookie=”名字=值 ”;
```

示例：

```javascript
 <script>
        /* 
        创建cookie
        document.cookie=”名字=值 ” 
        */

        /* 
        创建username = ergou 到cookie中
        存储是否记住密码的状态  isremember=true 

        cookie中名字一样时，会覆盖原来的值
        */
        document.cookie = "usesrname=ergou";
        document.cookie = "isremember=true";
        document.cookie = "usesrname=fugui";


    </script>

```

> JS“=”代表覆盖，cookie“=”代表添加
>
> cookie中名字一样时，会覆盖原来的值



![image-20210322152355008](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322152355008.png)



#### 2、读取cookie值

语法：

```javascript
 document.cookie; //即获取到所有存储的cookie值
```

```javascript
 <script>
        /* 
        创建cookie
        document.cookie=”名字=值 ” 
        */

        /* 
        创建username = ergou 到cookie中
        存储是否记住密码的状态  isremember=true 

        cookie中名字一样时，会覆盖原来的值
        */
        document.cookie = "usesrname=ergou";
        document.cookie = "isremember=true";
        document.cookie = "usesrname=fugui";


        /* 
        读取cookie值语法：
        document.cookie;
        即得到所有的cookie存储数据
        */
       var cookies = document.cookie;
       console.log(cookies);
    </script>
```

![image-20210322152617551](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322152617551.png)

原生的cookie对前端人员很不友好，获取cookie值的时候一下子把所有的cookie信息给获取出来，如果需要其中的某一个具体的值，需要进行相对应的js进行拆分



```javascript
 <script>
        /* 
        创建cookie
        document.cookie=”名字=值 ” 
        */

        /* 
        创建username = ergou 到cookie中
        存储是否记住密码的状态  isremember=true 

        cookie中名字一样时，会覆盖原来的值
        */
        document.cookie = "usesrname=ergou";
        document.cookie = "isremember=true";
        document.cookie = "usesrname1=fugui";


        /* 
        读取cookie值语法：
        document.cookie;
        即得到所有的cookie存储数据
        */
       var cookies = document.cookie;
       console.log(cookies);

       /* 
       对接收到的cookie值进行拆分
       先通过；来进行拆分
       然后通过=进行拆分
       得到新的数组，通过判断数组下标[0]是否等于isremember 得到对应的值
       */

       var arry = cookies.split("; ");
       console.log(arry);
       for(var i=0;i<arry.length;i++){
            var new_arry = arry[i].split("=");
            console.log(new_arry);

            if(new_arry[0]=='age'){
                console.log(new_arry[1]);
            }
       }
		return'';
      
    </script>
```



#### 3、删除cookie

过期时间：expires=时间 【此处的时间为时间对象Date()】



 删除cookie,通过设置cookie键值对的过期时间

  通过 expires = 时间对象

语法：

```
document.cookie = "name=value;expires="+时间对象
```



```javascript
<script>
		/* 
       删除cookie,通过设置cookie键值对的过期时间
       通过 expires = 时间对象
       document.cookie = "name=value;expires="+时间对象
       */

       var time = new Date();
		//+1 代表一天后过期，如果想立马删除，可以设置-1
       time.setDate(time.getDate()+1);
       document.cookie="money=999999;expires="+time;
</script>
```

![image-20210322161729731](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322161729731.png)





**封装Cookie**

我们通过上面的学习，学到了设置cookie,获取cookie和删除cookie，那么如果我们接下来想再次的使用设置获取和删除cookie，就需要重新再来写一遍，这样非常的不方便。这里就用到了封装



**封装三个函数**

- setCookie()——创建Cookie
- getCookie()——获取Cookie
- removeCookie()——删除Cookie

**testMycookie.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    
    <script src="./myCookie.js"></script>
    <script>
        // 设置cookie 参数 键  值  有效时间
        setCookie('张三',12,2);
        setCookie('李四',18,2);

        //获取cookie 键名
        var val = getCookie('李四');
        console.log(val);

        //删除cookie  通过键名删除
        removeCookie('张三');

    </script>
</body>
</html>
```



封装好的cookie

myCookie.js:

```javascript
// 设置cookie 需要传入三个参数  键 值  过期时间
function setCookie(key,value,time){
    // console.log('time:'+time)
    var date_ = new Date();
    date_.setDate(date_.getDate()+time);
        document.cookie=key+'='+value+';expires='+date_;
}

// 获取cookie 键名
function getCookie(key){
    // 多个cookie通过；分割
    var arry = document.cookie.split(';');
    console.log(arry);
    for(var i=0;i<arry.length;i++){
        var n_arry = arry[i].split('=');
        // 多个cookie存值的时候  会存在某个cookie的值名前面有空格 去除
        var n_key = n_arry[0].replace(/^\s/,'');
        if(n_key == key){
            console.log(n_arry[0],n_arry[1]);
            return n_arry[1];
        }
    }
    return '';
}

//删除cookie  通过键名
function removeCookie(key){
    this.setCookie(key,'',-1);
}
```

# localStorage-本地存储

- 为永久性保存数据，不会随着浏览器的关闭而消失，可以在同域名跨页访问。
- 按域名进行存储，不会和其他域名冲突
- 键值对存储：key/value



#### localStorage存储数据：

语法：

```
localStorage.setItem(key,value);
```



```javascript
 <script>
        /* 
        设置storage
        localStorage.setItem(key,value);
        */
        localStorage.setItem('username','尼古拉斯赵四')

    </script>
```

<img src="E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322213653133.png" alt="image-20210322213653133" style="zoom:67%;" />





> **localSorage存储的值，必须是字符串，如果存储的是对象，则无法正常显示**

```javascript
 <script>
        /* 
        设置storage
        localStorage.setItem(key,value);
        */

        var user_message = {
            'name':'小宝',
            'address':'铁岭',
            'age':50
        }

        localStorage.setItem('user_message',user_message);

    </script>
```

![image-20210322214010812](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322214010812.png)



> localStroage存储数据，value必须是字符串，
>
> 所以如果想要存储的值是对象，需要先把对象转为字符串

JSON.parse(字符串);  字符串  转为  对象

JSON.stringify(对象);   对象 转为 字符串



```javascript
 <script>
        var user_message = {
            'name':'小宝',
            'address':'铁岭',
            'age':50
        }

        user_message = JSON.stringify(user_message);
        localStorage.setItem('user_message',user_message);
    </script>
```

<img src="E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322214526218.png" alt="image-20210322214526218" style="zoom:80%;" />





> localStorage.setItem(key , value)，保存或设置数据
> 如果key已经存在，则覆盖key对应的value
> 如果不存在则添加key与value





#### localStorage获取数据：

语法：

localStorage.getItem(key);   获取key对应的value。

如果key不存在则返回null



```javascript
 // 取值 localStorage.getItem(key);
        var user_message = localStorage.getItem('user_message');
        console.log(user_message);
```

![image-20210322215212870](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322215212870.png)

返回的字符串如果是一个对象字符串，最好转为对象，这样方便接收数据

```javascript
 var user_message = JSON.parse(localStorage.getItem('user_message'));
        console.log(user_message.address);
```

![image-20210322215607554](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322215607554.png)



#### localStorage删除数据：

clear(); 

将同域名下的所有localStorage数据都清空



清空前：

![image-20210322220053576](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322220053576.png)

清空后：

![image-20210322220248788](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322220248788.png)



removeItem('key'):
删除数据，通过key来删除相应的value

```javascript
// 删除数据  localStorage.removeItem(key)
        localStorage.removeItem('username');
```

删除前：

![image-20210322220053576](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322220053576.png)

删除后：

![image-20210322220136566](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322220136566.png)





length 获取localStorage一共有多少条数据

```
// length获取localStorage的长度
        console.log(localStorage.length)  //2
```



配合key(index)方法可以实现遍历localStorage数据的方法

```javascript
// localStorage以键值对的方式存在
        // localStorage.key(0)  根据下标获取键名
        console.log(localStorage.key(0)); //username
```



遍历localStorage

```javascript
 //遍历获取信息
        for(var i=0;i<localStorage.length;i++){
            var k_ = localStorage.key(i)
            var value = localStorage.getItem(k_);
            console.log(k_+":"+value);
        }
```



![image-20210322221318338](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322221318338.png)



#### localStorage同源事件：

当同源的localStorage有更改以后，会触发这个事件

<img src="E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322222258266.png" alt="image-20210322222258266" style="zoom: 67%;" />

打开素材同源事件，

![image-20210322222352369](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322222352369.png)

修改任意一个，查看页面变化：

![image-20210322222406227](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322222406227.png)

![image-20210322222423600](E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322222423600.png)

# sessionStorage



sessionStorage为临时性保存数据，当页面关闭就会消失。其他一切与localStorage一样

sessionStorage不能跨页面访问，也不会触发跨标签页的storage事件。它只局限在当前的标签页

存储临时性数据

其他的方法属性和localStorage一样





cookie和localStorage 和sessionStorage的区别：

<img src="E:\备份\学习视频\05_js高级\10_cookie&storage\笔记\assetis\image-20210322223121313.png" alt="image-20210322223121313" style="zoom:67%;" />





# 音&视频

### 音频

比如：autoplay属性，谷歌浏览器就不支持，ie是支持的，谷歌官方声明防止广告的自动播放，影响用户体验，所以网页中所有的音视频全部需要用户自己点击

语法：

```html
< audio src="音频路径"> </ audio >
```

| 属性     | 值             | 说明                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| controls | controls       | 如果出现该属性，则向用户显示控件，比如播放按钮               |
| autoplay | autoplay       | 如果出现该属性，则音频在就绪后马上播放 [自动播放]            |
| loop     | loop           | 如果出现该属性，则当音频结束时重新开始播放 [循环播放]        |
| preload  | auto/meta/none | 如果出现该属性，则音频在页面加载时进行加载，并预备播放 [预加载] |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>

    <style>
        audio{
            /* 与border效果相同 */
            outline: none;
        }
    </style>
</head>
<body>
    <audio src="./video/我和我的祖国.mp3" controls  autoplay loop></audio>
</body>
</html>
```

source可链接不同格式的音频文件

```html
<h2>在html5中播放音频：</h2> 
<audio controls="controls">
       <source src="vedio/song.ogg"/>
       <source src="vedio/song.mp3"/>
         您的浏览器不支持audio元素播放的音频
</audio>

```

### 视频

语法：

```html
< video src="视频路径"> </ video>
```



| **属性**     | **值**     | **说明**                                                     |
| ------------ | ---------- | ------------------------------------------------------------ |
| controls     | controls   | 如果出现该属性，则向用户显示控件，比如播放按钮               |
| autoplay     | autoplay   | 如果出现该属性，则视频在就绪后马上播放 [自动播放]            |
| loop         | loop       | 如果出现该属性，则当视频结束时重新开始播放 [循环]            |
| preload      | auto       | 如果出现该属性，则视频在页面加载时进行加载，并预备播放 [预加载] |
| width/height | length(px) | 设置视频播放器的宽度/高度                                    |
| muted        | muted      | 静音播放                                                     |

```html
  <video  src="./video/video.webm" controls width="300px" height="100px">
        不支持当前格式
    </video>
```

### source元素

video元素允许多个source元素
source可链接不同的视频文件

```html
<h2>在html5中播放音频：</h2> 
<video controls="controls">
      <source src="vedio/vedio.mp4"/>
      <source src="vedio/vedio.ogg"/>
      <source src="vedio/video.webm"/>
     您的浏览器不支持video播放的视频
</video>

```

```html
<details>
<summary>展开查看</summary>
<pre><code>
System.out.println("Hello to see U!");
</code></pre>
</details>
```

### 自定义视频播放器





### 属性

controls  :   显示或隐藏用户控制界面
autoplay  :  媒体是否自动播放
loop  : 媒体是否循环播放
paused  :   媒体是否暂停(只读)
ended   :   媒体是否播放完毕(只读)

currentTime  :  开始播放到现在所用的时间
duration  :  媒体总时间(只读)
volume  :   0.0-1.0的音量相对值
muted  :   是否静音



### 方法和事件

play()  :  媒体播放
pause()  :  媒体暂停

webkitRequestFullScreen():全屏

timeupdate :  时间更新
canplay: 可以播放





html主题样式在素材中，我们只写js方法

```javascript
// 获取video
var video = document.getElementById('video');
var jp_play = document.getElementsByClassName('jp-play')[0];//播放按钮
var jp_pause = document.getElementsByClassName('jp-pause')[0];//暂停按钮
var jp_duration = document.getElementsByClassName('jp-duration')[0];//总时间
var jp_current_time = document.getElementsByClassName('jp-current-time')[0];//当前时间
var jp_play_bar = document.getElementsByClassName('jp-play-bar')[0];//当前进度条
var jp_seek_bar = document.getElementsByClassName('jp-seek-bar')[0];//进度条
var jp_full_screen = document.getElementsByClassName('jp-full-screen')[0];//全屏


// 点击播放
video.addEventListener('canplay', function () {
    //点击按钮播放
    jp_play.addEventListener('click', function () {
        video.play();
        this.style.display = 'none';
        jp_pause.style.display = 'block';
    });

    //点击暂停
    jp_pause.addEventListener('click', function () {
        video.pause();
        this.style.display = 'none';
        jp_play.style.display = 'block';
    });

    //显示总的时长
    jp_duration.innerHTML = format_time(video.duration);



    // 时间更新
    video.addEventListener('timeupdate', function () {
        //显示当前播放的时间
        jp_current_time.innerHTML = format_time(video.currentTime);

        //根据百分比设置进度条的值
        jp_play_bar.style.width = (video.currentTime / video.duration) * 100 + '%';
    });


    //点击拖拽进度条
    jp_seek_bar.addEventListener('click',function(e){
        e = e|| window.event;
        var width = jp_seek_bar.offsetWidth;//元素的宽度
        var small = e.offsetX;
        var b = small / width;

        //设置进度条内容
        jp_play_bar.style.width = (b*100+'%');
        //根据比例来设置当前的时间
        jp_current_time.innerHTML = format_time(b * video.duration);
        //设置播放的位置
        video.currentTime = b * video.duration;
    });

    
    //设置quanp
    jp_full_screen.addEventListener('click',function(){
        video.webkitRequestFullScreen();
    });

    //格式化时间
    function format_time(time) {
        var m = Math.floor(time / 60);//得到分钟
        m > 10 ? m : m = ('0' + m);
        var s = Math.floor(time % 60);//秒
        s > 10 ? s : s = ('0' + s);

        return m + ':' + s;
    }

});
```

# ES6

## let与const 

### let

1.let没有变量提升

​	不像var一样，会强行把要打印的下面的对象强行提升到最上面进行变量声明

![image-20221222112017475](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221222112017475.png)

2.let是块级作用域

![image-20221222111956206](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221222111956206.png)

3.不能重复声明



![image-20221222111927962](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221222111927962.png)

### const

1.1.let没有变量提升

​	不像var一样，会强行把要打印的下面的对象强行提升到最上面进行变量声明

2.let是块级作用域

3.不能重复声明

4.只能声明常量

5.const声明的变量必须直接赋值，不能在下面再进行复制

6.const也可以声明对象，在下面也可以对对象里面的属性进行修改，但是不能直接对对象进行重写

![image-20221222113207846](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221222113207846.png)

![image-20221222113221151](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221222113221151.png)

# Github

### 0.基础命令

​		查询本地仓库：`git reflog`

​		回退版本：`git reset –hard` 版本号

​		推送到缓存：`git add .`

​		推送到本地仓库：`git commit –m”次推送的名称”`

​		推送本地仓库到远程仓库：`git push origin main`

### 1.创建远程仓库

![image-20221020231241035](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231241035.png)

![image-20221020231250003](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231250003.png)

### 2.删除远程仓库

![image-20221020231437298](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231437298.png)

![image-20221020231443880](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231443880.png)

![image-20221020231453572](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231453572.png)

![image-20221020231507989](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231507989.png)

<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231519338.png" alt="image-20221020231519338" style="zoom:80%;" />

### 3.创建ssh

一台电脑只有一个密钥和公钥，用来链接本地仓库和远程仓库

<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020231621848.png" alt="image-20221020231621848" style="zoom: 80%;" />

1. 检测是否有ssh，

   ​	输入：`ls -al ~/.ssh` 

​		          ![image-20221020232130269](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232130269.png)

​	           	这样是没有

​	2.创建一个ssh

​       	输入：`ssh-keygen -t rsa -C ''xxx''`

​     	  一直点确定键创建完成

​         		![image-20221020232049571](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232049571.png)

​	3.创建成功

​      		![image-20221020232408912](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232408912.png)

​	4. 打开里面的公匙，并复制里面的内容

​				![image-20221020232439257](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232439257.png)

​		5.点击github的设置

​			![image-20221020232519569](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232519569.png)

​			![image-20221020232528513](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232528513.png)

​	6.用公匙绑定本地文件

​		![image-20221020232628333](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232628333.png)

​		7.绑定成功

​				![image-20221020232706039](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232706039.png)

​		8.验证

​			输入：`ssh -T git@github.com`

​			![image-20221020232850740](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020232850740.png)

### 4.将本地仓库添加到远程仓库

- 输入：`git remote add origin git@github.com:2277684550/study_01.git`

​				![image-20221020233055969](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020233055969.png)

​				报错了，表示远程仓库已存在，删除关联的origin远程库

​				输入：`git remote rm origin` 

​				再次输入：`git remote add origin git@github.com:2277684550/study_01.git`便成功

​				然后输入：`git push -u origin main`推送到仓库

​				![image-20221020233255742](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020233255742.png)

- 更改远程库内容

  先在本地库更改内容，再推送到远程库

​		![image-20221020233400889](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020233400889.png)

​			当再次更改以前的版本再推送库会报错，可能是因为库里面已经有了之前的版本，再次提交

​			以前的版本会报错，只能推送未提交过的版本

​			![image-20221020233435863](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221020233435863.png)

### 5.公开项目

​				![image-20221021094942140](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021094942140.png)

​					![image-20221021094950835](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021094950835.png)

### 6.克隆远程仓库

​			1、gitHub新建一个远程仓库，在本地克隆

​				![image-20221021095038469](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095038469.png)

​				![image-20221021095049141](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095049141.png)

​			2.输入：git clone 刚才复制的网址

​				![image-20221021095112735](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095112735.png)

​			3.克隆成功

​				![image-20221021095133916](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095133916.png)

### 7.分支操作

​		在克隆成功的项目下，查看分支：

​			查看分支：`git branch`

​			创建分支：`git branch` 分支名

​			切换分支：git switch name或者`git checkout name name`表示分支名

​			创建+切换分支：`git switch -c name`或者`git checkout -b name`

​			合并某分支到当前分支：`git merge name`

​			删除分支：`git branch -d name`

### 8.多人协作

​		![image-20221021095355175](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095355175.png)

​				1.创建分支

​					<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095606981.png" alt="image-20221021095606981" style="zoom: 67%;" />

​				2.克隆分支

​					![image-20221021095616218](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095616218.png)

​				    A文件夹克隆

​					![image-20221021095638016](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095638016.png)

​		    		B文件夹克隆	

​							同A操作

​				3.检测链接是否成功

​					![image-20221021095806839](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095806839.png)

​					<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095832636.png" alt="image-20221021095832636" style="zoom: 80%;" />

​				4.创建本地分支并连接远程分支

​					输入：`git checkout -b dev origin/dev`

​						![image-20221021095855634](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095855634.png)

​						![image-20221021095919581](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095919581.png)

​				5.创建index.html文件并写入内容

​						![image-20221021095928791](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095928791.png)

​						![image-20221021095945934](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095945934.png)

​						![image-20221021095954049](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021095954049.png)

​							![image-20221021100002839](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100002839.png)

​								同样的方法操作B文件

​								因为A已经上传过了，再上传B会冲突，先把A从远程仓库拉下来，解决冲突后再推送B

​								![image-20221021100040125](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100040125.png)

​								输入：`git pull origin dev`

​								拉下来后保留两个更改

​								![image-20221021100129755](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100129755.png)

​								![image-20221021100144711](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100144711.png)

​								推送成功

​								![image-20221021100215896](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100215896.png)

### 				9.远程仓库合并分支

​								![image-20221021100302933](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100302933.png)

​								![image-20221021100310957](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100310957.png)

​								![image-20221021100320509](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100320509.png)

​										![image-20221021100333602](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021100333602.png)

# 移动端

### 0.弹性布局

- ####  html

![img](https://img-blog.csdnimg.cn/ec8122f9c2d64f21aa16fef72a937a00.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

- #### css

主轴:以谁为准谁为主轴，另一条轴为侧轴

![img](https://img-blog.csdnimg.cn/b691eda0cbab40e594f4fb5315178da8.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://img-blog.csdnimg.cn/619a7c2cdaa649608e71056212ad1f21.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://img-blog.csdnimg.cn/84da08fda8d54418935cc62d17ca75ed.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 ![img](https://img-blog.csdnimg.cn/0315c984ccb9426a82e630f3cff0eb21.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

- #### 基础属性

  注：这些属性都是写在父元素里面

| 容器属性        | 常用值                                                       | 说明                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| flex-direction  | column（垂直）/row（水平）/ 			row-reverse \|\| column-resverse（反向排列） | 决定主轴方向                                                 |
| flex-warp       | warp（换行） / no-warp（不换行）                             | 如果在一条轴线线上排不下，是否换行                           |
| justify-content | flex-start（左对齐） flex-end（右对齐） 			center（居中对齐） 			space-between（平均分布,两侧紧挨） 			space-around（平均分布,两侧空白为中间空白一半） 			space-evebly（平均分布,所有空白长度一样） | 定义子元素在主轴上的对齐方式（详情看图1.0）                  |
| align-items     | flex-start（侧轴起点对齐） flex-end（侧轴终点对齐） 			center（侧轴中间对齐） baseline（以首子元素文字下基线对齐） stretch（若子元素未设置高度或为auto，则占满整个容器高度） | 定义子元素在侧轴上的对齐方式（单行也可用） 			（详情看图1.1） |
| align-content   | flex-start（侧轴起点对齐） flex-end（侧轴终点对齐） 			center（侧轴中间对齐）space-between（两侧紧挨，平均分布） 			space-around（平均分布） 			stretch(将父元素高度平分，子元素各占一份) | 设置侧轴上子元素的排列方式（必须多行才能使用） 			（详情看图1.2） |



- #### 子元素属性

​    注：这些属性都是写在子元素里面

| 子元素容器属性 | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| order          | 设置某子元素排列顺序，后面填阿拉伯数字，最小为0，默认也为0，数字越大，排序越靠后 |
| flex-grow      | 设置某子元素放大比例，默认为0，将剩余空间分成所有的子元素下面的flex-grow值和，然后该子元素占其中的flex-grow值份 |
| flex-shrink    | 设置某子元素缩小比例，默认为1，前提是子元素超出父元素后没有添加换行属性，此时会把加入该属性的子元素缩小，缩小的比例为flex-shink值 |
| flex           | 复合属性，代表flex-grow,flex-shink,flex-basis的简写，常用，当剩余空间少时缩放，当剩余空间多时放大 |
| align-self     | 定义该子元素在该子元素所分的的块的侧轴的对齐方式，有start，center，end |

![img](https://img-blog.csdnimg.cn/23c2def1f1f14954964691045833e5d3.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

------



![img](https://img-blog.csdnimg.cn/343398f5d3ff4dbb9688cf8dd51f94c6.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 ![img](https://img-blog.csdnimg.cn/d491c6e2a6dc4de2b7bcdb84466eaca0.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 1.em与rem

​	对比：

​			em会继承父级元素的字体大小（相对父级的字体大小而发生变化）(不常用)

​			rem是相对根节点html发生变化的（和父节点无关）（常用）

​	用法：

​			rem：实际开发中一般默认的把html根节点设置为10px（62.5%）或者是100px，方便后续计算   

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rem相对根节点</title>

    <style>
        /* rem是相对于根节点html的font-size值
            
         */
        html{
            font-size: 100px;
        }
        div{
            /* 16像素 */
            font-size: .16rem;
        }
        h1{
            /* 20像素 */
            font-size: .2rem;
        }
    </style>
</head>
<body>
    <div>
        哈哈，我是div元素
        <h1>我是div的儿子h1</h1>
    </div>
</body>
</html>
```





通过js动态设置字体大小	

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rem相对根节点</title>

    <style>
        /* rem是相对于根节点html的font-size值
            
         */
        html {
            font-size: 100px;
        }

        div {
            /* 16像素 */
            font-size: .16rem;
        }

        h1 {
            /* 20像素 */
            font-size: .2rem;
        }
    </style>
</head>

<body>
    <div>
        哈哈，我是div元素
        <h1>我是div的儿子h1</h1>
    </div>
</body>

<script>
    function setRem() {
        var ui_w = 375;
        // 获取屏幕的宽度
        var clientWidth = document.documentElement.clientWidth || document.body.clientWidth;
        console.log(ui_w,clientWidth);

        // 通过js动态改变html根节点字体大小
        var html_ = document.getElementsByTagName('html')[0];
        html_.style.fontSize = (clientWidth/ui_w)*100 +'px';
    }
    // window.onresize 浏览器被重置大小执行事件
    window.onresize = setRem;


</script>

</html>
```



### 2.Touch点击事件模型

| touchstart  | 手指刚接触屏幕时触发，在移动端上使用click事件会有300s延迟，用这个代替click |
| ----------- | ------------------------------------------------------------ |
| touchmove   | 手指在屏幕上移动时触发                                       |
| touchend    | 手指从屏幕上移开时触发                                       |
| touchcancel | 当一些更高级别的事件发生的时候（如电话接入或者弹出信息）会取消当前的touch操作，即触发touchcancel。一般会在touchcancel时暂停游戏、存档、暂停视频音乐等操作 |

注意，在绑定事件的时候，要加上关键字on

```js
<script>
    var div = document.getElementsByTagName('div')[0];
	//手指接触屏幕触发事件
    div.ontouchstart = function(){
        div.style.backgroundColor = 'red';
	
    }
	//手指在屏幕上移动触发事件
	div.ontouchmove = function(){
		div.style.backgroundColor = 'yellow'
	}
	//手指从屏幕上离开触发事件
	div.ontouchend = function(){
		div.style.backgroundColor = 'green'
	}
	//高级事件，当来电或者来信息时触发，通常用暂停游戏或者视频
	div.ontouchcancel = function(){
		div.style.backgroundColor = 'black'
	}
	//触摸属性（event），用来两指或多指点击屏幕，用来检测放大还是缩小
	//当一个手指在触屏上时：event.touches.length=1
	//当两个手指在触屏上时：event.touches.length=2
</script>
```

### 3.触摸事件坐标（event事件）

```html

<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

    <style>
        div{
            width: 100%;
            height: 500px;
            background-color: skyblue;
        }
    </style>
</head>

<body>
    <div></div>

</body>

<script>

    var div = document.getElementsByTagName('div')[0];
    div.ontouchstart = function(e){
        e = e||window.event;
        console.log(e);
    }

</script>

</html>



```

![image-20221021153711216](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021153711216.png)



| clientX    | 触摸目标在视口中的x坐标  视觉视口    |
| ---------- | ------------------------------------ |
| clientY    | 触摸目标在视口中的y坐标   视觉视口   |
| identifier | 标识触摸的唯一ID                     |
| pageX      | 触摸目标在页面中的x坐标     布局视口 |
| pageY      | 触摸目标在页面中的y坐标     布局视口 |
| screenX    | 触摸目标在屏幕中的x坐标              |
| screenY    | 触摸目标在屏幕中的y坐标              |
| target     | 触摸的DOM节点目标，返回触摸的元素    |

注意：

clientX/Y和pageX/Y的区别：

clientX/Y：相对于视觉视口的左上角

pageX/Y：相对布局视口的左上角。布局视口 是可以滚动的



```
<script>

    var div = document.getElementsByTagName('div')[0];
    div.ontouchstart = function(e){
        e = e||window.event;
        console.log(e);
        str = '';
        for(var i = 0;i<e.changedTouches.length;i++){
            str += '第'+(i+1)+'根手指的id是：'+e.changedTouches[i].identifier;
            str +='<br>第'+(i+1)+'根手指的screenx坐标：'+e.changedTouches[i].screenX;
            str +='<br>第'+(i+1)+'根手指的screenY坐标：'+e.changedTouches[i].screenY;
            div.innerHTML = str;

        }

    }

</script>
```



### 4.封装事件

- #### 判断点击还是拖拽

```js
<script>
	//判断是否点击还是拖拽
	//创建一个对象
	var touch_ = {
		//创建一个tab属性，里面有一个函数,传入一个参数，参数为dom元素
		tab:function(el){
			var sx,sy,ex,ey;
			//获取开始触摸点属性
			el.ontouchstart = function(e){
				e = e || window.event;
				//获取第一个手指点击屏幕触发事件的位置
				sx = e.changedTouches[0].clientX;
				sy = e.changedTouches[0].clientX;
			}
			//获取结束触摸点属性
			el.ontouchend = function(e){
				e = e || window.event;
				//获取第一个手指离开屏幕触发事件的位置
				ex = e.changedTouches[0].clientX;
				ey = e.changedTouches[0].clientX;
				
				//让结束 减去 开始 ，判断得到的误差， 误差为50px
				//Math.abs()转为绝对值
				if(Math.abs(ex-sx) <=50&& Math.abs(ey-sy) <= 50){
					alert('点击事件')
				}
				else{
					alert('拖拽事件')
				}
			}
		}
	}
	var div = document.getElementsByTagName('div')[0];
	//调用对象属性并传参
	touch_.tab(div);
</script>
```

- #### 封装单击事件

为什么要封装单击事件？

比如：

我们现在给同一个元素绑定了点击和移动两个事件

因为移动端的屏幕非常小，点击完以后，手在抬起来的时候，很容易造成一点的移动偏差

此时就很容易触发移动事件

我们需要进行一个判断，比如手在抬起来的时候，位置偏差范围多少的情况下视为单击离开

偏差多少的范围外，视为移动事件



```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>封装单击事件</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        .div1,.div2{
            height: 200px;
            background-color: skyblue;
            margin-bottom: 30px;
        }
    </style>
    
</head>

<body>
    <div class="div1"></div>
    <div class="div2"></div>

</body>

<script>
    var div1 = document.getElementsByClassName('div1')[0];
    var div2 = document.getElementsByClassName('div2')[0];

    // 把点击事件封装成对象的方法
    var touchEvent = {
        
        tab:function(el){
            var end_x,end_y,start_x,start_y;
            el.ontouchstart = function(e){
                e =e||window.event;
                // 获取按下动作的x值和y值
                start_x = e.changedTouches[0].clientX;
                start_y = e.changedTouches[0].clientY;
            }

            el.ontouchend = function(e){
                e = e||window.event;
                //获取抬起动作的x值和y值
                end_x = e.changedTouches[0].clientX;
                end_y = e.changedTouches[0].clientY;

                if(Math.abs(end_x-start_x)<10 && Math.abs(end_y-start_y)<10){
                    alert('您调用了点击事件')
                }else{
                    alert('您调用了移动事件');
                }
            }
        }
    }

    touchEvent.tab(div1);
    touchEvent.tab(div2);
</script>

</html>
```

### 5.移动端事件库

`Touch.js`是移动设备上的手势识别与事件库, 由百度云Clouda团队维护，也是在百度内部广泛使用的开发工具.(已停更)

`Touch.js`手势库专为移动设备设计,是Web移动端touch点击事件不错的解决方案

https://github.com/Clouda-team/touchjs

| **属性**   | **设备类型** |
| ---------- | ------------ |
| tap        | 单击屏幕     |
| doubletap  | 双击屏幕     |
| swipe      | 滑动         |
| swipeleft  | 向左滑动     |
| swiperight | 向右滑动     |
| swipeup    | 向上滑动     |
| swipedown  | 向下滑动     |
| hold       | 长按屏幕     |
| dragstart  | 拖动开始     |
| drag       | 拖动         |
| pinchstart | 缩放手势起点 |
| pinchin    | 收缩         |
| pinchout   | 放大         |

![image-20210415010603531](E:\备份\学习视频\09_移动端\09-05、移动端事件\笔记\assetis\image-20210415010603531.png)

用法：

```js
//引入touchjs
<script src="js/touch-0.2.14.min.js"></script>
/*
	touch.on(1,2,3)

    三个参数：
	1、DOM元素
	2、移动端事件
	3、处理函数

 */
touch.on(oBox, 'tap', function(ev) {
     this.style.background = "red";
     this.style.color = '#fff'; 
});
```





示例：

```javascript
<script>
    var div = document.getElementsByTagName('div')[0];
    touch.on(div,'tap',function(){
        this.style.backgroundColor = 'red';
    });
    touch.on(div,'doubletap',function(){
        this.style.backgroundColor = 'green';
    });

    // 长按
    touch.on(div,'hold',function(){
        alert('长按');
        this.style.backgroundColor = 'yellow';

    })
    // 拖动
    touch.on(div,'drag',function(){
        
        this.style.backgroundColor = 'pink';

    })



</script>
```

### 6.点透现象

```js
/* 点击第一层第一个,令其消失*/
b.addEventListener('touchstart', function(e) {
    level10.style.display = 'none';
});
a.onclick = function() {
    console.log('看下会不会被点击到');
}
点透发生的条件
A 和 B不是后代继承关系，而是兄弟关系
b发生touch， b touch后立即消失， a事件绑定click
b显示在a浮层之上

```

```html
  <style>
        div{
            width: 100%;
            height: 200px;
            
        }

        .a{
            position: absolute;
            background-color: rgb(241, 71, 71);
        }
        .b{
            position: absolute;
            background-color: rgb(70, 145, 41);
        }
    </style>
  
</head>

<body>
    <div class="a"></div>
    <div class="b"></div>

</body>

<script>
    var a = document.getElementsByClassName('a')[0];
    var b = document.getElementsByClassName('b')[0];

    b.addEventListener('touchstart',function(){
        b.style.display = 'none';
    });

    a.onclick = function(){
        alert('a显示出来了，红色的');
    }
</script>
```



- #### 解决点透问题


将click换成移动端事件

```javascript
  // a.onclick = function(){
 //     alert('a显示出来了，红色的');
 // }
a.ontouchstart = function(){
        alert('a显示出来了，红色的');
    }
```

### 7.图片懒加载

```js
<script>
        
        function load(){
            // 1.获取桌面高度
            var clientH=document.documentElement.clientHeight || document.body.clientHeight;
            // 2获取已加载高度
            var scroolH=document.documentElement.scrollHeight || document.body.clientHeight;
            // 3.获取所有图片
            var image=document.getElementsByClassName('images');
            // 4.找到图片中的每一个并判断
            for(var img of image){
                //懒加载,offsetTop为元素到祖宗定位的距离，即到body顶部的距离
                //当已加载区域高与屏幕高的和超过元素到offsetTop，就加载图片并替换
                //-20是提前20px开始加载内容
                //当真实路径为空时是为了重复加载
                if(clientH+scroolH>=img.offsetTop-20 && img.getAttribute('data-realSrc')){
                    //找到真实路径
                    var realSrc=img.getAttribute('data-realSrc');
                    //替换路径
                    img.src=realSrc;
                    //每一次加载后，删除原本的真实路径，防止重复加载
                    img.removeAttribute('data-realSrc')
                }
            }

        }
        load();
        window.onscroll = load
    </script>
```

### 8.swiper轮播图

​	https://www.swiper.com.cn/usage/index.html



- #### 首先加载插件，在html中引入插件


​	需要用到的文件有swiper-bundle.min.js和swiper-bundle.min.css文件，不同[Swiper版本](https://www.swiper.com.cn/about/us/index.html#version-different)用到的文件名略有不同。可下载[Swiper文件](https://www.swiper.com.cn/download/index.html#file1)或使用[CDN](https://www.swiper.com.cn/cdn/index.html)。

- 下载swiper文件：把swiper的css和js样式下载到本地，放进项目中直接使用

- CDN：使用远程的网址链接，直接引用swiper得到css和js样式。【网速不好的情况下不建议使用，加载慢】



下载swiper文件：

点击获取swiper

![image-20210408100516024](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408100516024.png)



解压，重点找：

swiper-bundle.min.css 和swiper-bundle.min.js两个文件

复制到项目中

![image-20210408101332860](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408101332860.png)



CDN：

![image-20210408100608429](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408100608429.png)



在html中引入插件：

![image-20210408101951308](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408101951308.png)





- #### HTML内容


![image-20210528043815741](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210528043815741.png)

也可以官网找到类似案例,复制html结构，css样式js语法

```
<div class="swiper-container">
    <div class="swiper-wrapper">
        <div class="swiper-slide">Slide 1</div>
        <div class="swiper-slide">Slide 2</div>
        <div class="swiper-slide">Slide 3</div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>
    
    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
    
    <!-- 如果需要滚动条 -->
    <div class="swiper-scrollbar"></div>
</div>
导航等组件可以放在container之外
```



- #### 你可能想要给Swiper定义一个大小，当然不要也行。


```
.swiper-container {
    width: 600px;
    height: 300px;
}  
```

- #### 初始化Swiper


```javascript
<script>        
  var mySwiper = new Swiper ('.swiper-container', {
    direction: 'vertical', // 垂直切换选项
    loop: true, // 循环模式选项
    
    // 如果需要分页器
    pagination: {
      el: '.swiper-pagination',
    },
    
    // 如果需要前进后退按钮
    navigation: {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev',
    },
    
    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })        
  </script>
```



如何更改初始化swiper中js内容的值？



![image-20210408103207927](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408103207927.png)





轮播图切换效果：

![](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/testSwiper.gif)

```html
<body>
		<!--使用两个轮播图，需要在html里面每一个都重新绑定一个id，在js里面重新引用-->
		<div class="swiper" id="swiperOne">
		    <div class="swiper-wrapper">
		        <div class="swiper-slide">
					<img src="./images/0.jpg" alt="">
				</div>
		        <div class="swiper-slide">
		        	<img src="./images/1.jpg" alt="">
		        </div>
				<div class="swiper-slide">
					<img src="./images/2.jpg" alt="">
				</div>
				<div class="swiper-slide">
					<img src="./images/3.jpg" alt="">
				</div>
				<div class="swiper-slide">
					<img src="./images/4.jpg" alt="">
				</div>
		    </div>
			<!-- <span style="width: 100px;height: 50px;background-color: aliceblue;"></span> -->
		    <!-- 如果需要分页器 -->
		    <div class="swiper-pagination" id="swpOne"></div>
		    
		    <!-- 如果需要导航按钮 -->
		    <div class="swiper-button-prev" id="swiper-button-prev_one"></div>
		    <div class="swiper-button-next" id="swiper-button-next_one"></div>
		    
		</div>
		<div class="header">
			<a href="./signIn.html" id="myBook">
				我的书架
			</a>
		</div>
		<div class="swiper" id="swiperTwo">
			<div class="swiper-wrapper">
				<div class="swiper-slide"><img src="../images/1.0.jpg" alt=""></div>
				<div class="swiper-slide"><img src="../images/1.1.jpg" alt=""></div>
				<div class="swiper-slide"><img src="../images/1.2.jpg" alt=""></div>
				<div class="swiper-slide"><img src="../images/1.3.jpg" alt=""></div>
				<div class="swiper-slide"><img src="../images/1.4.jpg" alt=""></div>
				<div class="swiper-slide"><img src="../images/1.5.jpg" alt=""></div>
			</div>
			<!-- 如果需要分页器 -->
			<div class="swiper-pagination" id="swpTwo"></div>
			
			<!-- 如果需要导航按钮 -->
			<div class="swiper-button-prev" id="swiper-button-prev_two"></div>
			<div class="swiper-button-next" id="swiper-button-next_two"></div>
			
		</div>
		
		<div class="main">
			
		</div>
		<div class="fotter">
			
		</div>
	</body>
```



```js
//使用两个轮播图，需要在html里面每一个都重新绑定一个id，在js里面重新引用
var mySwiperOne = new Swiper ('#swiperOne', {
    direction: 'horizontal', // 垂直切换选项
    loop: true, // 循环模式选项
    
    // 如果需要分页器
    pagination: {
      el: '#swpOne',
	  clickable :true,//点击小点，跳转图片
	  // dynamicBullets: true,//小点多时，使中间的突出放大
	  //使分页器显示文字
	       renderBullet: function (index, className) {
	            switch(index){
	              case 0:text='射手凶猛';break;
	              case 1:text='修行在废土';break;
	              case 2:text='古神在低语';break;
	              case 3:text='从剧本杀店开始';break;
	              case 4:text='一万种清除玩家的方法';break;
	            }
	            return '<span class="' + className + '">' + text + '</span>';
	          },
    },
    
    // 如果需要前进后退按钮
    navigation: {
      nextEl: '#swiper-button-next_one',
      prevEl: '#swiper-button-prev_one',
    },
    
	 autoplay:true,//等同于以下设置
	  autoplay: {
	    delay: 2000,

	    disableOnInteraction: true//点击页面暂停移动
	    },
  })
  var mySwiperTwo = new Swiper ('#swiperTwo', {
    direction: 'horizontal', // 垂直切换选项
    loop: true, // 循环模式选项
	//几个为一组
    slidesPerView : 4,
	//每组的间隔
    spaceBetween : 50,
	

    // 如果需要分页器
    pagination: {
      el: '#swpTwo',
	  clickable :true,
    },
    // 如果需要前进后退按钮
    navigation: {
      nextEl: '#swiper-button-next_two',
      prevEl: '#swiper-button-prev_two',
    },
	autoplay:true,//等同于以下设置
	  autoplay: {
	    delay: 2000,

	    disableOnInteraction: true//点击页面暂停移动
	    },
  })            
```



发现没有小圆点分页器，这能行吗？？？

![image-20210408143322851](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408143322851.png)





好玩儿的切换效果：
![image-20210408144607983](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408144607983.png)

![image-20210408144703694](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/image-20210408144703694.png)

```javascript
<!-- 初始胡swiper -->
<script>
    var mySwiper = new Swiper('.swiper-container', {
        initialSlide: 2,
        direction: 'horizontal',
        loop: true,//循环轮播
        
        // 切换点击按钮
        navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',

        },

        autoplay: true,//等同于以下设置
        autoplay: {
            delay: 3000,
            stopOnLastSlide: false,//如果设置为true，当切换到最后一个slide时停止自动切换。（loop模式下无效）。
            disableOnInteraction: false,//滑动后停止自动切换  false 滑动不停止
        },

        pagination: {
            el: '.swiper-pagination',//分页器
        },
        effect :'cube',//切换效果'slide'（普通切换、默认）,"fade"（淡入）"cube"（方块）"coverflow"（3d流）"flip"（3d翻转）。

    })


</script>

```





### 9.响应式布局

​		是同一页面在不同屏幕尺寸下有不同的布局，一套页面，可以在不同的设备上正常显示

​		![响应式布局](file://E:/%E5%A4%87%E4%BB%BD/%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91/09_%E7%A7%BB%E5%8A%A8%E7%AB%AF/09-02%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80&%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/%E7%AC%94%E8%AE%B0/assetis/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80.gif?lastModify=1666343310)

​	通过上图，我们发现在进行屏幕缩放的时候，缩放到一定的程度，一些内容不再显示，只显示主要内容

​	**通过设定屏幕不同时刻的样式进行设置**

```html
<title>响应式布局</title>
<link rel="stylesheet" type="text/css" media="screen and (max-width: 480px)" href="style-1.css" />
<link rel="stylesheet" type="text/css" media="screen and (min-width: 480px) and (max-width: 760px)" href="style-2.css" />
<link rel="stylesheet" type="text/css" media="screen and (min-width: 760px) and (max-width: 995px)" href="style-3.css" />
<link rel="stylesheet" type="text/css" media="screen and (min-width: 995px) and (max-width: 1100px)" href="style-4.css" />
<link rel="stylesheet" type="text/css" media="screen and (min-width: 1100px)" href="style-5.css" />
```

如上述代码：

分别设置

 屏幕最大480px时，展示一套css样式

屏幕最小480px,最大760px时，展示一套css样式

屏幕最小7690px,最大995px时，展示一套css样式

屏幕最小1100pxs时，展示一套css样式



### 10.媒体查询

> 媒体：指的就是各种设备 (移动设备, PC设备)
>
> 查询：指的是要检测属于哪种设备
>
> 
>
> 媒体查询: 通过查询当前属于哪种设备, 让网页能够在不同的设备下正常的预览。根据设备 展示不同的css样式

媒体特性语法：

```html
<style>
@media  媒体类型  and  （媒体特性）{ 
        CSS样式 
}
</style>
```

- #### 媒体查询案例：


需求：

- 宽度大于900px  背景red
- 介于500-900px 背景 green
- 小于500px 背景yellow

![media_1](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/media_1.gif)

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="">
    <script src=""></script>

    <style>
     
        @media screen and (max-width:500px){
            body{
                background-color: yellow;
            }
        }

        @media screen and (min-width:501px) and (max-width:900px) {
            body{
                background-color: green;
            }
        }

        @media screen and (min-width:901px) {
            body{
                background-color: red;
            }
        }

    </style>
</head>

<body>
   <!--  
    - 宽度大于900px 背景red
    - 介于500-900px 背景 green
    - 小于500px 背景yellow -->



</body>

</html>
```



- #### 通过媒体查询，解决屏幕获取不到高清图片


思路： 通过媒体查询dpr的值，不同的值显示不同质量的图片

在开发中，我们会根据dpr的值显示1倍图，2倍图，3倍图等

此处为了演示，我们只让显示不同的图片，来代替123倍图

![dpr1](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/dpr1.gif)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div{
            width: 800px;
            height: 500px;
        }
        @media screen and (-webkit-min-device-pixel-ratio: 1){
            div{
                background:url(./image/1.jpg);
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio: 2){
            div{
                background:url(./image/2.jpg);
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio: 3){
            div{
                background:url(./image/3.jpg);
            }
        }
    </style>
</head>
<body>
    <div>

    </div>
</body>
</html>
```





刚才判断属性的时候，我们使用了and关键词，and表示多个条件同时满足

除了and，还有其他的关键词

- #### and：表示多个条件同时满足


```css
@media screen and （max-width：1200px）{样式代码…}

```



- #### only:


only：指定某种特定的媒体类型，可以用来排除不支持媒体查询的

```css
<link href = "style.css"  media = " only screen and  (max-width：500px) "  
```

标志，只有在屏幕最大宽度是500px的屏幕下，会执行style.css样式



示例：

效果图：

![only_media](E:/备份/学习视频/09_移动端/09-02、流式布局&媒体查询/笔记/assetis/only_media.gif)

only.css:

```css
div{
    width: 100%;
    height: 300px;
    background-color: yellow;
}
```



```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="./css/only.css" media="only screen and (max-width:500px)">
    <script src=""></script>
</head>

<body>
    <div></div>

</body>

</html>
```



- #### not：


排除某种指定的媒体类型，即排除符合表达式的设

表示取反

```css
@media  not  print  and （max-width：1200px）{样式代码…}

```



**引入方式：**

@media方式：

```
@media 媒体类型 {
        选择器{ /*样式代码写在这里…*/}
}

```

link方法：

```
<link  rel="stylesheet"  href="style.css"  media="媒体类型" />

```

### 11.rem响应式布局

如果移动端页面只在移动端访问，那么使用rem可以实现响应式布局



- #### 实现原理：


动态改变 html的font-size值的大小，来完成rem实现响应式布局



- #### rem实现响应式原理：


rem 的值都是根据html的fontsize进行计算的

统一缩放元素大小，只要修改html的fontsize

```css
html  {   font-size: 100px;
		/* 将图片的大小变成 75*75 */
		/* font-size: 50px; */}
main {
		 width: 1.5rem; height: 1.5rem;background-color: #f38;
		 }
/*省略其他的CSS样式*/

```





- #### 使用rem开发响应式布局步骤1:

    - 从Ui设计师拿到设计稿，一般尺寸都是以iphone 6的尺寸为准 750**1334（638*1136）

    - 在样式中给html设定一个fontsize的值，我们一般设置一个方便后续计算的值，例如10px、100px等，我们使用100px

    - 写样式
        - 完全按照设计稿的尺寸来写样式，设计稿上的长度、height、margin、padding、字体的值是多少，我们就写多少，这样可以100%还原设计稿
        - 注意：需要把得到的像素值/100px,转换为rem单位




- #### 使用rem开发响应式布局步骤2:

    - 根据当前屏幕的宽度和设计稿的宽度来重新计算html的FontSize的大小

    - 根据当前屏幕宽度和设计稿的宽度的比例，动态计算当前宽度下的fontsize值大小，如果fontsize值改变了，之前设定的所有的rem单位的值自动会跟着改变


```javascript
<script>
    function setRem() {
        var ui_w = 375;
        // 获取屏幕的宽度
        var clientWidth = document.documentElement.clientWidth || document.body.clientWidth;
       

        // 通过js动态改变html根节点字体大小
        var html_ = document.getElementsByTagName('html')[0];
        html_.style.fontSize = (clientWidth/ui_w)*100 +'px';
    }
    // window.onresize 浏览器被重置大小执行事件
    window.onresize = setRem;


</script>
```



### 12.判断是pc还是移动浏览器

通过JavaScript判断终端类型

```javascript
//把请求头信息转为小写  
//user agent是指用户代理,使服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。
sUserAgent = navigator.userAgent.toLowerCase();

sUserAgent.match('ipad') == "ipad";
sUserAgent.match('ucweb') == "ucweb";
...
```





```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>判断是PC还是移动端浏览器</title>
</head>
<body>


</body>
</html>

<script>
    
function browserRedirect() {
var curURL = window.location.href;
var sUserAgent = navigator.userAgent.toLowerCase();

var bIsIpad = sUserAgent.match(/ipad/i) == "ipad";
var bIsIphoneOs = sUserAgent.match(/iphone os/i) == "iphone os";
var bIsMidp = sUserAgent.match(/midp/i) == "midp";
var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4";
var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb";
var bIsAndroid = sUserAgent.match(/android/i) == "android";
var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce";
var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile";



if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
    // 移动端浏览器 
    document.write("phone");
    //移动端浏览器
    window.location.href = "https://m.jd.com/";
    // if (curURL.indexOf("jd.com") != -1) {
    //     window.location.href = "https://m.jd.com/";
    // }
} else {
    // PC端浏览器
    document.write("pc");
    //  if (curURL.indexOf("jd.com") != -1) {
        // window.location.href = "https://www.jd.com/";
    //   }
    }
}

browserRedirect()


</script>
```

# webpack

### 1.用途

- ##### 网页中引入的静态资源多了以后有什么问题？？？

1. 一个前端项目里面可能有多个 .js, 多个 .css , 多个静态图片， 多个其他前端资源。
    当一个页面需要加载多个 .js 的话，也会拖累整个页面的加载速度，因为我们要发起很多的二次请求；
2. 要处理错综复杂的依赖关系，例如一些 js 资源彼此之间存在依赖关系。



- 
    ##### 如何解决上述两个问题


1. 合并、压缩、精灵图、图片的Base64编码

2. 使用webpack可以解决各个包之间的复杂依赖关系；

    如图所示，webpack 就把左边的各种各样的静态资源，打包成了一个所谓的 assets 这样浏览器加载起来就快多了。

    ![image-20201218224702345](E:\备份\学习视频\11_webpack\01_webpack\笔记\image\image-20201218224702345.png)

- #### 什么是webpack?

    - Webpack 是一个前端资源加载/打包工具（项目构建工具）。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

    - webpack 提供了友好的模块化支持，以及资源的合并、打包、压缩、混淆、处理 js 兼容问题、性能优化等强大的功能，从而让程序员把工作的重心放到具体的功能实现上，提高了开发效率和项目的可维护性。

    - [webpack官网](https://www.webpackjs.com/)


### 2.webpack安装的两种方式

​	https://webpack.docschina.org/guides/getting-started/

​	npm 包管理机制 包管理   类似于 360的软件管理 ；

​			1.	运行 `npm i webpack –g` 全局安装webpack 

​			2.	运行 `npm install webpack-cli -g`全局安装CLI

​			3.	运行 webpack –v 查询webpack与CLI版本

​			4.	在项目下运行 `npm install jquery` 安装jquery

​			5.	打包文件: webpack .\index.js -o ..\dist\bundle.js

​					-o:为打包到哪，后面是打包到的地址

​					此时位于WEBPACK_01下面的src目录下

​							<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021195148470.png" alt="image-20221021195148470" style="zoom:67%;" />

​					有时会报错

​							![image-20221021195301914](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021195301914.png)

​					解决办法：

​						1.使用管理员打开使用的工具（idea,vs code,HbuilderX）。

​						2.命令行执行：`get-ExecutionPolicy`，显示Restricted，表示状态是禁止的。

​						3.执行：`set-ExecutionPolicy     RemoteSigned`

​						4.再执行`get-ExecutionPolicy`，就显示RemoteSigned就可以使用webpack打包了。

​							每一次更改js内容都得重新打包

​							由于打包代码过长，为方便，将位置更改到WEBPACK_01下面进行打包

​							直接输入webpack打包

​							<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221021195847330.png" alt="image-20221021195847330" style="zoom:67%;" />

​							但是此种方法只能打包名字为index.js的文件，如果是其他名字会报错，

​							如果是其他名字，用下面的方式		

​						

​							●单入单出					

​								1.在项目<font color=red>根目录</font>中创建`webpack.config.js`

​								2.由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在`webpack.config.js`中配置这两个路径：

```js
    // 导入处理路径的模块
    var path = require('path');

    // 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理
    module.exports = {
        entry: path.resolve(__dirname, 'src/js/main.js'), // 项目入口文件 __dirname当前模块目录名
       
        output: { // 配置输出选项
            path: path.resolve(__dirname, 'dist'), // 配置输出的路径
            filename: 'bundle.js' // 配置输出的文件名
        },
       
    }
```

​									在目录下直接使用 webpack命令打包

​						

​							●多入多出

​								多入口webpack.config.js

​								inedx与print都是前缀名字，可以任意

​	注意，只能用./而不是../

```js
var path = require('path');
module.exports = {
   /*  
    生产模式还是开发模式 默认生产环境：自动压缩打包生成的代码 开发环境：不压缩打包生成代码
    生产模式： mode: 'production'
    开发模式： mode: 'development'
  */
  	mode:'development',//开发者模式
    entry: {
        index: './src/main.js',
        print: './src/main2.js',
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: "[name].index.js"
    }

}
```

### 3.打包项目

1. 创建一个文件夹，再分别创建两个子文件夹，dist与src

​		<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023200616433.png" alt="image-20221023200616433" style="zoom:67%;" />

2. 初始化npm ：`npm init -y`

​		<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023200625774.png" alt="image-20221023200625774" style="zoom:67%;" />

3. 安装jquery：`npm install jquery`

​		<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023201016186.png" alt="image-20221023201016186" style="zoom:67%;" />

4.本地安装webpack：`npm install webpack --save-dev`

​     ![img](file:///C:\Users\22776\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg)

​		<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023212527812.png" alt="image-20221023212527812" style="zoom:67%;" />

​		<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023212546668.png" alt="image-20221023212546668" style="zoom:67%;" />

5.在src目录下创建index.html,index.js，在根目录下创建webpack.config.js

​	webpack.config.js

​	注意，只能用./而不是../

```js
var path = require('path');
module.exports = {
   /*  
    生产模式还是开发模式 默认生产环境：自动压缩打包生成的代码 开发环境：不压缩打包生成代码
    生产模式： mode: 'production'
    开发模式： mode: 'development'
  */
  	mode:'development',//开发者模式
    entry:{
        1:'./src/index.js'
    },
    output:{
        path: path.resolve(__dirname,'dist'),
        filename:'index_[name].js'
    }
}

```

6.在命令行下webpack

​	![image-20221023212739899](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023212739899.png)

<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023230608994.png" alt="image-20221023230608994" style="zoom:67%;" />创建成功

然后在index.html引入该js文件

<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023230628186.png" alt="image-20221023230628186" style="zoom:67%;" /><img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023230635305.png" alt="image-20221023230635305" style="zoom:67%;" />

成功

7.实时显示更改代码，不用反复打包

​	 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用`webpack-dev-server`来实现代码实时打包编译，当修改代码之后，	会自动进行打包构建。

首先在webpack.config.js里面引用

​	![image-20221023212814487](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023212814487.png)

然后,

​		https://webpack.docschina.org/configuration/dev-server/#devserver

​		1.运行`npm install webpack-dev-server --save-dev`安装到开发依赖

​		2.安装完成之后，在命令行直接运行`webpack-dev-server`来进行打包，发现报错，

![image-20210507215413405](E:\备份\学习视频\11_webpack\02_webpack\笔记\image\image-20210507215413405.png)

​		3.此时需要借助于`package.json`文件中的指令，来进行运行`webpack-dev-server`命令，在`scripts`节点下新增`"dev": "webpack-dev-server"`指令，发			现报错

![image-20221023213207455](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213207455.png)

​							**报错：**

![image-20211114211245847](E:\备份\学习视频\11_webpack\02_webpack\笔记\image\image-20211114211245847.png)

​		4.输入`npm run dev`

​     ![img](file:///C:\Users\22776\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg)

​			过程中会询问是否安装cli工具，选择yes，也可以选择no，

​			然后在命令行运行：`npm install webpack-cli –save-dev`,安装cli工具，

​			然后再次执行`npm run dev`
​		 	点击该网址

​				![image-20221023213413529](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213413529.png)

​				跳转页面为:

​					![image-20221023213432578](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213432578.png)

​				之所以这样，是因为没有配置文件，需要配置一下

​					![image-20221023213451768](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213451768.png)

​					因为此时已经打包到npm中了，本地的dist下面的index_1已经无效可以删除了

​					此时的引入都不是本地引入了，而是npm云引入

​					所以index.html下面的引入路径需要更改，路径的名称以filename下面的命名为准

​							<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213521946.png" alt="image-20221023213521946" style="zoom:67%;" />

​						然后再：`npm run dev`

​						![image-20221023213539890](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213539890.png)

​						输出成功

 

​						验证是否实时更改

​								<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213607672.png" alt="image-20221023213607672" style="zoom:67%;" />

​								<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213637380.png" alt="image-20221023213637380" style="zoom:67%;" />

​							验证成功

 

​							额外操作

​								![image-20221023213704227](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213704227.png)

​							配置完成后需要重新：`npm run dev`

​									<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213725283.png" alt="image-20221023213725283" style="zoom:67%;" />

​									<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023213737515.png" alt="image-20221023213737515" style="zoom:67%;" />

### 4.插件打包html

- #### 打包到Js		

1.   终端运行：`npm i html-webpack-plugin --save-dev`

​			查看是否安装成功

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214320945.png" alt="image-20221023214320945" style="zoom:67%;" />

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214326365.png" alt="image-20221023214326365" style="zoom:67%;" />

​			更改index.html的title为：

​				<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214340793.png" alt="image-20221023214340793" style="zoom:67%;" />

​		2.   运行`npm run dev`打包无反应

​				是因为没有配置，在webpack.config.js下面配置

​				![image-20221023214408322](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214408322.png)

​	3.  运行webpack命令打包

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214430239.png" alt="image-20221023214430239" style="zoom:67%;" />

​			打包完成

​	4.  运行npm run dev 查看是否成功

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214459451.png" alt="image-20221023214459451" style="zoom:67%;" />

​			成功

### 5.插件打包css

![image-20221024232252096](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221024232252096.png)

- #### 打包到JS

    将css文件打包到js里面，到时候直接引入打包好的js文件，也就顺带引入css文件了

​		1.终端运行：`npm i -D css-loader style-loader`		

​		2.创建一个css文件，并写入内容

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214645182.png" alt="image-20221023214645182" style="zoom:67%;" />

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214650174.png" alt="image-20221023214650174" style="zoom:67%;" />

​		3.在index.js里面引入index.css

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214710525.png" alt="image-20221023214710525" style="zoom:67%;" />

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214716321.png" alt="image-20221023214716321" style="zoom:67%;" />

​		4.在webpack.config.js下面的module.export里面配置

​			

```js
module:{
        rules:[
            //指定多个配置规则
            {
            test:/\.css$/i,
            //use中loader的加载顺序：先下后上
            use:[
                //将JS中的样式，挂载到<style>标签中
                "style-loader",
                //按照CommonJS规范，将样式文件，输出到Js中
                "css-loader"
            ]
        }
    ]
    }
}
```

​		5. webpack命令打包，并`npm run dev`运行

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214811422.png" alt="image-20221023214811422" style="zoom:67%;" />

​			运行成功

#### 打包成独立的css文件

1.终端运行：`npm i -D mini-css-extract-plugin`

2.webpack.config.js里面配置

​	

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const { resolve } = require('path')
module.exports = {
    mode: 'development',
    entry: {
        index:'./js/index.js',
        signIn:'./js/signIn.js'
    },
    output: {
        path: resolve(__dirname, 'dist'),
        filename: 'main.js'
    },
    module: {
        rules: [
            // 指定多个配置规则
            {
                test: /\.css$/i,
                use: [
                    // 'style-loader',
                    //将css打包到style标签中
 
                    // 2. 将css打包到独立文件中
                    MiniCssExtractPlugin.loader,
 
                    //1. css-loader按照common.js贵伐，将样式文件输出的熬js中
                    'css-loader'
                ]
            }
        ]
    },
    plugins: [
        new MiniCssExtractPlugin({
            filename: 'css/[name].css'
            // 输出的css文件名不变的意思
        })
    ]
}

```

3.在要打包的js里面配置

```js
import './css/main.css';
//以模块的方式把css引入到index.js的入口文件中，不然找不到css文件，无法打包成独立文件
```

4.终端输入：`webpack`

5.最后在dist里面输出的文件名是js的文件名，而不是css的

- #### 压缩打包后的css文件

    1.安装插件，终端运行：`npm install optimize-css-assets-webpack-plugin -D`

    2.webpack.config.js里面配置

    ```js
    const MiniCssExtractPlugin = require('mini-css-extract-plugin')
    const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');    // 引入插件
    const { resolve } = require('path')
    module.exports = {
    		optimization: {          // 配置webpack的优化项
            minimizer: [         // 配置最小值优化项
                new OptimizeCSSAssetsPlugin()   // 声明css优化插件的实例
              	new TerserPlugin(),            // 压缩js包
            ]
        },
        mode: 'development',
        entry: './src/index.js',
        output: {
            path: resolve(__dirname, 'dist'),
            filename: 'main.js'
        },
        module: {
            rules: [
                // 指定多个配置规则
                {
                    test: /\.css$/i,
                    use: [
                        // 'style-loader',
                        //将css打包到style标签中
     
                        // 2. 将css打包到独立文件中
                        MiniCssExtractPlugin.loader,
     
                        //1. css-loader按照common.js贵伐，将样式文件输出的熬js中
                        'css-loader'
                    ]
                }
            ]
        },
        plugins: [
            new MiniCssExtractPlugin({
                filename: 'css/[name].css'
                // 输出的css文件名不变的意思
            })
        ]
    }
    
    ```

    

### 6.插件打包less

​		1.  运行命令：`npm install less less-loader --save-dev`

​		2.  创建less文件并自动生成css文件

​				<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214951256.png" alt="image-20221023214951256" style="zoom:67%;" />

​				<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023214958100.png" alt="image-20221023214958100" style="zoom:67%;" />

​		3.在index.js里面引入less文件

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023215012886.png" alt="image-20221023215012886" style="zoom:67%;" />

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023215020426.png" alt="image-20221023215020426" style="zoom:67%;" />

​		4.在webpack.config.js里面配置

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023215055365.png" alt="image-20221023215055365" style="zoom:67%;" />

​		5.   `npm run dev` 测试

​			<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221023215116994.png" alt="image-20221023215116994" style="zoom:67%;" />

​			成功

# VUE

## 介绍

Vue是前端框架

 框架：封装可以跨行的可复用代码

 框架的优势：提高开发效率

渐进式JavaScript框架

 可以将一部分vue应用到开发中，不用全部改成vue

优势

  体积小，运行效率高，因为是用虚拟dom技术

Mvc框架![image-20221026223931384](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221026223931384.png)<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221026223940569.png" alt="image-20221026223940569" style="zoom:67%;" /><img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221026223947104.png" alt="image-20221026223947104" style="zoom:67%;" /><img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221026224018349.png" alt="image-20221026224018349" style="zoom:67%;" />

## vue指令

### v-text:(设置元素的内容)

v-text相当于 元素的innerText();

设置元素的内容，同时会覆盖元素内的内容

```html
<body>
    <div id="box">
        <!-- 结果： 哈哈! -->
        <p v-text = 'msg+"!"'>哈哈</p>
    </div>
</body>
</html>

<script src="./vue.js"></script>
<script>

    var vm = new Vue({
        el:'#box',
        data:{
            message:'老陈',
            msg:'老李'
        }
    })

</script>
```

### v-html:(设置元素的内容)

```
v-text相当于 元素的innerText();

设置元素的内容，同时会覆盖元素内的内容
如果指令获取的数据里面有html标签，会自动解析为html样式
```

```html
<body>
    <div id="box">
        <!-- v-html 相当于元素.innerHtml -->
        <p v-html = 'message+"!"'>哈哈</p>
        <p v-text='message'></p>
    </div>
</body>
</html>

<script src="./vue.js"></script>
<script>

    var vm = new Vue({
        el:'#box',
        data:{
            message:'<h1>老陈</h1>',
            msg:'老李'
        }
    })

</script>
```



### v-show:(显/隐元素)



```tex
v-show='表达式'
可以根据表达式值的真假，来控制页面元素的显示(true）和隐藏(false)控制元素显示和隐藏
本质:就是css的display: block display:none
```

例：控制div的显示与隐藏

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>v-show</title>

    <style>
        .red{
            width: 200px;
            height: 200px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div id="box">
        <!-- 要显示的div -->
        <div class="red" v-show='isShow'></div>
    </div>

</body>

</html>

<script src="./vue.js"></script>

<script>
    const vm = new new Vue({
        el: '#box',
        data: {
            isShow: true
        }
    })
</script>
```



### v-iE:(显/删元素)

v-iE:根据表达值的真假,切换元素的显示和移除(操纵dom元素)

v-else-iE:如果if表达式不成立，则 判断当前表达式，成立显示元素，否则移除

v-else:如果if不成立，则显示v-else绑定的daom元素。无需表达式



注意：v-if v-else-if  和 v-else中间  不能有其他的内容 必须紧密的连接在一起

```html
<body>
    <ul id="list">
        <li v-if='num>85'>离离原上草</li>
        <li v-else-if = 'num>80'>一岁一枯荣</li>
        <li v-else-if = 'num>75'>野火烧不尽</li>
        <li v-else>春风吹又生</li>
    </ul>
</body>
</html>

<script src="./vue.js"></script>
<script>
    const vm = new new Vue({
        el:'#list',
        data:{
            num:80
        }
    })
</script>
```

> v-if和v-show的区别:
>
> v-if：纯粹的元素插入和删除
>
> v-show：纯粹的css的显示和隐藏

```
//v-if与v-show区别
//v-show指令的元素始终会被渲染到HTML
//它只是简单地为元素设置CSS的style属性。当不满足条件的元素被设置style="display:none"样式
//v-if指令满足条件是，会渲染到html中，不满足条件时，是不会渲染到html中的

v-if 指令有更高的切换消耗
v-if当条件成立的时候会将元素加上，不成立的时候，就会移除dom，并且内部的指令不会执行
v-show 指令有更高的初始渲染消耗
v-show只是简单的隐藏和显示
如果需要频繁切换使用 v‐show 较好，如果在运行时条件不大可能改变 使用v‐if 较好
```



### v-for：

`v-for` 指令可以绑定数组的数据来渲染一个项目列表：

`v-for`指令需要使用item in items形式的特殊语法，
其中 items是源数据数组，而item则是被迭代的数组元素的别名，即数组中每一项的内容。



```html
<body>
    <div id="box">
        <ol>
            <li v-for="clas in classes">
                {{ clas.text }}
            </li>
        </ol>
    </div>
</body>
<script src="./vue.js"></script>
<script>
    const vm = new Vue({
        el: '#app',
        data: {
            num: 80,
            classes:[
                {text:"郭德纲相声集"},
                {text:"易中天品三国"},
                {text:"陈福国相声"},
            ]
        }
    })
</script>
```





### v-on:

```
为 HTML 元素绑定事件监听
v-on：事件名称 =‘函数名称()’
表达式可以是一个方法的名字或一个内联语句
简写语法：@事件名称 =‘函数名称()’
注：函数定义在 methods 配置项中

<button v-on:click='fn()'>toggle</button>
//v-on: 可以简写成 @
<button @click='fn()'>toggle</button>
```



```html
<body>
    <div id="box">
        <input type="button" value="v-on普通点击" v-on:click='fn'>
        <input type="button" value="v-on简写" @click='fn'>
        <input type="button" value="v-on双击" @dblclick='fn'>

        <p @click='show'>{{msg}}</p>
    </div>
    
</body>
</html>

<script src="./vue.js"></script>
<script>
    var vm = new Vue({
        el:'#box',
        data:{
            msg:'老陈真帅'
        },
        methods:{
            fn:function(){
                alert('点击成功');
            },
            show:function(){
                // 改变值
                this.msg +='呵';
                console.log(this.msg);
                
            }
        }
    })
</script>
```

```html
v-on后面可以增加修饰符
事件修饰符：
.stop：调用event.stopPropagation() 阻止冒泡
.prevent : 调用event.preventDefault() 阻止默认事件
.self : 只当事件是从侦听器绑定的元素本身触发时才触发回调
.once:点击事件将只会触发一次

按键修饰符
.{keycode} : 只在指定键上触发回调

系统修饰键
.ctrl
.alt
.shift
.meta

.exact 修饰符 精确修饰符
举个栗子：
<input @click.ctrl="fn">  按下的按键中只要有ctrl即可，他可以有其他的按键
<input @click.ctrl.exact="fn">  有且只有按下ctrl键时，在点击，才能触发事件

鼠标按钮修饰符
.left
.right
.middle

#获取事件对象
<div class="out" @click="fn($event)">event</div>
```

#### .stop(阻止冒泡)

事件修饰符阻止冒泡：

```html
<head>
    <meta charset="UTF-8">
    <title>阻止冒泡</title>

    <style>
        div{
            border: 1px solid black;
            padding: 50px;
        }
    </style>
</head>
<body>
    <div id="box" v-on:click="fn('out')">
        <div class="inner" @click.stop='fn("inner")'>

        </div>
        
    </div> 
```

```js
<script>
    const vm = new Vue({
        el:'#box',
        methods: {
            fn(v){
                alert(v);
            }
        }
    })
</script>
```

#### .prevent(阻止默认)

事件修饰符阻止默认事件：

```html
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: red;
        }
    </style>
</head>
<body>
    <!-- .prevent  阻止默认事件 -->
    <div id="box" @contextMenu.prevent='onright("hahah")'></div>
</body>
```

```js
<script>
    const vm = new Vue({
        el:"#box",
        methods:{
            onright(v){
                alert(v);
            }
        }
    })
</script>
```



#### .self属性(点击自身触发)

 只要点击自身才会触发事件

以阻止冒泡为例

```html
    <style>
        div{
            border: 1px solid black;
            padding: 50px;
        }
    </style>
</head>
<body>
    <!-- 都添加.self -->
    <div id="box" v-on:click.self="fn('out')">
        <div class="inner" @click.self='fn("inner")'>
        </div>
    </div>
</body>
```

```js
<script>
    const vm = new Vue({
        el: '#box',
        methods: {
            fn(v) {
                alert(v);
            }
        }
    })
</script>
```



#### .once(触发一次)

点击事件将只会触发一次，底层中触发一次以后，立即解绑了该事件

比如给上面例子中的out添加一个.once 则只弹出一次 out

```
<div @click.self.once='cli("out")'>
```



#### 按键修饰符

在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：

```css
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">

为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：

.enter
.tab
.delete (捕获“删除”和“退格”键)
.esc
.space
.up
.down
.left
.right

举个栗子：
<input @click.ctrl="fn">  按下的按键中只要有ctrl即可，他可以有其他的按键
<input @click.ctrl.exact="fn">  有且只有按下ctrl键时，在点击，才能触发事件

```

```html
<body>
    <input id="ipt" type="text" v-on:keyup.enter="sub()">
</body>
```

```js
 const vm = new Vue({
        el:'#ipt',
        methods:{
            sub(){
                alert('提交');
            }
        }
    })
```



#### 鼠标按钮修饰符

.left
.right
.middle



```html
    <style>
        #box{
            width: 100%;
            height: 200px;
            background-color: rgb(219, 148, 148);
        }
    </style>
</head>
<body>
    <div id="box"
     @click='click_event("普通点击")'
     @click.left = 'click_event("左键点击")'
     @click.right.prevent = 'click_event("右键点击")'
     @click.middle= 'click_event("滚轮点击")'
     
     ></div>
</body>
```

```js
  const vm = new Vue({
        el:'#box',
        methods: {
            click_event(v){
                alert(v);
            }
        }
    })
```



#### 获取事件对象

$event作为参数传递，可获取当前对象

```html
<div class="out" @click="fn($event)">event</div>
```

```html
<body>
    <div id="box" v-on:click="fn($event)">div id 为box</div>
</body>
```

```js
const vm = new Vue({
        el: '#box',
        methods: {
            fn(e) {
                console.log(e);
            }
        }
    })
```



### v-bind(动态绑定指令)

v-bind传递的值是引号里面的数据

```html
v-bind可以在其名称后面带一个参数，参数通常是HTML元素的属性（attribute），v-bind是动态绑定指令，默认情况下自带属性的值是固定的，为了能够动态的给这些属性添加值可以使用v-bind指令
v-bind:属性名 = ‘表达式’
简写形式：v-bind可以省略，直接书写为 :属性名 = ‘表达式’
<img v-bind:src="imageSrc"> 等价于  <img :src="imageSrc">   //绑定一个属性
//绑定多个属性
<div v-bind:class="{'textColor':isColor, 'textSize':isSize}">多个样式的绑定</div>
```





#### 绑定属性：

```html
<div id="box">
      <a v-bind:href="rurl">百度</a>
      <a :href="rurl">百度</a>
    </div>
```

```
 const vm = new Vue({
        el:'#box',
        data:{
            rurl:'http://www.baidu.com'
        }
    })
```



#### v-bind:绑定class

```html
<div :class="{类名:属性}">v-bind: class</div> 
根据属性值的情况来定，是否要添加类名
```

```html
    <style>
        .active {
            width: 200px;
            height: 200px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div id="box" :class="{active:bool}"></div>
</body>

```

```js
<script>
    const vm = new Vue({
        el: '#box',
        data: {
            bool: false// 布尔类型结果 决定了是否要添加类名
        },
        methods: {

        }
    })
```



可以同时绑定多个类名，也可以和静态类名同时存在

```html
<div id="box" class="aa"  :class="{active:bool,two:bool}"></div>
```

```html
const vm = new Vue({
        el: '#box',
        data: {
            bool: true
        },
        methods: {

        }
    })
```



 ![image-20210513014747933](E:\备份\学习视频\12_Vue\02 vue指令\笔记\image\image-20210513014747933.png)



数组形式绑定类名：

```html
<div id="box" :className=[name1,name2]>数组绑定类名</div>
```

```js
 const vm = new Vue({
        el:'#box',
        data:{
            name1:'aaa',
            name2:'bbb'
        },
        methods:{

        }
    })
```

 ![image-20210513015147728](E:\备份\学习视频\12_Vue\02 vue指令\笔记\image\image-20210513015147728.png)







```js
//对象语法
我们可以传给 v-bind:class 一个对象，以动态地切换 class：
<div v-bind:class="{ active: isActive }"></div>

<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>

//数组语法
我们可以把一个数组传给 v-bind:class，以应用一个 class 列表：
<div v-bind:class="[activeClass, errorClass]"></div>
 data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}

<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```







#### v-bind:绑定内联样式

对象语法

```html
 <div id="box" :style="{color:xxcolor,fontSize:xxpx+'px'}">
        对象方式设置css样式
    </div>
```

```js
const vm = new Vue({
        el:'#box',
        data:{
            xxcolor:'red',
            xxpx:50
        },
        methods:{

        }
    })
```



```js
#对象语法
//v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：
 <div id="box" :style="{color:xxcolor,fontSize:xxpx+'px'}">
        对象方式设置css样式
    </div>

data: {
  xxcolor: 'red',
  xxpx: 30
}


//直接绑定到一个样式对象通常更好，这会让模板更清晰：
<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}

#数组语法
//v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：
<div v-bind:style="[styleObject，baseStyles, overridingStyles]"></div>
```



### v-model(与表单双向绑定)



```
你可以用 v-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。
```

> `v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值。

大白话： v-model会自动的将表达式的值，插入到表单对应的内容



```html
 <div id="box">
        <input type="text" value="默认数据" v-model="msg">
        <p>{{msg}}</p>
    </div>
```

```js
 const vm = new Vue({
        el:'#box',
        data:{
            msg:'v-model数据'
        },
        methods:{

        }
    })
```

![image-20210513021605831](E:\备份\学习视频\12_Vue\02 vue指令\笔记\image\image-20210513021605831.png)



#### 单个复选框

单个复选框，绑定到布尔值：

v-model  拿到的是checked选中的值，true或者false

```html
 <div id="box">
        <input type="checkbox" v-model="checked">英雄
        <p>{{checked}}</p>
    </div>
```

```js
 const vm = new Vue({
        el:'#box',
        data:{
            checked:''
        },
        methods:{

        }
    })
```

 ![image-20210513022607506](E:\备份\学习视频\12_Vue\02 vue指令\笔记\image\image-20210513022607506.png)



#### 多个复选框

用v-model 接收到的值，在data中用数组接收，接收到的是值

```html
 <div id="box">
        <input type="checkbox" v-model="checkedNames" value="hreo">英雄
        <input type="checkbox" v-model="checkedNames" value="History">历史
        <input type="checkbox" v-model="checkedNames" value="music">音乐
        <input type="checkbox" v-model="checkedNames" value="movie">电影
        <p>{{checkedNames}}</p>
    </div>
```

```js
 const vm = new Vue({
        el:'#box',
        data:{
            checkedNames:[]
            // 如果想选择默认 直接在数组中写上默认的value值
            // checkedNames:['movie']

        },
        methods:{

        }
    })
```

 ![image-20210513023414123](E:\备份\学习视频\12_Vue\02 vue指令\笔记\image\image-20210513023414123.png)

#### 单选按钮：

```html
 <div id="box">
        <input type="radio" name="sex" value="woman" v-model="msg">女
        <input type="radio" name="sex" value="man" v-model="msg">男
        <p>{{msg}}</p>
    </div>
```

```js
 const vm = new Vue({
        el:'#box',
        data:{
            msg:""
        },
        methods:{

        }
    })
```

 ![image-20210513024109413](E:\备份\学习视频\12_Vue\02 vue指令\笔记\image\image-20210513024109413.png)



#### select下拉选择框

v-model 拿到的是选中选项的值

```html
<div id="box">
        <select v-model="selected">
            <option>请选择</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
          </select>
          <br>
          <span>Selected: {{ selected }}</span>
     
    </div>
```

```js
  const vm = new Vue({
        el:'#box',
        data:{
            selected:''
        },
        methods:{

        }
    })
```

## axios 

### 特点

- 可以在浏览器端发送axios请求

- 可以在node.js里发送HTTP请求

- 可以在请求前做一些准备工作，在响应回来之后做一些处理

- 对请求和显示数据做转换

- 取消请求

- 自动将结果转为Json数据

- 阻挡一些跨域攻击

    注意：axios返回的是一个promise对象，需要用then方法去指定成功的回调，在里面获取结果

### 安装

CDN方式

https://unpkg.com/axios/dist/axios.min.js
NPM
npm install axios

### Json-server(模拟后台)

​	单独用axios会产生跨域问题，用该方法可以解决

1.安装，命令行运行：`npm install -g json-server`

2.创建json文件，里面添写数据

data.json（只有一个对象）

```json
{
    "data":[{
            "num": 1,
            "name": "Za姬芮新能真皙美白隔离霜 35g",
            "imgUrl": "image/icon-1.jpg",
            "desc":"￥59.90 最近13403人购买"
        }, {
            "num": 2,
            "name": "美宝莲精纯矿物奇妙新颜乳霜BB霜 30ml",
            "imgUrl": "image/icon-2.jpg",
            "desc":"￥89.00 最近13610人购买"
        }, {
            "num": 3,
            "name": "菲奥娜水漾CC霜40g",
            "imgUrl": "image/icon-3.jpg",
            "desc":"￥59.90 最近13403人购买"
        }, {
            "num": 4,
            "name": "HC 蝶翠诗橄榄卸妆油 200ml",
            "imgUrl": "image/icon-4.jpg",
            "desc":"￥169.00 最近16757人购买"
        }]}
```

db.json（有多个对象）

```json
{
  "posts": [
    {
      "id": 1,
      "title": "json-server",
      "author": "typicode"
    }
  ],
  "comments": [
    {
      "id": 1,
      "body": "some comment",
      "postId": 1
    }
  ],
  "profile": {
    "name": "typicode"
  }
}
```



3.启动服务，

- 在需要配置的json文件目录下运行

    `json-server --watch data.json`

    或者

    `json-server --watch db.json`

- 运行结果分别为（有几个对象就有几个端口，每个端口运行每个对象里面的内容）

    ![image-20221014181855931](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221014181855931.png)

    ------

    ![image-20221014181920069](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221014181920069.png)

    如果端口被占用

    ​	如图：![image-20221014182054330](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221014182054330.png)

    - 输入 `netstat -ano`获取所有端口的PID

        ![image-20221014182221891](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221014182221891.png)

    - 输入`taskkill /pid 21072 /f`终止进程

        ![image-20221014182318746](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221014182318746.png)

4.若需要获取txt文本数据，需要将txt转为josn

文本素材.txt

```txt
rick,male,21
demen,male,26
Jack,male,26
John,female,20
Lucy,female,16
```

txt转json.js

```js
let fs = require('fs')
let path = require('path')
const sty = path.join
fs.readFile(sty(__dirname,'文本素材.txt'),'utf8',function(err,data){
  if(err){
    console.log(err);
    return
  }else{
    // console.log(data.split('\n'));
    let num = 0
    let sum = 0
    let arr = []
    
    data.split('\n').forEach(item=>{
      //拆分成数组,遍历数组
      let obj = {}
      // 循环一次增加一次数据
      obj.name = item.split(',')[0]
      obj.Gender = item.split(',')[1]
      //最后一个数据才加1*
      obj.Age = 1*item.split(',')[2]
      arr.push(obj)
      // 再把obj数据增加到数组里
      sum+=obj.age
      //求三个数的和,方便求平均值
      num++
      // 每循环一次增加一
    })
    // console.log(arr);
    let out = {
      list: arr, //数据
    //   average:sum/num,//平均值   总数除以次数
    //   total:num    //次数
    }
    console.log(out);
    // JSON.stringify(out) 
    fs.writeFile(sty(__dirname,'文本素材.json'),JSON.stringify(out),function(err){
      console.log(err);
    })
  }
  
})

```

在该目录下命令行运行：`node txt转json.js`

生成json文件

文本素材.json

```json
{"list":[{"name":"rick","Gender":"male","Age":21},{"name":"demen","Gender":"male","Age":26},{"name":"Jack","Gender":"male","Age":26},{"name":"John","Gender":"female","Age":20},{"name":"Lucy","Gender":"female","Age":16}]}
```

### 获取后台数据

把axios放到事件里

常规写法

```js
<script src='./../js/axios.min.js'></script>
#基本用法
//可以通过向 axios 传递相关配置来创建请求
//axios(config)    基于promise的api ，所以在then方法中接收数据
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
}).then(res=>console.log(res));

```

get请求

```js
#get请求
// 为给定 ID 的 user 创建请求
 send_by_axiosGet2(){
     axios.get('http://127.0.0.1:4000?name=三体').then(res=>{
        console.log(res);
 })
   //请求失败返回内容
  .catch(erro=>{
     console.log(erro);
     })
  }

// 上面的请求也可以这样做
 axios.get('http://127.0.0.1:4000',{
   params:{
     name:'三体'
   }
}).then(res=>{
    console.log(res);
   })
```

post请求

```js
axios.defaults.headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        } 
methods:{
    axios({
        method: 'post',
        url: 'http://127.0.0.1:4000',
        data: {
            name:'三体'
         }
     }).then(res => {
        console.log(res);
   });
}
```

执行多个并发请求

```js
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // 两个请求现在都执行完成
  }));
```

### 响应结构

某个请求的响应包含以下信息

```js
{
  // `data` 由服务器提供的响应
  data: {},
 
  // `status` 来自服务器响应的 HTTP 状态码
  status: 200,

  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: 'OK',

  // `headers` 服务器响应的头
  headers: {},

   // `config` 是为请求提供的配置信息
  config: {},
 // 'request'
  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance the browser
  request: {}
}
```

### 拦截器

在请求或响应被 `then` 或 `catch` 处理前拦截它们。

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    //此处拦截器内部一定要有return的内容 不然的话拦截将终止在这里 无法往下运行
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

 // 添加响应拦截器
        axios.interceptors.response.use(function (response) {
            // 对响应数据做点什么
            console.log('响应被拦截');
            console.log(response);
            // 过滤拦截信息  
            return response.data;
        }, function (error) {
            // 对响应错误做点什么
            return Promise.reject(error);
        });
```

示例：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="../lib/vue.js"></script>
    <script src="../lib/axios.min.js"></script>
    <script src="../lib/qs.min.js"></script>
</head>

<body>
    <div id="app">
        <button @click='axiosGet'>axiosGet请求方式</button>
        <button @click='axiosPost'>axiosPost请求方式</button>
        <button @click='axiosAll'>执行多个并发请求</button>
    </div>

    <script>
        axios.defaults.headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        // 添加请求拦截器
        axios.interceptors.request.use(function (config) {
            // 在发送请求之前做些什么
            //此处拦截器内部一定要有return的内容 不然的话拦截将终止在这里 无法往下运行
            console.log(config);

            //更改请求方式 此处先不管能否成功 只查看请求方式是否更改成功
            config.method = 'post';
            return config;
        }, function (error) {
            // 对请求错误做些什么
            return Promise.reject(error);
        });
        //创建Vue实例,得到 ViewModel
        var vm = new Vue({
            el: '#app',
            data: {},
            methods: {
                // axiosGet() {
                //     axios({
                //         methods: 'get',
                //         url: "http://127.0.0.1:4000",
                //         params: {
                //             name: '三体'
                //         }
                //     }).then(res => {
                //         console.log(res);
                //     })
                // },
                axiosGet() {
                    return axios({
                        methods: 'get',
                        url: "http://127.0.0.1:4000",
                        params: {
                            name: '三体'
                        }
                    })
                },
                axiosPost() {
                    return axios.post('user', Qs.stringify(
                        {
                            act: 'reg',
                            user: 'laochen',
                            pass: '123456',
                        }

                    ),
                        {
                            baseURL: 'http://127.0.0.1:3001/'
                        }


                    )
                },

                //执行多个并发请求
                axiosAll() {
                    axios.all([this.axiosGet(), this.axiosPost()])
                        .then(axios.spread(function (gt, pos) {
                            console.log(gt, pos);
                        }))
                }
            }
        });
    </script>
</body>

</html>
```

如果你想在稍后移除拦截器，可以这样： 

```js
const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

可以为自定义 axios 实例添加拦截器

```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```

### 生命周期

- ##### 什么是实列的生命周期

    - 所谓“生命周期”，指的是实例对象从构造函数开始执行（被创建）到被GC（Garbage Collection:垃圾回收机制）回收销毁的整个存在的时期

- 什么是生命周期钩子

    - 在生命周期自动调用的函数叫做生命周期函数，也被形象的称其为钩子函数
    - 已经被创建好，同时在合适的时机，会自动触发的函数

- 生命周期狗子的用途

    - 在对象从创建到回收的整个过程中会在不同的时期有不同的钩子函数，我们可以利用不同时期的钩子函数去完成不同的动作

    ```js
    #生命周期：和人一样，从出生到注定死亡，要经历多个时期，实列也是类似的周期
    
    胚胎  出生    干活  干活后    临终    死亡
    对应八个钩子函数 
    创造前(beforeCreate)创造后(created),挂载前(beforeMount),挂载后(mounted),
    改变前(beforeUpdate),改变后(updated),销毁前(beforeDestroy),销毁后(destroyed)
            
    
    ```

| 生命周期函数                   | 含义                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| beforeCreate（创建前）         | 组件实列刚刚被创建，只有一些生命周期函数和默认事件，data和methods中的数据还没初始化，【加一些loading事件】 |
| created（创建后）              | 组件实例刚被创建完，属性已经绑定，当时DOM还未生成，$el属性还不存在【结束loading事件，做一些初始化，函数自执行等】 |
| beforeMount（挂载前）          | 模板编译，挂载之前                                           |
| mounted（挂载后）              | 模板编译，挂载之后【发起后端请求，取回数据接受页面之间传递的参数子组件向父组件传递参数】 |
| beforeUpdate（beforeUpdate）   | 组件更行之前                                                 |
| updated（updated）             | 组件更新之后                                                 |
| beforeDestroy（beforeDestroy） | 组件销毁前调用                                               |
| destroyed（destroyed）         | 组件销毁后调用                                               |

```js
var vm = new Vue({
    el: '#app',
    data: {
      message: 'Vue的生命周期'
    },
    /*// 生命周期的写法需要注意，适合data在一个级别的
    beforeCreate: function() {
      console.group('------beforeCreate创建前状态------');
      console.log("el: " + this.$el); //undefined
      console.log("data: " + this.$data); //undefined 
      console.log("message: " + this.message) //undefined 
      // 在这个时期 ,说明 el 和 data 并未初始化
      // 这个时候做的操作,例如:加一些loading事件
    },
    created: function() {
      console.group('------created创建完毕状态------');
      console.log("el: " + this.$el); //undefined
      console.log("data: " + this.$data); //已被初始化 
      console.log("message: " + this.message); //Vue的生命周期,说明已被初始化
      //  这个时期,data 数据已经初始化，但是 el没有
      //  这个时候可以做的操作例如:结束loading事件，还做一些初始化，实现函数自执行等

    },*/
    beforeMount: function() {
      console.group('------beforeMount挂载前状态------');
      console.log("el: " + (this.$el)); //已被初始化
      console.log(this.$el);
      console.log("data: " + this.$data); //已被初始化  
      console.log("message: " + this.message); //已被初始化  
      // 到这个时期,data 和 el 都已经 初始化
    },
    mounted: function() {
      console.group('------mounted 挂载后状态------');
      console.log("el: " + this.$el); //已被初始化
      console.log(this.$el);    
      console.log("data: " + this.$data); //已被初始化
      console.log("message: " + this.message); //已被初始化 
      // 完成挂载，这个生命周期用的是比较多的
      // 最常见的就是:1、发起后端请求，拿回数据 2、接收页面之间的传递的参数 3、子组件向父组件传递参数
      
    },
    beforeUpdate: function () {
      console.group('------beforeUpdate 更新前状态------');
      console.log("el: " + this.$el);
      console.log(this.$el);   
      console.log("data   : " + this.$data); 
      console.log("message: " + this.message); 
    },
    updated: function () {
      console.group('------updated 更新后状态------');
      console.log("el: " + this.$el);
      console.log(this.$el); 
      console.log("data: " + this.$data); 
      console.log("message: " + this.message); 
      // 当vue发现data中的数据发生了改变，会触发对应组件的重新渲染，先后调用beforeUpdate和updated钩子函数。我们在console中输入 vm.message = '触发组件更新'
      // 这里就比较好理解了：当希望更新组件前做一些操作的时候，我们就可以调用 beforeUpdate钩子函数，同理使用 updated 钩子函数
    },
    beforeDestroy: function () {
      console.group('------beforeDestroy 销毁前状态------');
      console.log("el: " + this.$el);
      console.log(this.$el);    
      console.log("data: " + this.$data); 
      console.log("message: " + this.message); 
      // beforeDestroy钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。
    },
    destroyed: function () {
      console.group('------destroyed 销毁后状态------');
      console.log("el: " + this.$el);
      console.log(this.$el);  
      console.log("data: " + this.$data); 
      console.log("message: " + this.message);
       // destroyed钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
    }/**/
  })
```

###   过滤器:filters

Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化，比如字母的大写、货币的千位使用逗号分隔。过滤器可以用在两个地方：**双花括号插值和 `v-bind` 表达式** (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示。

```js
//<!-- 在双花括号中    message：data中定义的属性       | 管道符    capitalize:过滤器        -->
{{ message | capitalize }}

//<!-- 在 `v-bind` 中         |管道符   formatId：过滤器 -->
<div v-bind:id="rawId | formatId"></div>
```

- #### 过滤器换算金额：


```html
<body>
    <div id ="app"> 
        一碗烩面{{price|format_price('￥ ')}}
    
    </div>

    <script>
     //创建Vue实例,得到 ViewModel
     var vm = new Vue({
        el: '#app',
        data: {
            price:2000,
            money:100
        },
        filters: {
            //v 是管道符最前面的第一个参数
            //v2是调用过滤器传递的实参
            format_price(v,v2){
                return `${v2}${v/100}`;
            }
        }
     });
    </script>
</body>
```



- ### 用法：


你可以在一个组件的选项中定义本地的过滤器：

```js
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

或者在创建 Vue 实例之前全局定义过滤器：

```js
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

过滤的规则是自定义的，通过给Vue示例添加选项filters来设置
过滤器是 JavaScript 函数，因此可以接收参数,过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，`capitalize` 过滤器函数将会收到 `message` 的值作为第一个参数。



全局定义过滤器：

```html
<body>
    <div id ="app"> 
        一碗烩面{{price|format_price('￥ ')}}
    
    </div>

    <script>
        
    //全局过滤器
    Vue.filter('format_price',function(v,v2){
        return `${v2}${v/100}`;
    })
     //创建Vue实例,得到 ViewModel
     var vm = new Vue({
        el: '#app',
        data: {
            price:2000,
            money:100
        },
        // filters: {
        //     //v 是管道符最前面的第一个参数
        //     //v2是调用过滤器传递的实参
        //     format_price(v,v2){
        //         return `${v2}${v/100}`;
        //     }
        // }
     });
    </script>
</body>
```



- ### 过滤器可以串联


```js
{{ message | filterA | filterB }}
//filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。
```

```html
<body>
    <div id ="app"> 
        <!-- type的第一个参数  是前面整个过滤器的结果 -->
        一碗烩面{{price|format_price('￥ ')|type('分')}}
    
    </div>

    <script>
     //创建Vue实例,得到 ViewModel
     var vm = new Vue({
        el: '#app',
        data: {
            price:2000,
            money:100
        },
        filters: {
            //v 是管道符最前面的第一个参数
            //v2是调用过滤器传递的实参
            format_price(v,v2){
                return `${v2}${v/100}`;
            },
            type(v,v3){
                return`${v}${v3}`;//$20分
            }
        }
     });
    </script>
</body>
```

## 组件

### 什么是组件

组件（Component）的概念：组件是可复用的vue实例，在开发中，我们可以把重复的代码封装成组件，达到便捷高效开发的目的。组件即自定义控件
组件的用途：组件能够封装可重用代码，扩展HTML标签功能
组件的本质：自定义标签    <组件名></组件名>  <h1></h1>   

### 全局组件

**语法：**

> 采用Vue.component(名称，描述当前组件的配置项)方法来创建全局组件



**定义位置：**

创建实例前定义全局组件

```js
Vue.component('name', {
  template: '<div>我是一个小小小组件</div>' // html代码  
  // template:组件的根组件 相当于实例的挂载点
});
```



**组件的调用方法：**

```
组件本质为标签，调用方式与调用标签相同
<组件名></组件名>
```

**组件的命名：**

- 如果是一个单词命名，便可直接引用
- 如果是驼峰命名，引用时，需要在驼峰之间加 -  ，且不区分大小写
- 如果是首字母大写的单词，则直接引用

```html
<body>
    <div id="app">
      <first></first>  
      <first-one></first-one><!--必须加 -  ，且不区分大小写-->
    </div>
    <first-one></first-one>  <!--全局组件，必须在vue实例里面才可以使用，
                              在哪一个具体vue实例里面无所谓，但是必须在vue里面
                              不在vue里面不生效 -->
    <div id="app2">
        <first-one></first-one><!--这个生效，因为在vue挂载的里面-->
    </div>
</body>
</html>
<script>
    //全局组件
    Vue.component('first',{
        template:'<li>老六出山</li>'
    })
    Vue.component('firstOne',{
        template:'<li>寸草不生</li>'
    })
    const vm = new Vue({
        el:'#app',
        data:{  
        },
        methods:{
        
        },
    });
    const vm2 = new Vue({
        el:'#app2',
        data:{  
        },
        methods:{
        
        },
    });
</script>
```

**组件是可复用的vue实例对象**

因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等

每个组件相当于完整的vue实例，拥有绝大多数vm实例的配置项。
仅有的例外是 
1、像 el 这样根实例特有的选项。 在组件中根实例选项是 template  
2、在vm实例中data是对象，在组件中必须是函数，并且数据是以函数返回值的形式来定义的

### 外部模板

因为在Vue.component里面写内容过于麻烦，所以在html里面写入，再包裹在template里面，绑定一个div，然后再在Vue.component里面挂载

```html
    <style>
        *{
            margin: 0;
            padding: 0;
            list-style: none;
        }
        #li_one{
            color: aquamarine;
        }
    </style>
</head>
<body>
    <div id="app">
        <first></first><!--调用组件-->
    </div>
    <!-- 无论是全局组件，还是局部组件，都写在vue外部，防止调用两次 -->
    <template id="tmp1"><!--绑定一个id，方便组件挂载-->
        <div><!--template:必须有一个根节点，否则报错-->
            <li id="li_one">春风得意马蹄疾</li><!--可以直接写style样式-->
            <li>一日看尽长安花</li>
        </div>
    </template>
</body>
</html>
<script>
    Vue.component('first',{//创建组件标签名
        template:'#tmp1'//挂载组件
    })
    const vm = new Vue({
        el:'#app',
        data:{    
        },
        methods:{
        
        },
    });
</script>
```

**组件传递数据-data**

#data必须是一个函数
为了保证组件的独立性 和 可复用性，

data 是一个函数，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址

你实例化几次，就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。

一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。

```html
<body>
    <div id="app">
       <!-- 调用组件 -->
        <one></one>
    </div>
      <!-- 创建外部模板 -->
    <template id="tmp1">
        <div>
            <input type="text" v-model="msg">
            <br>
            {{msg}}
            <br>
            <button @click="fn()">点击</button>
        </div>
    </template>
</body>
</html>
<script>
    // 创建全局组件
    Vue.component('one',{
      //引用外部模板  
      template:'#tmp1',
       //    data数据必须是一个函数  
      data:function(){
            return {
                msg:'芜湖'
            }
        },
      <!--组件中其他属性的声明和vue一样--!>
        methods:{
            fn(){
               alert('点中了') 
            }
        }
    })
  //创建Vue实例,得到 ViewModel
    const vm = new Vue({
        el:'#app',
        data:{
            
        },
        methods:{
        
        },
    });
</script>
```

通过函数取值，每次返回时不同的对象，得到的是不同的内存空间里面的方法，所以每次调组件，互相之间的数据不会影响

```js
function fn(){
    return {
        name:"lisi",
        age:20
    }
}
let fn1 = fn();
let fn2 = fn();
fn1.name = 'zhangsan';
console.log(fn1); // {name:"zhangsan",age:20}
console.log(fn2);//{name:"lisi",age:20}
```

### 局部组件

语法：

```js
#在Vue实例中，使用components选项可以局部的注册组件,而且所有的局部组件都需要放到这里定义
new Vue({
    el: '#box',
    data: {},
    // 2、局部组件的定义
    components: {
        // 组件名称：{配置项}
        'test': {
            // template: '<h1>标签</h1>'
            template: '#t',
            data: function () {
                return {
                    msg: 'hello',
                    a: 100
                }
            }
        }	
    }
});
#组件的调用方法：
//<组件名></组件名>
#组件的作用域：
//定义该组件的作用域内可调用
#组件注册方式不一样，其它与全局注册类似
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="../lib/vue.js"></script>
</head>

<body>
    <div id="app">
        <!-- 调用内部组件 -->
        <one></one>
    </div>

    <!-- 创建外部模板 -->
    <template id="one">
        <div>
            <p v-for="(item,index) in list">姓名：{{item.name}} 年龄：{{item.age}}</p>
        </div>
    </template>

    <script>
        //创建Vue实例,得到 ViewModel
        var vm = new Vue({
            el: '#app',
            data: {},
            // 局部组件，定义在vue实例内部
            components: {
                // 组件名称：{配置项}
                one: {
                    template: '#one',
                    data() {
                        return {
                            list: [
                                { name: '张三', age: '20' },
                                { name: '李四', age: '40' },
                                { name: '老陈', age: '18' },
                            ]
                        }
                    }
                }
            }

        });
    </script>
</body>

</html>
```

### 父子组件的定义



通常一个应用会以一棵嵌套的组件树的形式来组织：

![image-20201229061419819](E:\备份\学习视频\12_Vue\06 组件基础\笔记\image\image-20201229061419819.png)

例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。

1、当前组件内部仍然存在 components选项，当前组件的子组件就写到components选项中
2、子组件可以认为是当前组件的一个细化过程，当前组件划分力度比较大，不容易维护开发，所以需要划分为更加细化的组件，所以就产生子组件详见图片展示情况，例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。这就是一个细化组件的过程，也就是父子组件的划分；、

> 子组件的调用，在父组件的模板中调用

语法：

```js
new Vue({
    el:"#box",
    data:{},
    //定义父组件
    components:{
        'parent':{
         	template:"#父组件的模版"，
            data(){
                return {
                msg:'wo shi fu zu jian '
            },
    		//定义子组件
   	 		components:{
                'children':{
                    template:'#子组件的模版',
                    data(){
                        return {
                            info:"wo shi zi  zu jian"
                        }
                    }
                }
            }
        }
	}
    }
});
```

示例：

```html
<body>
    <div id="app">
        <father></father>
    </div>

    <!-- 定义组件模板 -->
    <template id="baba">
        <div>
            <h2>{{msg}}</h2>
            <!-- 在父组件模板中调用子组件 -->
            <child></child>
        </div>

    </template>

    <!-- 子组件模板 -->
    <template id="erzi">
        <h3>{{msg}}</h3>
    </template>

    <script>
        //创建Vue实例,得到 ViewModel
        var vm = new Vue({
            el: '#app',
            // 定义局部组件，父组件
            components: {
                father: {
                    template: '#baba',
                    data() {
                        return {
                            msg: '我是爸爸组件'
                        }
                    },
                    // 在父组件内部定义子组件
                    components: {
                        child: {
                            template: '#erzi',
                            data() {
                                return {
                                    msg: '我是儿子组件'
                                }
                            }
                        }
                    }

                }
            }

        });
    </script>
</body>
```

 ![image-20210519012355137](E:\备份\学习视频\12_Vue\06 组件基础\笔记\image\image-20210519012355137.png)



**父子组件的作用域**

- 组件相当于完整的vue实例
- 组件与vue实例间作用域独立
- 父子组件间作用域相互独立
    - 子组件调用只能在父组件的模板中进行调用

## 组件高级

### 父组件传值给子组件

子组件有时候需要接收来自父组件的数据，这时候就需要给子组件绑定props的值，

props表示期待的获取的数据

1.在父组件里面创建需要传递的值

```js
father:{
                template:'#f',
                data(){
                    return {
                        msg:'我是父组件',
                        // 1.创建需要传递的值
                        info:'我是父组件传递给子组件的值'
                    }
                },
```

2.在父组件模板里面调用子组件，并绑定一个名称，动态传递父组件的值

```html
 <template id="f">
        <div>
            {{msg}}
            <!-- 2.让父组件模板里面调用的子组件动态绑定需要传递的值，绑定的名称自定义 -->
            <son :tt='info'></son>
        </div>
    </template>
```

3.在子组件里面用props接受父组件传递过来的值

```js
components:{
                   son:{
                    template:"#s",
                    data(){
                        return {
                            msg:'我是子组件'
                        }
                    },
                    // 3.在子组件里面接受父组件传递的名称
                    props:['tt']
                   }
                }
```

4.在子组件模板里面调用该值

```html
<!-- 子组件模板 -->
    <template id="s">
        <div>
            {{msg}}
            <br>
            <!-- 4.在子组件里面调用父组件里面传递过来的值 -->
            {{tt}}
        </div>
    </template>
```

示例

```html
 <!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>韩</title>
    <link rel="stylesheet" href="">
    <script src="../lib/vue.js"></script>
    <style>
        *{
            margin: 0;
            padding: 0;
            list-style: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <father></father>
    </div>
    <!-- 父组件模板 -->
    <template id="f">
        <div>
            {{msg}}
            <!-- 2.让父组件模板里面调用的子组件动态绑定需要传递的值，绑定的名称自定义 -->
            <son :tt='info'></son>
        </div>
    </template>
    <!-- 子组件模板 -->
    <template id="s">
        <div>
            {{msg}}
            <br>
            <!-- 4.在子组件里面调用父组件里面传递过来的值 -->
            {{tt}}
        </div>
    </template>
</body>
</html>
<script>
    const vm = new Vue({
        el:'#app',
        data:{
            
        },
        methods:{
        
        },
        components:{
            father:{
                template:'#f',
                data(){
                    return {
                        msg:'我是父组件',
                        // 1.创建需要传递的值
                        info:'我是父组件传递给子组件的值'
                    }
                },
                components:{
                   son:{
                    template:"#s",
                    data(){
                        return {
                            msg:'我是子组件'
                        }
                    },
                    // 3.在子组件里面接受父组件传递的名称
                    props:['tt']
                   }
                }
            }
        }
    });
</script>   
  
```

### **Prop类型**

通常，我们只看到了以字符串数组形式列出的 prop：

```
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

但是，如果你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：

```js 
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}
```

### Prop 验证

我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。

为了定制 prop 的验证方式，你可以为 `props` 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：

```js
Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String, //数据类型
      required: true  //必填项
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100  //默认值
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propE: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
#注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。
```

测试price类型numer,设置默认值1000 

```js
 // 子组件
                components: {
                    son:{
                        template:'#s',
                        // 1、props定义在子组件中，表示期望接收到的值
                        //以对象类型存储 {a:b},a表示属性名，b表示数据类型
                        props: {
                            txt:String,
                            // price:Number
                            // 验证price  类型number 默认值1000

                            //把上面父组件调用子组件自定义标签中传递价格去掉
                            price:{
                                type:Number,
                                default:1000
                            }
                        },
```

### props 的使用

- props是只读的，Vue底层会检测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要更改，那么请复制props里的内容到data中一份，然后去修改data中的数据

- 与 data 一样，props 可以用在模板中
- 可以在 vm 实例中像 this.message 这样使用
- 与组件data函数return的数据区别
    - props的数据来自父级
    - data中数据是组件自己的数据

### 单向数据流

所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。

父组件===>子组件：vue允许的，会主动触发的，也叫正向传递。

子组件===>父组件：vue允许的，不会主动触发，需要手动（被动）触发，叫做逆向传递。



额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你**不**应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

这里有两种常见的试图变更一个 prop 的情形：

```js
#这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}

#这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```



### 子组件传值给父组件（$emit）

**自定义事件监听**

1、父组件将值传递给子组件，叫做正向传值，子组件将值传递给父组件，叫做逆向传值；需要借助 自定义事件
2、vue.js 中允许正向传值，所以正向传值不需要条件触发，是主动的；逆向传值，是不允许的，需要主动（手动）触发

1. 子组件创建需要传递的值*

​		

```js
template:'#s',
                        data(){
                            return {
                                msg:'我是子组件',
                                // 1.子组件创建需要传递的值
                                info:'我是子组件传递给父组件的值',
                            }
                         },
```

2.子组件创建一个方法，里面调用$emit方法，第一个值为父组件调用的自定义名称，第二个为传递的值

```js
 methods:{
                            // 2.创建一个方法，里面调用$emit方法，
                            // 第一个值为父组件调用的自定义名称，第二个为传递的值
                            change(){
                                this.$emit('to_father',this.info)
                            }
                        }         
```

3.子组件模板里面触发事件，调用传递函数* ，该事件触发，会连带着4的to_father事件一起触发，因为他俩绑定了-->*

```js
 <template id="s">
        <div>
            {{msg}}
            <!-- 3.子组件模板里面触发事件，调用传递函数 
                    该事件触发，会连带着4的to_father事件一起触发，
                    因为他俩绑定了-->
            <button @click="change">传值给父组件</button>
        </div>
    </template>
```

4.父组件模板里面调用子组件标签，并绑定子组件里面的自定义名称，并创建一个事件，事件里面默认传递的值为子组件需要传递值

```js
<template id="f">
        <div>
            {{msg}}
            <br>
            <!-- 4.父组件模板里面调用子组件标签，并绑定子组件里面的自定义名称
                并创建一个事件，事件里面默认传递的值为子组件需要传递值 -->
            <son @to_father="accept_"></son>
        </div>
```

5.父组件创建事件，子组件事件触发，该事件也会触发

```js
methods:{
                    // 5.父组件创建事件，子组件事件触发，该事件也会触发
                    accept_(v){
                        console.log(v);
                    }
                },
```

示例

```html
<body>
    <div id="app">
        <father></father>
    </div>
    <template id="f">
        <div>
            {{msg}}
            <br>
            <!-- 4.父组件模板里面调用子组件标签，并绑定子组件里面的自定义名称
                并创建一个事件，事件里面默认传递的值为子组件需要传递值 -->
            <son @to_father="accept_"></son>
        </div>
    </template>
    <template id="s">
        <div>
            {{msg}}
            <!-- 3.子组件模板里面触发事件，调用传递函数 
                    该事件触发，会连带着4的to_father事件一起触发，
                    因为他俩绑定了-->
            <button @click="change">传值给父组件</button>
        </div>
    </template>
</body>
</html>
<script>
    const vm = new Vue({
        el:'#app',
        data:{
            
        },
        methods:{
        
        },
        components:{
            father:{
                template:'#f',
                data(){
                    return {
                        msg:'我是父组件'
                    }
                },
                methods:{
                    // 5.父组件创建事件，子组件事件触发，该事件也会触发
                    accept_(v){
                        console.log(v);
                    }
                },
                components:{
                    son:{
                        template:'#s',
                        data(){
                            return {
                                msg:'我是子组件',
                                // 1.子组件创建需要传递的值
                                info:'我是子组件传递给父组件的值',
                            }
                         },
                        methods:{
                            // 2.创建一个方法，里面调用$emit方法，
                            // 第一个值为父组件调用的自定义名称，第二个为传递的值
                            change(){
                                this.$emit('to_father',this.info)
                            }
                        }                           
                    }
                }
            }
        }
    });
</script>
```

### 插槽（slot）

让父组件可以调用子组件的数据，并在父组件里面自定义样式

![image-20221106003527915](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221106003527915.png)

**匿名插槽**

```html
 <template id="f">
        <div id="f">
            <son>
                <p>我是匿名插槽</p>
            </son>
        </div>
    </template>
 <template id="s">
        <div id="s">
            <!-- 匿名插槽 -->
            <slot>如果没有分发内容，则显示默认提示</slot>
        </div>
    </template>
```

**具名插槽**

```html
 <template id="f">
        <div id="f">
            <son>
                <div slot="s1">我是具名插槽s1</div>
                <div slot="s2">我是具名插槽s2</div>
            </son>
        </div>
    </template>
 <template id="s">
        <div id="s">
            <!-- 具名插槽 -->
            <slot name="s1"></slot>
            <slot name="s2"></slot>
        </div>
    </template>
```

**插槽作用域**

**理解方式一： 和插槽相对**

**插槽**的作用是：父组件提供内容，在子组件中展示。

**作用域插槽**：子组件提供内容（数据），在父组件中展示。

**这里说的是表象，本质问题还是下面要说到的作用域。**



**理解方式二**： **延伸了子组件的作用域**

组件有**编译作用域**---父级模板里的所有内容都是在父级作用域中编译的，子模板里的所有内容都是在子作用域中编译的。

看看官方的例子---

定义一个子组件，有个具名插槽son，并且通过属性绑定子组件的数据user。

```js
const sonCom = {
      template: `
      <div>
        <slot name="son" :user="user">子组件数据：{{user.firstName}}</slot>
      </div>
      `,
      data() {
        return {
          user: {
            firstName: '三',
            lastName: '张'
          }
        }
      }
    }
```

父组件调用子组件时，假设不想展示firstName了，想展示lastName，按照下面这样写是不行的。

```text
  <div id="app">
    <son-com>{{user.lastName}}</son-com>
  </div>
```

因为user是在子组件的作用域中，父组件无法访问。

此时通过作用域插槽，可以做到。如下代码，通过v-slot指定绑定具名插槽son，通过自定义的scope接收子组件的user数据。

（注：v-slot指令是Vue2.6之后，作用域插槽的新语法，旧语法现在还保留，但3.0之后会移除。推荐新语法，简便写法是#son=“{user}”）

```text
  <div id="app">
    <son-com v-slot:son="scope">{{scope.user.lastName}}</son-com>
  </div>
```

从结果来看，可以认为作用域插槽延伸了子组件数据的作用范围，这样想，作用域插槽这个名字就不那么抽象了，而且顾名思义。



**使用场景**

例如，在使用elementUI组件库的表格组件时，表格的编辑和删除操作要用到作用域插槽。因为一个表格组件，就是当前组件的子组件。

此时我们通过作用域插槽很容易拿到当前表格行的索引和内容，这样就可以很方便地进行编辑展示、删除的操作。

并且，我们知道Vue是单向数据流。传递给子组件的数据，若要修改，应在父组件中处理。而我们通过作用域插槽，正好可以在父组件中修改数据，方便安全。

需要用新版的vue.js,否则报错

![image-20221106001501287](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221106001501287.png)

新版地址：https://cdn.jsdelivr.net/npm/vue@2.6.12

示例

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>韩</title>
    <link rel="stylesheet" href="">
    <!-- 版本太低会导致报错，需要新版本 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
    <style>
        *{
            margin: 0;
            padding: 0;
            list-style: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <father></father>
     </div>
     <template id="f">
         <div>
             <son>
                <!-- 3.用slot-scope直接获取2所接受的data数据,适用于匿名插槽
                        也可以用 v-slot：name="",或者#name="",适用于具名插槽>
                <!-- <template slot-scope="zz"> -->
                 <template #header="zz">
                     <div>
                        {{zz.msg}}
                        {{zz.list}}
                     </div>
                 </template>
              
             </son>
         </div>
     </template>
     <template id="s">
         <div>
            <!-- 2.prop方式传值 ,必须将需要的数据传入，否则3无法获取-->
             <slot :list="list" :msg="msg" name="header"></slot>
         </div>
     </template>
</body>
</html>
<script>
    const vm = new Vue({
        el:'#app',
        components:{
            father:{
                template:'#f',
                components:{
                    son:{
                        template:'#s',
                        data(){
                            return {
                                // 1.子组件创建数据
                                list:['java','html','css','js'],
                                msg:'搜索'
                            }
                        }
                    }
                }
            }

        }
    });
</script>
```

## CLI

### 安装

电脑里面必须有node.js和npm

安装： `npm install -g @vue/cli`

![image-20210520220050122](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520220050122.png)

1、命令框安装或者进行某些操作时报错，我的就是安装了Vue，查看Vue的版本报错



2、解决方法：在命令框输入set-ExecutionPolicy RemoteSigned

在PowerShell中输入会出现如下图，选择y或者a就可以了



在cmd中没有任何输出



检查：`vue --version`

 ![image-20210520220220116](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520220220116.png)



创建项目：`vue create 项目名称`

![image-20210520221403999](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520221403999.png)

按上下键，选择手动预设，即`Manually select features` 回车

 ![image-20210520223351757](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520223351757.png)

linter/Formatter 为es语法规范，选了写代码不规范便报错

选择2.0版本 回车

![image-20210520224055115](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520224055115.png)

![image-20210520224257988](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520224257988.png)



![image-20210520224530894](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520224530894.png)

![image-20210520224721509](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520224721509.png)

![image-20210520225203892](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520225203892.png)

开始输入命令，进入项目中，运行

![image-20210520225724052](E:/备份/学习视频/12_Vue/08 vueCli/08 vueCli/笔记/image/image-20210520225724052.png)



安装 ： `npm install -g @vue/cli`

检查：`vue --version`

创建项目：`vue create 项目名称`

```js
#提示选择preset
Default ([Vue 2] babel, eslint)  //默认vue 2 中的预设
Default (Vue 3 Preview) ([Vue 3] babel, eslint) //默认vue 3 中的预设
Manually select features //手动选择

#手动选择
Check the features needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection)  //选择将来项目中用到的依赖  空格：选择  a：全选  i：反选


```



### 项目结构解析

![image-20221106160945482](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221106160945482.png)

​													assets静态目录，也就是放一些图片的地方

​													除了上面这些文件需要使用之外，其他的文件都不需要动

### 项目运行步骤

1.在components目录下，下面创建小组件

HelloWorld.vue

```vue
<template>
  <div class="hello">
    <h1>{{ msg }}</h1>
  </div>
</template>

<script>
// 向外暴露该组件，让其他的组件可以接收到
export default {
  // 组件名称为HelloWorld
  name: 'HelloWorld',
  // 接收父组件的数据
  props: {
    //规定接收的数据类型
    msg: String
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<!-- scoped为该样式只作用于当前组件，lang为预编译处理器方式 -->
<style scoped lang="less">
h3 {
  margin: 40px 0 0;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
</style>

```

2.views目录下，页面级组件接收并使用小组件

HomeView.vue

```vue
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.png">
    <!-- 将需要展示的内容传到小组件里面，小组件里面有prop接收 -->
    <HelloWorld msg="Welcome to Your Vue.js App"/>
  </div>
</template>

<script>
// 接收components下面的小组件
import HelloWorld from '@/components/HelloWorld.vue'

export default {
  name: 'HomeView',
  components: {
    // 注册接收的小组件
    HelloWorld
  }
}
</script>

```

3.router目录下，路由页面级组件

index.js

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
//接收页面级组件
import HomeView from '../views/HomeView.vue'

Vue.use(VueRouter)

const routes = [
  {
    path: '/',//规定该路由的名称
    name: 'home',//重命名组件的名称
    component: HomeView //注册组件
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    // 箭头函数接收组件并注册，与上面方式不同
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
  }
]

const router = new VueRouter({
  routes
})
// 暴露路由
export default router

```

4.app.vue根组件路由页面级组件

```vue
<template>
  <div id="app">
    <nav>
      <!-- 路由第一个页面级组件，to后面是router下面index.js里面设置的路由名称 -->
      <!-- 并且路由标签里面需要添加内容，不然没有点击的地方，类似于超链接里面没有点击的地方 -->
      <!-- button按钮里没有文字撑开盒子用于点击 -->
      <router-link to="/">Home</router-link> |
      <!-- 路由第二个页面级组件 -->
      <router-link to="/about">About</router-link>
    </nav>
    <router-view/>
  </div>
</template>

<style lang="less">
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}

nav {
  padding: 30px;

  a {
    font-weight: bold;
    color: #2c3e50;

    &.router-link-exact-active {
      color: #42b983;
    }
  }
}
</style>

```

5.main.js主js入口文件下，挂载el到html入口文件

```js
// 接收vue，vue是在node_modules目录下面
import Vue from 'vue'
// 接收根组件
import App from './App.vue'
// 接收路由
import router from './router'
// 接收vuex
import store from './store'

Vue.config.productionTip = false

new Vue({
  router,
  store,
  render: h => h(App)//把app组件挂载到#app上面
}).$mount('#app')//mount挂载到app上面，app是在index.html里面定义的div的id

```

### 单文件组件传值

**父传子**

子组件 myHome.vue

```vue
<template>
    <div>
        <h1>第一个组件myHome</h1>
        {{getBa}}
    </div>
</template>

<script>
export default {
    props: {
        getBa:strig
    },
};
</script>

<style scoped lang="less">
    h1{
        color: skyblue
    }
</style>

```

父组件 HomeView.vue

```vue
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.png">
    <!-- 将需要展示的内容传到小组件里面，小组件里面有prop接收 -->
    <myHome :getBa="set_son"></myHome>
  </div>
</template>

<script>
// 接收components下面的小组件
import myHome from '@/components/myHome.vue'
export default {
  name: 'HomeView',
  data(){
    return {
      set_son:'我是父亲给儿子的值'
    }
  },
  components: {
    // 注册接收的小组件
    myHome
  }
}
</script>

```

**子传父**

子组件  myHome.vue

```vue
<template>
    <div>
     <!--点击按钮才传值
     		<input type="text" v-model="val">
        <button @click="sendBa">传值给父亲</button>
			-->
     <!-- 时刻传值
        	子传父如果不想用按钮，而是想子动父动，那么就用@input绑定事件，每一次更改input框便触发一次事件    -->
      <input type="text" @input="sendBa" v-model="val">
    </div>
</template>

<script>
export default {
    data() {
        return {
            val:'我是给父亲的值'
        };
    },
    methods: {
        sendBa(){
            this.$emit('sendBa',this.val)
        }
    },
};
</script>

<style scoped lang="less">
    h1{
        color: skyblue
    }
</style>

```

父组件 HomeView.vue

```vue
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.png">
    <myHome @sendBa="getV"></myHome>
    <p>我儿子传过来的值为：{{son}}</p>
  </div>
</template>

<script>
// 接收components下面的小组件
import myHome from '@/components/myHome.vue'
export default {
  data(){
    return {
      son:''
    }
  },
  methods:{
    getV(v){
      this.son=v
    }
  },
  components: {
    // 注册接收的小组件
    myHome,
  }
}
</script>

```

## 路由

### 路由配置

1.安装路由

当安装cli，没装路由时

`npm install --save vue-router@3.5.3`

2.在components下面创建两个组件

Home.vue

```vue
<template>
    <div>
      我是Home
    </div>
</template>

<script>
export default {
    props: {

    },
};
</script>
<style scoped lang="less">
</style>

```

About.vue

```vue
<template>
    <div>
      我是About
    </div>
</template>

<script>
export default {
    props: {

    },
};
</script>
<style scoped lang="less">
</style>

```

3.创建一个reouter文件夹，里面创建一个index.js

index.js

```js
// 引入配置文件
import Vue from 'vue'
import VueRouter from 'vue-router'
// 引入组件
import Home from './../views/Home'
import About from './../views/About'

// 使用VueRouter
Vue.use(VueRouter)

// 创建一个新的VueRouter对象
const Router = new VueRouter({
    // 配置路由，因为是数组，所以可以配置多个路由
    routes:[
        {
            path:'/',//定义路由路径
            //路由所映射的组件
            //1.直接导入引入
            component:Home,
            //2.路由懒加载，多用，提高代码性能
            // component:()=>import('./../views/Home')
            name:'home'//命名路由
        },
        {
            path:'/about',
            component:About,
            name:'about'
        }
    ],
    mode:'hash' //使用URL hash值来做路由，支持所有浏览器
})

//暴露路由，让main.js可以接收
export default Router
```

4.配置main.js

```js
//引入配置
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false//阻止vue启动生产消息，

//接收index.js,这里的名字必须为router
import router from './router/index'
new Vue({
  router,//注册router
  render: h => h(App),
}).$mount('#app')

```

5.配置App.vue

```vue
<template>
  <div id="app">
    <!-- 路由入口 -->
   <ul>
    <li>
      <router-link to="/">Home</router-link>
    </li>
    <li>
      <router-link to="/about">About</router-link>
    </li>
   </ul>
   <!-- 路由出口，与路由入口为兄弟关系 -->
   <router-view></router-view>
  </div>
</template>

<script>

export default {
  name: 'App',
  components: {
 
  }
}
</script>

```

### 路由样式配置

方式1

​		App.vue

​												![image-20221113110109010](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221113110109010.png)		

​												![image-20221113110132049](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221113110132049.png)

方式2

​		App.vue

![image-20221113105803970](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221113105803970.png)

​												![image-20221113105847586](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221113105847586.png)

​		index.js

​												![image-20221113105942061](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221113105942061.png)

### 一、二级路由及重定向

​	一级路由

```js
const Router = new VueRouter({
    // 配置路由，因为是数组，所以可以配置多个路由
    routes:[
        {
            path:'/',//定义路由路径
            //路由所映射的组件
            //1.直接导入引入
            component:Home,
            //2.路由懒加载
            // component:()=>import('./../views/Home')
            name:'home',//命名路由
            
        },
        {
            path:'/about',
            component:About,
            name:'about'
        }
    ],
    mode:'hash', //使用URL hash值来做路由，支持所有浏览器，
    // linkActiveClass:'act'
})
```

二级路由

```js
 {
            path:'/',//定义路由路径
            //路由所映射的组件
            //1.直接导入引入
            component:Home,
            //2.路由懒加载
            // component:()=>import('./../views/Home')
            name:'home',//命名路由
            //在一级路由下面添加一个children，里面的内容与一级路由结构相似
            children:[
                {
                    // 重定向，就是当页面为/时显示什么组件，然后你说我找不到，你去找/about/rihan吧
                    path:'/',
                    //所以redirect便是你推荐它去找谁，而转发则为，页面需要找/页面时需要显示的组件
                    // 你说我没有，但是我可以去借，我去借/about/rihan的组件然后给你
                    redirect:'/about/rihan'
                },
                {		
                  //必须要加/about，因为需要明确是哪个一级路由下的二级路由
                    path:'/about/oumei',
                    component:()=>import('./../components/oumei'),
                    name:'oumei'
                },
                {
                    path:'/about/rihan',
                    component:()=>import('./../components/rihan'),
                    name:'rihan'
                },
                {
                    path:'/about/guochan',
                    component:()=>import('./../components/guochan'),
                    name:'guochan'
                }
            ]
        },
        {
            path:'/about',
            component:About,
            name:'about'
        }
```



### 路由传参

​		把路由的名字传到路由里面

1.在index.js里面创建两个路由

```js
 				{
            path:'/news',
            component:()=>import('./../components/news/News.vue'),
        },
        {
          //即路由的名称自定义，但是不管名字是哪个，跳转的都为同一个组件
          //动态路径参数，以冒号开头
            path:'/news/:new_id',
            component:()=>import('./../components/news/NewsDeatil.vue'),
        },
```

2.创建一个文件夹news，里面创建两个文件，News.vue与NewsDeatil.vue

News.vue

```vue
<template>
    <div>
        <h1>----------news------------</h1>
        <!-- 父组件模板 -->
        <ul>
            <li>
                <router-link to="/news/0001">新闻1</router-link>
            </li>
            <li>
                <router-link to="/news/0002">新闻2</router-link>
            </li>
            <li>
                <router-link to="/news/0003">新闻3</router-link>
            </li>
            <li>
                <router-link to="/news/0004">新闻4</router-link>
            </li>
            <li>
                <router-link to="/news/0005">新闻5</router-link>
            </li>
        </ul>
        <router-view></router-view>
    </div>
</template>
```

NewsDeatil.vue

```vue
<template>
    <div>
       <!-- 获取路由名称 -->
        新闻id：{{this.$route.params.new_id}}
    </div>
</template>
```

此时在父组件News.vue里面无论点击哪一个路由，子组件NewsDeatil.vue都会显示路由名称

### 编程式路由

即不用router标签，而是绑定事件，事件里面跳转路由

```vue
<template>
  <div id="app">
    <!-- 路由入口 -->
   <ul class="router">
    <li>
      <router-link to="/">Home</router-link>
    </li>
    <li>
      <router-link to="/about">About</router-link>
    </li>
    <li>
      <router-link to="/news">News</router-link>
    </li>
    <!-- 编程式跳转路由入口，与router一样需要出口 -->
    <li>
      <button @click="goHome">我也是电影区</button>
    </li>
    <li>
      <button @click="goNews">我去新闻</button>
    </li>
   </ul>
   <!-- 路由出口，与路由入口为兄弟关系 -->
   <router-view></router-view>
  </div>
</template>

<script>

export default {
  name: 'App',
  components: {
 
  },
  methods:{
    goHome(){
      // 编程式路由入口  this.$router.push('路径')
      //                this.$router.push({path:'路径'})                          
      // this.$router.push({path:'/'})
      // 编程式路由跳转到命名路由
      //    给路由起一个name，根据name来跳转
      this.$router.push({name:'home'})
    },
    goNews(){
      // 编程式路由传参，并直接跳转到页面
      // 1.正常显示地址
      this.$router.push({name:'news',params:{new_id:'002'}})
      // 2.用问号显示地址
      this.$router.push({name:'news',query:{new_id:'002'}})
    }
  }
}
</script>
<style>
  .router a{
    text-decoration: none;
  }
  .router-link-exact-active{
    color: red;
  }
  ul{
    width: 100%;
    display: flex;
    justify-content: space-around;
  }
  /* .act{
    color: red;
  } */
</style>
```

index.js里面的路由

```js
// 引入配置文件
import Vue from 'vue'
import VueRouter from 'vue-router'
// 引入组件
import Home from './../views/Home'
import About from './../views/About'

// 使用VueRouter
Vue.use(VueRouter)

// 创建一个新的VueRouter对象
const Router = new VueRouter({
    // 配置路由，因为是数组，所以可以配置多个路由
    routes:[
        {
            path:'/',//定义路由路径
            //路由所映射的组件
            //1.直接导入引入
            component:Home,
            //2.路由懒加载
            // component:()=>import('./../views/Home')
            name:'home',//命名路由
            children:[
                {
                    // 重定向，就是当页面为/时显示什么组件，然后你说我找不到，你去找/about/rihan吧
                    path:'/',
                    //所以redirect便是你推荐它去找谁，而转发则为，页面需要找/页面时需要显示的组件
                    // 你说我没有，但是我可以去借，我去借/about/rihan的组件然后给你
                    redirect:'/about/rihan'
                },
                {
                    path:'/about/oumei',
                    component:()=>import('./../components/oumei'),
                    name:'oumei'
                },
                {
                    path:'/about/rihan',
                    component:()=>import('./../components/rihan'),
                    name:'rihan'
                },
                {
                    path:'/about/guochan',
                    component:()=>import('./../components/guochan'),
                    name:'guochan'
                }
            ]
        },
        {
            path:'/about',
            component:About,
            name:'about'
        },
        {
            path:'/news',
            component:()=>import('./../components/news/News.vue'),
        },
        {		//name不能相同，是唯一的
            path:'/news/:new_id',
            component:()=>import('./../components/news/NewsDeatil.vue'),
            name:'news'
        },
    ],
    mode:'hash', //使用URL hash值来做路由，支持所有浏览器，
    // linkActiveClass:'act'
})

//暴露路由，让main.js可以接收
export default Router
```

NewsDeatil.vue

```vue
<template>
    <div>
        <!-- 获取路由名称 -->
        新闻id：{{this.$route.params.new_id}}
        新闻id：{{this.$route.query.new_id}}
    </div>
</template>
```

### 路由守卫

即路由跳转前、中、后期间所触发的钩子函数

示例：当路由跳转前判断是否登录，如果已经登录则显示购买页，如未登录则跳转登录页

index.js

```js
// 引入配置文件
import Vue from 'vue'
import VueRouter from 'vue-router'
// 引入组件
import Home from './../views/Home'
import About from './../views/About'

// 使用VueRouter
Vue.use(VueRouter)

// 创建一个新的VueRouter对象
const Router = new VueRouter({
    // 配置路由，因为是数组，所以可以配置多个路由
    routes:[
        {
            path:'/about',
            component:About,
            name:'about'
        },
        {
            path:'/buy',
            component:()=>import('../components/buy.vue'),
        },
        {
            path:'/login',
            component:()=>import('../components/login.vue'),
        },
    ],
    mode:'hash', //使用URL hash值来做路由，支持所有浏览器，
    // linkActiveClass:'act'
})
// 全局守卫
//跳转前触发，前面的Router为上面的路由实例
Router.beforeEach((to, from, next) => { //to.Route :即将要进入到路由对象
                                        //from:Router ：当前导航正要离开的路由
                                        //next:Function :一定要调用该方法来resolve这个钩子
                                        //next('/')或者next({ path:'/'}) :跳转到一个不同的的地址 
    // 如果跳转buy组件时，且取反isLogin，因为此时isLogin为空，也就是未登录，
    // 取反则为true，便可以使用if条件，然后如果未登录，则跳转登录页面，
  	//因为上面buy.vue里面有退出登录按钮，点击后令isLogin为false，这里每一次可以检测，是否为false
  	//如果为则跳转登录页
if(to.fullPath == '/buy' && (!localStorage.getItem('isLogin')|| localStorage.getItem('isLogin')=='false')){
        next('/login')
    }
    // 如果没有条件限制，则路由该跳转哪就跳转哪
    next()    
})
//暴露路由，让main.js可以接收
export default Router
```

buy.vue

```vue
<template>
    <div>
        <h1>买买买</h1>
     	  <button @click="esc_login">退出登录</button>
    </div>
</template>
<script>
export default {
    methods: {
       esc_login(){
         //点击退出登录按钮后，令isLogin为false，并且跳转到about页面
        localStorage.setItem('isLogin',false),
        this.$router.push({path:'/about'})
       }
    },
};
</script>
```

login.vue

```vue
<template>
    <div>
        <h1>--------登录页-----------</h1>
        <button @click="login">登录</button>
        <router-view></router-view>
    </div>
</template>

<script>
export default {
    methods: {
        login(){
            //1.存值 islogin true
            localStorage.setItem('isLogin',true)
            //变成路由，回到首页
            this.$router.push('/')
        }
    },

};
</script>


```

## VUEX

​	当做大项目时，组件直接来回传值麻烦，将一些普遍使用的数据集中起来，让各个组件都方便使用，集中制

​			Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态

​	![image-20221115192725599](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221115192725599.png)

创建项目建议直接使用CLI脚手架安装VUEX，单独安装因为版本原因经常报错

### 数据结构

```js
// 创建vuex模块文件，开始使用vuex
import Vue from 'vue'
import Vuex from 'vuex'

// 在一个模块化打包系统中，必须显式的通过`Vue.use()`来安装Vuex
Vue.use(Vuex)

// 实例化Vuex.Store,并进行配置
export default new Vuex.Store({
  state: {
    // 储存状态
    num:0,
  },
  getters: {
    // state的派生状态
    // 类似计算属性，可以过滤数据
  },
  mutations: {
    // 同步操作,可以改变state数据状态
    // 因为不能直接更改state里面数据，需要用mutation进行更改
  },
  actions: {
      // 异步操作,可以改变state数据状态  
  },
  modules: {
    // 将store分割成模块
  }  
})

```

### state

组件获取数据

index.js

```js
state: {
    // 储存状态
    num:0,
  },
```

Home.vue

```vue
<template>
  <div class="home">
    <!--方式一：直接获取 !-->
    <p>vuex中state的num：{{this.$store.state.num}}</p>
    <!--方式二，用计算属性返回!-->
    <p>vuex中计算属性：{{vuex_num}}</p>
  </div>
</template>

<script>
export default {
  //计算属性返回VUEX里面的数据
  computed:{
    vuex_num:function(){
      return this.$store.state.num
    }
  },
}
</script>

```

### Mutation

更改state里面数据，并且可以同步追踪，但是不要用异步操作，不然数据不准确，异步操作必须放在actions里面

index.js

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    // 储存状态
    num:0,
  },
  mutations: {
    // 因为不能直接更改state里面数据，需要用mutation进行更改
    // 变更store中的状态，同步操作
    change_num(state,v){
      // 同步操作,可以改变数据状态
      state.num+=v
      // 在mutations里面进行异步操作有延迟，会让数据不准确，应把异步操作都放在action里面
    //   setTimeout(function(){
    //     state.num+=v
    //   },1000)
    }
  }
})

```

About.vue

```vue
<template>
  <div class="about">
    <!-- 点击按钮，触发函数 -->
    <button @click='change_num'>num增值</button>
    <p>vuex中state的num：{{this.$store.state.num}}</p>
    </p>
  </div>
</template>

<script>
  export default{
    methods:{
      change_num(){
        //获取mutations里面的函数数据
        // 这里的change_num是store文件夹下面index.js里mutation里面的函数
        this.$store.commit('change_num',1)
      },
    }
  }
</script>
```



### Actions

Action 类似于 mutation，不同在于：

- Action 提交的是 mutation，而不是直接变更state状态。

- Action 可以包含任意异步操作。

    ```js
    import Vue from 'vue'
    import Vuex from 'vuex'
    
    Vue.use(Vuex)
    
    export default new Vuex.Store({
      state: {
        num:0,
      },
      mutations: {
        // 因为不能直接更改state里面数据，需要用mutation进行更改
        // 变更store中的状态，同步操作
        change_num(state,v){
          // 在mutations里面进行异步操作有延迟，会让数据不准确，应把异步操作函数让action同步
          //mutation里面的异步操作，如setTimeout会不起作用，若想异步操作，必须使用action来异步
          // setTimeout(function(){
          // state.num+=v
       	  // },1000)
          //这里使用同步操作
          state.num+=v
        }
      },
      actions: {
          // 异步操作,可以改变数据状态
          // actions函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 
          // 提交一个 mutation,或者通过 context.state 和 context.getters 来获取 state 和 getters
          addNum (context,v){
            setTimeout(function(){
              context.commit('change_num',v)
            },1000)
          }
        
      },
      modules: {
        // 将store分割成模块
      }
      
    })
    ```

    

### Getters

类似计算属性

index.js

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    list:[
      {name:'李雷',age:18},
      {name:'韩梅梅',age:18},
      {name:'Luck',age:18},
      {name:'uncle王',age:58},
    ]
  },
  getters: {
    // state的派生状态
    // 类似计算属性，可以过滤数据
    //传参，传入state的数据
    filter_age(state){
      //filter为过滤器，第一个item为list里面的每一条数据，第二个item为每条数据的age
      // 用箭头函数，类似循环遍历，最后返回每一个符合条件的结果
      return state.list.filter(item=>item.age<30)
    }
  },
})

```

About.vue

```vue
<template>
  <div class="about">
    <p>过滤后的数据</p>
    <!--   -->
    <!-- 直接获取getters里面的属性  -->
    {{this.$store.getters.filter_age}}
    <!-- 点击按钮，循环出想要的数据  -->
    <button @click="show_name">显示姓名</button>
    <!-- 原本list为空，什么都不显示，点击按钮才会显示数据  -->
    <p v-for= "(item,index) in list" :key="index">
    {{item.name}}
    </p>
  </div>
</template>

<script>
  export default{
    data:function(){
      return {
        list:[]
      }
    },
    methods:{
      show_name(){
        //把getters里面的数据赋给组件
        this.list = this.$store.getters.filter_age
      }
    }
  }
</script>
```

### Module

由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。

为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：

```js
const moduleA = {
  state: () => ({ xx }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
//使用：this.$store.state.a.xx
```



## 微信小程序开发

与W3C的不同

div变成了view

img变成了image，地址需要./../../

没有ul与li，需要view套view

span变成了text

### 可移动视图容器

[movable-view](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html)的可移动区域

[movable-view](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html)必须在 [movable-area](https://developers.weixin.qq.com/miniprogram/dev/component/movable-area.html) 组件中，并且必须是直接子节点，否则不能移动。

示例

```xml
<view>
  <movable-area class="movable_area">
    <!-- direction为移动的方向 -->
    <movable-view  class="movable_view " direction="all">
      
    </movable-view>
  </movable-area>
</view>
```

### swiper

滑块视图容器。其中只可放置[swiper-item](https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html)组件，否则会导致未定义的行为

swiper-item仅可放置在[swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)组件中，宽高自动设置为100%。

| 属性                   | 类型    | 默认值            | 最低版本                                              |
| :--------------------- | :------ | :---------------- | :---------------------------------------------------- |
| indicator-dots         | boolean | false             | 是否显示面板指示点                                    |
| indicator-color        | color   | rgba(0, 0, 0, .3) | 指示点颜色                                            |
| indicator-active-color | color   | #000000           | 当前选中的指示点颜色                                  |
| autoplay               | boolean | false             | 是否自动切换                                          |
| current                | number  | 0                 | 当前所在滑块的 index                                  |
| interval               | number  | 5000              | 自动切换时间间隔                                      |
| duration               | number  | 500               | 滑动动画时长                                          |
| circular               | boolean | false             | 是否采用衔接滑动                                      |
| vertical               | boolean | false             | 滑动方向是否为纵向                                    |
| previous-margin        | string  | "0px"             | 前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值 |

### 图标组件icon

| 属性  | 类型          | 必填 | 说明                                                         |
| :---- | :------------ | :--- | :----------------------------------------------------------- |
| type  | string        | 是   | icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size  | number/string | 否   | icon的大小，单位默认为px，[2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)起支持传入单位(rpx/px)，[2.21.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)起支持传入其余单位(rem 等)。 |
| color | string        | 否   | icon的颜色，同 css 的color                                   |

示例：<img src="C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221107165810767.png" alt="image-20221107165810767" style="zoom:50%;" />

```xml
<icon type="success" color="gray" size="90"/>
```

### todoList

- wx:for循环，里面只需要写入需要循环的数组就行了，会默认（item in 数组)     
- wx:key绑定键值
- bindtap点击事件，但是不会阻止冒泡。而catchtap会阻止冒泡

- 响应式数据this.setData

​		list为data里面的数据，this.data.list为当前事件里面的数据
​		因为原数据还没有变化，而事件里的list已经发生了变化，为了让data里面的数据同步，
​		则需要让data里面的数据响应更改

![image-20221107205938018](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221107205938018.png)

inedx.wxml

```xml
<!-- 创建一个大盒子，让里面的内容都用flex都居中 -->
<view class="main">
  <view class="add" bindtap="goDo">
  +待办事项
</view>
<!-- 再创建一个盒子，效果类似于ul -->
<view class="list">
  <!-- 这个盒子类似于li，
        wx:for循环，里面只需要写入需要循环的数组就行了，会默认（item in 数组)     
        wx:key绑定键值
        bindtap点击事件，但是不会阻止冒泡。而catchtap会阻止冒泡
        id绑定键值
        -->
  <view wx:for="{{list}}" wx:key="index" bindtap="change" id="{{index}}">
    <!-- 获取数据，如果为true则显示对号图标，如果为false则显示空白图标 -->
    <icon type="{{(item.finish)? 'success':'circle'}}"/>
    <!-- 获取数据，如果为true则绑定class，更改样式，为false则不变 -->
    <text class="{{item.finish?'active':''}}">{{item.text}}</text>
  </view>
</view>
</view>
```

index.js

```js
Page({
  data: {
    //需要的数据
    list:[
      {text:'学习击剑',finish:false},
      {text:'学习钢琴',finish:false},
      {text:'学习跳舞',finish:false},
      {text:'学习游泳',finish:false}
    ]
  },
  //点击事件，当wxml页面点击后触发，与data为同级，并传入值，传入的值为所点击模块的信息
  change(e){
    // 因为点击后获取到的模块带有id，id正好对应着键值，所以点击哪个模块，获取其键值
    // 然后更改这个键值的finish，便达到了点击改变状态的功能
    let index = e.currentTarget.id;
    // 每点击一次都会取反
    this.data.list[index].finish = !this.data.list[index].finish;
    // 响应事件，更改data里面的数据
    this.setData({
      // list为data里面的数据，this.data.list为当前事件里面的数据
      // 因为原数据还没有变化，而事件里的list已经发生了变化，为了让data里面的数据同步，
      // 则需要让data里面的数据响应更改
      list:this.data.list
    })
  },
  goDo(){
    // 跳转页面，但是不能跳转到toBar所包含的页面
    // wx.navigateTo({
    //   url: '/pages/logs/logs',
    // })
    // 专门跳转到toBar所包含的页面
    wx.switchTab({
      url: '/pages/dos/dos',
    })
  }
})
```



### 获取用户信息

**wx.getUserProfile**:https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserProfile.html



home.wxml

```xml
<view class="main">
  <!-- 该logo盒子与button为兄弟关系，且紧挨，当logo里面的if成立时显示logo盒子里面东西
        为空则false，不为空则true           当不成立时，则显示else里面的东西
  因为刚开始没有获取数据，if不成立，不显示logo盒子里面的内容，显示button里面的内容 -->
  <view class="logo" wx:if="{{userinfo.avatarUrl}}">
    <image src="{{userinfo.avatarUrl}}" alt="" srcset=""/>
    <view>
    {{userinfo.nickName}}
    </view>
  </view>
  <!-- 点击盒子，获取数据，logo里面的if成立，则显示if里面的内容，删除button里面的内容 -->
 <button bindtap="getUserProfile" wx:else>获取用户信息</button>
 
</view>

```

home.js

```js
Page({
  data: {
    //创建一个空属性用来接收数据
    userinfo:{}
  },
  // 点击事件
  getUserProfile(){
    // 为获取用户信息事件
    wx.getUserProfile({
      // 用户是否允许小程序获取其信息
      desc:'完善信息',
      // 获取信息
      success:(res)=>{
        console.log(res);
        // 响应更改数据
        this.setData({
          // 将获取到的数据赋到data里面
          userinfo:res.userInfo
        })
       // 将数据存储到本地
        wx.setStorage({
          //取一个键值，方便getStorage调用
          key:"user",
          //创建一个属性，将数据放入里面，
          data:res.userInfo
        })
      },  
    })
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    // 当页面加载时，调用数据
    wx.getStorage({
      //必须与存入的键值相同才能获取到那个setStorgage储存的数据
      key:"user",
      // 将数据赋给data里面的userinfo，这样加载时，userinfo就不为空，便直接显示内容，而不显示button按钮了
      success:(res)=>{//回调函数
        console.log(res);
        this.setData({
          userinfo:res.data
        })
      }
    })
  },
}) 
```

### 获取位置

home.js

```js
Page({
  data: {
    //创建一个空属性用来接收数据
    userinfo:{},
    接收坐标
    //location:{},
  	//接收地图选取的数据
    Location:{}
  },
  // 点击事件
  getUserProfile(){
    //1.允许获取当前地理位置
   wx.getLocation({
      type: 'wgs84',//wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标
      success:(res)=>{
        console.log(res);
        this.setData({
          //赋值给data
          location:res
        })
        //请求位置失败返回值
        fail:(e)=>{
          console.log(e);
        }
        //2.将数据存入本地
        wx.setStorage({
          //取一个键值，方便getStorage调用
          key:"location",
          //创建一个属性，将数据放入里面，
          data:res
        })
      }
     })
     
  },
  // 打开地图选取位置
    getLocation(){
    // 打开地图选取位置
    wx.chooseLocation({
      success:(res) => {
        console.log(res);
        //赋值给data
        this.setData({
          Location:res
        })
      },
      //请求失败返回值
      fail:(e)=>{
        console.log(e);
      }
     
    })
  },
  onLoad(options) {
    // 3.当页面加载时，调用数据
    wx.getStorage({
      //必须与存入的键值相同才能获取到那个setStorgage储存的数据
     	key:"location",
      // 将数据赋给data里面的userinfo，这样加载时，userinfo就不为空，便直接显示内容，而不显示button按钮了
      success:(res)=>{
        console.log(res);
        this.setData({
          location:res.data
        })
      }
    }),
   }
})      
```



### 小程序登录流程

​	我们前端只需要用到左半部分，右半部分是服务端的

![image-20221108092647744](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221108092647744.png)

1. 调用 [wx.login()](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html) 获取 **临时登录凭证code** ，并回传到开发者服务器。
2.   wx.request,发起 HTTPS 网络请求
3. 调用 [auth.code2Session](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html) 接口，换取 **用户唯一标识 OpenID** 和 **会话密钥 session_key**。

​		之后开发者服务器可以根据用户标识来生成自定义登录态（token），用于后续业务逻辑中前后端交互时识别用户身份。

home.js

```js
Page({
  data: {
    //创建一个空属性用来接收数据
    userinfo:{}
  },
  // 点击事件
  getUserProfile(){
    // 为获取用户信息事件
    wx.getUserProfile({
      // 用户是否允许小程序获取其信息
      desc:'完善信息',
      // 获取信息
      success:(res)=>{
        console.log(res);
        // 响应更改数据
        this.setData({
          // 将获取到的数据赋到data里面
          userinfo:res.userInfo
        })
       // 将数据存储到本地
        wx.setStorage({
          //取一个键值，方便getStorage调用
          key:"user",
          //创建一个属性，将数据放入里面，
          data:res.userInfo
        })
        // 获取登录临时凭证code，并传回开发者服务器
        wx.login({
          // 回调函数接收凭证
          success: (res) => {
            console.log(res)
            // 发起 HTTPS 网络请求
            wx.request({
              // 开发者服务器接口地址，地址 & id & 密钥 & 凭证 & 授权授予
              url: `https://api.weixin.qq.com/sns/jscode2session?appid=  &secret=  &js_code=${res.code}&grant_type=authorization_code`,
              // 回调接收返回的数据，如果接收到openid 和 session_key则说明发送请求成功
              success:(res)=>{
                如果接收到
                console.log(res)
              }
            })
          },
        })
      },  
    })
  },
})
```

若报错

![image-20210605001632227](E:/备份/学习视频/13_微信小程序/2、登陆授权/笔记/assets/image-20210605001632227.png)



![image-20210605001903148](E:/备份/学习视频/13_微信小程序/2、登陆授权/笔记/assets/image-20210605001903148.png)

### 本地生活项目

1.app.json文件里面配置tabBar

​		![image-20221112001542458](C:\Users\22776\AppData\Roaming\Typora\typora-user-images\image-20221112001542458.png)

​	   创建三个导航页，再创建一个详情页（list）

​		pagepath：是导航地址

​		navigationBarTitleText：导航名字

​		iconPath：是未选中时照片，

​		selectedIconPath：是选中时的照片

```json
{
    "pages": [
        "pages/home/home",
        "pages/news/news",
        "pages/mine/mine",
        "pages/list/list"
    ],
    "window": {
        "backgroundTextStyle": "light",
        "navigationBarBackgroundColor": "#fff",
        "navigationBarTitleText": "本地生活",
        "navigationBarTextStyle": "black"
    },
    "tabBar": {
      "list": [{
        "pagePath": "pages/home/home",
        "text": "首页",
        "iconPath": "/pages/images/home.png",
        "selectedIconPath": "/pages/images/home-active.png"
      },
      {
        "pagePath": "pages/news/news",
        "text": "消息",
        "iconPath": "/pages/images/message.png",
        "selectedIconPath": "/pages/images/message-active.png"
      },
      {
        "pagePath": "pages/mine/mine",
        "text": "我的",
        "iconPath": "/pages/images/profile.png",
        "selectedIconPath": "/pages/images/profile-active.png"
      }]
    },
    "style": "v2",
    "sitemapLocation": "sitemap.json"
}
```

2.request目录下的index.js,封装获取接口数据模块

```JS
module.exports = (url,data,method = 'get')=>{
  wx.showLoading({
    title: '加载中',
  })
  return new Promise((resolve,reject) =>{
    wx.request({
      url: `https://applet-base-api-t.itheima.net${url}`,
      data,
      method,
      success:(res)=>{
        resolve(res);
        wx.hideLoading({
          success:(res)=>{}
        })
      },
      fail:(erro)=>{
        reject(erro)
      }
      // success:resolve,
      // fail:reject,
    })
  })
  
}
```

3.home.js获取接口数据

```JS
let http = require('./../../request/index')
Page({
  /**
   * 页面的初始数据
   */
  data: {
    swiperImg:[],
    list:[]
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    http('/slides').then(res=>{
      // console.log(res);
      this.setData({
        swiperImg:res.data
      })
    }),
    http('/categories').then(res=>{
      // console.log(res);
      this.setData({
        list:res.data
      })
    })
  },
})
```

4.home.wxml配置主页面

```xml
<!-- 轮播图 -->
<swiper indicator-dots="true" autoplay="true" interval="2000" circular="true" class="swiper">
  <swiper-item> 
    <image src="/pages/images/home/banner-01.png" mode=""/>
  </swiper-item>
  <swiper-item>
    <image src="/pages/images/home/banner-02.png" mode=""/>
  </swiper-item>
</swiper>
<!-- 九宫格 -->
<view class="main">
  <!-- navigator为跳转页面链接，url为要跳转的地址，在home.js里面已经在页面启动时获取了接口数据
  并把值赋给了item，？后面为要传的值，因为九宫格九个id，从1~9，每个id所代表的接口数据不同，
  请求的接口数据也不同， 显示的页面也不同，从而达到每点击一个格子，跳转到指定的页面-->
  <navigator url="/pages/list/list?id={{item.id}}" wx:for="{{list}}" class="option">
    <!-- 获取接口的图片和名字 -->
    <image src="{{item.icon}}" mode=""/>
    <text>{{item.name}}</text>
  </navigator>
</view>
<!-- 下方两个格子 -->
<view class="fotter">
  <view class="go_link">
    <image src="/pages/images/home/link-01.png" mode=""/>
    <image src="/pages/images/home/link-02.png" mode=""/>
  </view>
</view>
```

5.详情页list.js获取数据

```JS
// pages/list/list.js
let http = require('./../../request/index')
Page({
  /**
   * 页面的初始数据
   */
  data: {
    list:[]
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    http(`/categories/${options.id}/shops`).then(res=>{
      // console.log(res);
      wx.setNavigationBarTitle({
        title: options.name,
      })
      this.setData({
        list:res.data
      })
    })
  },
})
```

6.详情页html渲染数据

```XML
<view class="list" wx:for="{{list}}">
  <image src="{{item.images[0]}}" mode=""/>
  <view class="info">
    <view>{{item.name}}</view>
    <view>电话：{{item.phone}}</view>
    <view>地址：{{item.address}}</view>
    <view>营业时间：{{item.businessHours}}</view>
  </view>
</view>

```

## pm2管理服务器

![image-20221225165718935](md%E5%9B%BE%E7%89%87%E5%AD%98%E6%94%BE/image-20221225165718935.png)
